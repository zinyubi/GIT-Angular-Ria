import{ProgrammingError}from"../error/ProgrammingError.js";import{CoordinateType}from"../reference/CoordinateType.js";import{isArray,isNumber,isUndefined}from"../util/Lang.js";import{Shape}from"./Shape.js";import{ShapeType}from"./ShapeType.js";import{ShapeUtil}from"./ShapeUtil.js";export class ComplexPolygon extends Shape{constructor(e,o){super();this._reference=e;this._polygonList=[];this._coordinates=[];if(isArray(o))this.addPolygons(o)}get type(){return ShapeType.COMPLEX_POLYGON}get coordinates(){return this._coordinates}get coordinateType(){return this._reference?this._reference.coordinateType:CoordinateType.CARTESIAN}get polygonCount(){return this._polygonList.length}get focusPoint(){if(isUndefined(this._focus))this._focus=this.bounds?this.bounds.focusPoint:null;return this._focus}get bounds(){if(isUndefined(this._bounds)){const e=this._polygonList[0];this._bounds=e?.bounds?e.bounds.copy():null}return this._bounds}contains2DCoordinates(e,o){const t=this._polygonList[0];let n;if(!(t&&t.contains2DCoordinates(e,o)))return false;for(n=1;n<this._polygonList.length;n++)if(this._polygonList[n].contains2DCoordinates(e,o))return false;return true}getPolygon(e){return this._polygonList[e]}addPolygon(e,o){if(1===arguments.length||"undefined"===typeof o){ShapeUtil.validateReferencesOrBounce(this.reference,e.reference);this._polygonList.push(e);this._coordinates.push(e.coordinates[0])}else{ShapeUtil.validateReferencesOrBounce(this.reference,o.reference);this._polygonList.splice(e,0,o);this._coordinates.splice(e,0,o.coordinates[0])}this.invalidate()}addPolygons(e){const o=e.length;for(let t=0;t<o;t++)ShapeUtil.validateReferencesOrBounce(this.reference,e[t].reference);Array.prototype.push.apply(this._polygonList,e);Array.prototype.push.apply(this._coordinates,e.map((e=>e.coordinates[0])));this.invalidate()}clearPolygons(){this._polygonList=[];this._coordinates=[];this.invalidate()}removePolygon(e){if(isNumber(e)){this.invalidate();this._coordinates.splice(e,1);return this._polygonList.splice(e,1)[0]}else{let o=0;const t=this._polygonList.length;for(;o<t;o++)if(this._polygonList[o].equals(e))break;if(o<t){this._coordinates.splice(o,1);this._polygonList.splice(o,1);return e}else return null}}removePolygons(e){for(let o=0,t=e.length;o<t;o++)this.removePolygon(e[o]);this.invalidate()}setPolygon(e,o){if(e>=this._polygonList.length)throw new ProgrammingError(`setPolygon: no polygon at index ${e}`);ShapeUtil.validateReferencesOrBounce(this.reference,o.reference);this._coordinates.splice(e,1,o.coordinates[0]);const t=this._polygonList.splice(e,1,o)[0];this.invalidate();return t}polygonChanged(e){this.invalidate()}invalidate(){this._bounds=void 0;this._focus=void 0}copy(){const e=new ComplexPolygon(this.reference);const o=this._polygonList;let t;const n=o.length;for(t=0;t<n;t++)e.addPolygon(o[t].copy());return e}equals(e){if(e===this)return true;if(!(e instanceof ComplexPolygon))return false;if(e.polygonCount!==this.polygonCount||!ShapeUtil.referencesEqual(this.reference,e.reference))return false;return this._polygonList.every(((o,t)=>e.getPolygon(t).equals(o)))}hashCode(e){e.appendUInt32(this.type);for(let o=0,t=this.polygonCount;o<t;o++)this.getPolygon(o).hashCode(e)}toString(){let e="ComplexPolygon[";for(let o=0,t=this.polygonCount;o<t;o++){e+=this.getPolygon(o).toString();if(o+1<t)e+=","}e+="]";return e}translate2D(e,o){for(let t=0,n=this.polygonCount;t<n;t++)this.getPolygon(t).translate2D(e,o);this.invalidate()}}export function isComplexPolygon(e){return e&&e.type===ShapeType.COMPLEX_POLYGON}