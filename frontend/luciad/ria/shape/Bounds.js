import{Shape}from"./Shape.js";import{ShapeType}from"./ShapeType.js";import{Axis}from"../reference/Axis.js";function precision(e){return t=>t.toPrecision(e)}export class Bounds extends Shape{hashCode(e){e.appendUInt32(this.type);e.appendDouble(this.x);e.appendDouble(this.y);e.appendDouble(this.z);e.appendDouble(this.width);e.appendDouble(this.height);e.appendDouble(this.depth)}get type(){return ShapeType.BOUNDS}toString(){return[this.x,this.width,this.height,this.height].map(precision(5)).join(",")}move2D(e,t){if("undefined"===typeof t)this.move2DToPoint(e);else this.move2DToCoordinates(e,t)}move2DToPoint(e){this.compareReference(e.reference,e.coordinateType);this.move2DToCoordinates(e.x,e.y)}move3D(e,t,i){if("undefined"===typeof t)this.move3DToPoint(e);else if(i)this.move3DToCoordinates(e,t,i)}move3DToPoint(e){this.compareReference(e.reference,e.coordinateType);this.setTo3D(e.x,this.width,e.y,this.height,e.z,this.depth)}translate(e,t,i){if(i)this.translate3D(e,t,i);else this.translate2D(e,t)}contains3D(e){if(e instanceof Bounds)return this.contains3DBounds(e);else return this.contains3DPoint(e)}contains3DPoint(e){this.compareReference(e.reference,e.coordinateType);return this.contains3DCoordinates(e.x,e.y,e.z)}contains2DBounds(e){this.compareReference(e.reference,e.coordinateType);const{x:t,y:i,width:s,height:n}=e;return this.x<=t&&this.x+this.width>=t+s&&this.y<=i&&this.y+this.height>=i+n}contains2DBoundsWithEps(e,t){this.compareReference(e.reference,e.coordinateType);const{x:i,y:s,width:n,height:h}=e;return this.x<=i+t&&this.x+this.width>=i+n-t&&this.y<=s+t&&this.y+this.height>=s+h-t}enlarge2D(e,t=false){const i=this.width*e;const s=this.height*e;const n=(i-this.width)/2;const h=(s-this.height)/2;let o=this.x-n;let r=o+i;if(t&&this.reference){const{minimumValue:e,maximumValue:t}=this.reference.getAxis(Axis.Name.X);o=null!=e?Math.max(e,o):o;r=null!=t?Math.min(t,r):r}this.setTo2D(o,r-o,this.y-h,s);return this}invalidate(){}}export function isBounds(e){return ShapeType.contains(ShapeType.BOUNDS,e.type)}