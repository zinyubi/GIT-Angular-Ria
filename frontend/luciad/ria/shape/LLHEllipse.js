import{CoordinateType}from"../reference/CoordinateType.js";import{ProgrammingError}from"../error/ProgrammingError.js";import{Ellipse}from"./Ellipse.js";import{LLHBounds}from"./LLHBounds.js";import*as LLHEllipseUtil from"./LLHEllipseUtil.js";import{normalizeAngle}from"../util/Cartesian.js";import{isNumber}from"../util/Lang.js";export class LLHEllipse extends Ellipse{constructor(e,t,i,r,o){super();this._reference=this.validateReference(e);this._compareReferenceStrict(t.reference,"LLHEllipse::the center point reference must be equal to the ellipse reference");this._center=t.copy();if(!isNumber(i))throw new ProgrammingError("LLHEllipse::cannot create a without a");this._semiMajorAxis=i;if(!isNumber(r))throw new ProgrammingError("LLHEllipse::cannot create a without b");this._semiMinorAxis=r;if(!isNumber(o))throw new ProgrammingError("LLHEllipse::cannot create a without rotationAzimuth");this._rotationAzimuth=normalizeAngle(o)}get coordinateType(){return CoordinateType.GEODETIC}copy(){return new LLHEllipse(this.reference,this.center,this.a,this.b,this.rotationAzimuth)}get bounds(){return this._cache.memoize("cached-bounding-box",(()=>{const e=new LLHBounds(this.reference,[0,0,0,0,0,0]);LLHEllipseUtil.calculateBounds(this.reference.geodeticDatum.ellipsoid,this.center,this.a,this.b,90-this.rotationAzimuth,e);return e}))}contains2DCoordinates(e,t){return this.bounds.contains2DCoordinates(e,t)&&LLHEllipseUtil.contains2D(this.reference.geodeticDatum.ellipsoid,this.center,this.a,this.b,90-this.rotationAzimuth,e,t)}interpolate(e,t){return LLHEllipseUtil.interpolate(this,e,t)}updatePoint(e,t,i){LLHEllipseUtil.updatePoint(this,e,t,i)}}