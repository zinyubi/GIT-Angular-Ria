import{BezierCurve}from"./BezierCurve.js";import{Constants}from"../util/Constants.js";import{LLHPolyline}from"./LLHPolyline.js";import{CoordinateArrayUtil}from"../view/style/CoordinateArrayUtil.js";import{CoordinateType}from"../reference/CoordinateType.js";export class LLHBezierCurve extends BezierCurve{constructor(t,i){super(t,i);this._ellipsoid=t.geodeticDatum.ellipsoid;this.invalidate()}calculatePointParams(){for(let t=0;t<this.points.length;t++){if(t>0)this.points[t].x=linearLon(this.points[t-1].x,this.points[t].x);this.pointParams[t]=0==t?0:this.pointParams[t-1]+this._ellipsoid.geodesicDistance(this.points[t-1],this.points[t])}const t=this.pointParams[this.points.length-1];if(t>0)for(let i=0;i<this.points.length;i++)this.pointParams[i]/=t}get coordinateType(){return CoordinateType.CARTESIAN}getStartTangent2D(){return 90-Constants.RAD2DEG*this._ellipsoid.forwardAzimuth2D(this.points[0],this.points[1])}getEndTangent2D(){let t=Constants.RAD2DEG*this._ellipsoid.forwardAzimuth2D(this.points[this.points.length-1],this.points[this.points.length-2])+180;if(t>360)t-=360;return 90-t}getTangent2D(t){if(t>1-1e-4)return this.getEndTangent2D();if(t<1e-4)return this.getStartTangent2D();const i=this.interpolate(t-1e-4);const e=this.interpolate(t);const n=this.interpolate(t+1e-4);const s=this._ellipsoid.forwardAzimuth2D(e,i)-Math.PI;const o=this._ellipsoid.forwardAzimuth2D(e,n);return 90-Constants.RAD2DEG*(s+o)/2}interpolate(t){const i=super.interpolate(t);this.mixWithGeodetic(t,i);return i}getDiscretizedPolyline(){return new LLHPolyline(this._reference,this.getDiscretizedPoints())}getNormalizedCoordinates(){const t=[];this.points.forEach((({x:i,y:e,z:n},s)=>{if(0===s)t.push([i,e,n]);else t.push([linearLon(t[s-1][0],i),e,n])}));return t}calculateTotalLength(){const t=this.curvePolyline.getSimplePoints();let i=0;for(let e=0;e<t.length-1;e++)i+=this._ellipsoid.geodesicDistance(t[e],t[e+1]);return i}copy(){return new LLHBezierCurve(this.reference,this.points)}mixWithGeodetic(t,i){const e=i.x;const n=i.y;const s=this.getIndexFromParam(t);this.getGeodeticPointAt(t,s,i);const o=this.calculateWeight(t,s);const r=linearLon(i.x,e);i.move2D(r*(1-o)+i.x*o,n*(1-o)+i.y*o)}getIndexFromParam(t){let i=CoordinateArrayUtil.binarySearchNumber(this.pointParams,t);if(i<0)i=-i-1;i-=1;return Math.max(Math.min(i,this.points.length-2),0)}getGeodeticPointAt(t,i,e){const n=this.pointParams[i];const s=undefined;const o=(t-n)/(this.pointParams[i+1]-n);this._ellipsoid.geodesicPositionAtFractionSFCT(this.points[i],this.points[i+1],o,e);return i}calculateWeight(t,i){const e=this.pointParams[i];const n=this.pointParams[i+1];const s=n-e;if(0===s)return 0;let o;if(0==i)o=(n-t)/s;else if(i===this.points.length-2)o=(t-e)/s;else o=0;o=Math.max(0,Math.min(1,o));o*=o;o*=o;return o}}function linearLon(t,i){const e=i-t;return e<-180?i+360:e>180?i-360:i}