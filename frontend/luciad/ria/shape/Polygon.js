import{isOfShapeType,Shape}from"./Shape.js";import{ShapeType}from"./ShapeType.js";import{ShapeUtil}from"./ShapeUtil.js";import{coordinateToSimplePoint,pointListHashCode,unwrapCoordinateFromPoint,wrapCoordinateInPoint}from"./ShapeWithPointList.js";import{coordinate_equals}from"./PointCoordinate.js";export class Polygon extends Shape{get pointCount(){return this._coordinates[0].length}insertPoint(t,e){this._compareReferenceStrict(e.reference);const i=this._coordinates[0];ShapeUtil.validateIndexForInsertionOrBounce(t,i);i.splice(t,0,unwrapCoordinateFromPoint(e));this.invalidate()}removePoint(t){const e=this._coordinates[0];ShapeUtil.validateIndexForRemovalOrBounce(t,e);e.splice(t,1);this.invalidate()}translate(t,e,i){this.translate3D(t,e,i||0)}translate2D(t,e){this.translate3D(t,e,0)}translate3D(t,e,i){const o=undefined;this._coordinates[0].forEach((o=>{this.implTranslate(o,t,e,i)}));this.invalidate()}translatePoint(t,e,i,o){ShapeUtil.validateIndexForRemovalOrBounce(t,this._coordinates[0]);this.implTranslate(this.getPointCoordinates(t),e,i,o);this.invalidate()}move2DPoint(t,e,i){ShapeUtil.validateIndexForRemovalOrBounce(t,this._coordinates[0]);this.implMove(this.getPointCoordinates(t),e,i);this.invalidate()}move3DPoint(t,e,i,o){ShapeUtil.validateIndexForRemovalOrBounce(t,this._coordinates[0]);this.implMove(this.getPointCoordinates(t),e,i,o);this.invalidate()}isValid(){return this.pointCount>=3}getPoint(t){const e=this._coordinates[0];if(e[t])return wrapCoordinateInPoint(this.reference,e[t]);return}hashCode(t){t.appendUInt32(this.type);for(let e=0;e<this._coordinates.length;e++)pointListHashCode(this._coordinates[e],t)}toString(){let t="Polygon[";this._coordinates[0].forEach((e=>{t+=`[${e[0]},${e[1]},${e[2]}]`}));return`${t}]`}invalidate(){this._bounds=void 0;this._focus=void 0}equals(t){if(this===t)return true;if(!isOfShapeType(t,ShapeType.POLYGON)||!this._referencesEqual(this._reference,t.reference)||this.pointCount!==t.pointCount)return false;const e=this.pointCount;for(let i=0;i<e;i++)if(!coordinate_equals(this.getPointCoordinates(i),t.getPointCoordinates(i)))return false;return true}get type(){return ShapeType.POLYGON}get coordinates(){return this._coordinates}get focusPoint(){if(!this._focus)this._focus=this.bounds?.focusPoint??null;return this._focus}getPointCoordinates(t){return this._coordinates[0][t]}getCoordinateArray(t){const e=[];this._coordinates[0].forEach((t=>{e.push(...t)}));if(t&&this.pointCount>1){const t=this.getPointCoordinates(0);if(!coordinate_equals(t,this.getPointCoordinates(this.pointCount-1)))e.push(...t)}return e}getSimplePoint(t){return coordinateToSimplePoint(this.getPointCoordinates(t))}getSimplePointSFCT(t,e){const i=this._coordinates[0][t];e.x=i[0];e.y=i[1];e.z=i[2]}getSimplePoints(){return this._coordinates[0].map(coordinateToSimplePoint)}copyRing(){return this._coordinates[0].map((t=>[t[0],t[1],t[2]]))}}export function isPolygon(t){return t&&t.type===ShapeType.POLYGON}