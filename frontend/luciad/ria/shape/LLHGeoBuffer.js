import{closestPointOnGeodesic}from"../geodesy/EllipsoidUtil.js";import{Constants}from"../util/Constants.js";import{CoordinateType}from"../reference/CoordinateType.js";import{LLHGeoBufferHelper}from"../geometry/constructivegeometry/geobuffer/LLHGeoBufferHelper.js";import{EndCapStyle}from"./EndCapStyle.js";import{GeoBuffer}from"./GeoBuffer.js";import{LLHPoint}from"./LLHPoint.js";import{isPolygon}from"./Polygon.js";const REL_TOLERANCE=1e-12;const ABS_TOLERANCE=.01;export class LLHGeoBuffer extends GeoBuffer{constructor(e,t,i){super(e,t,i);this._bufferHelper=new LLHGeoBufferHelper(this._reference)}get bounds(){return this._cache.memoize("buffer-bounds",(()=>{if(this._contour.bounds)return this._contour.bounds.copy();return null}))}get coordinateType(){return CoordinateType.GEODETIC}copy(){const e=new LLHGeoBuffer(this._reference,this._baseShape.copy(),this._width);e.endCapStyle=this._endCapStyle;return e}contains2DPoint(e){const t=this._reference.geodeticDatum.ellipsoid;let i,n,o,s,r;if(!this.bounds?.contains2DPoint(e))return false;if(this._baseShape.contains2DPoint(e))return true;if(isPolygon(this._baseShape))return this._nearPolygonBounds(this._baseShape,e);const a=this._baseShape.getPoint(0);const f=this._baseShape.getPoint(1);const u=this._baseShape.pointCount;const h=new LLHPoint(this._reference);if(0==u)return false;if(1==u)return this._baseShape.getPoint(0).contains2DPoint(e);if(2==u){i=closestPointOnGeodesic(a,f,e,t,REL_TOLERANCE,ABS_TOLERANCE,h);if(i<=this._width){if(this._endCapStyle===EndCapStyle.CAP_ROUND)return true;if(t.geodesicDistance(a,h)<=ABS_TOLERANCE){n=t.forwardAzimuth2D(a,f)*Constants.RAD2DEG;o=t.forwardAzimuth2D(h,e)*Constants.RAD2DEG;r=n-o;if(r<0)r+=360;if(r>90&&r<270)return false}if(t.geodesicDistance(f,h)<=ABS_TOLERANCE){s=t.forwardAzimuth2D(f,a)*Constants.RAD2DEG;o=t.forwardAzimuth2D(h,e)*Constants.RAD2DEG;r=s-o;if(r<0)r+=360;if(r>90&&r<270)return false}return true}return false}if(u>2)for(let n=1;n<u-2;n++){i=closestPointOnGeodesic(this._baseShape.getPoint(n),this._baseShape.getPoint(n+1),e,t,REL_TOLERANCE,ABS_TOLERANCE,h);if(i<=this._width)return true}i=closestPointOnGeodesic(a,f,e,t,REL_TOLERANCE,ABS_TOLERANCE,h);if(i<=this._width)if(this._endCapStyle===EndCapStyle.CAP_ROUND)return true;else{if(t.geodesicDistance(a,h)<=ABS_TOLERANCE){n=t.forwardAzimuth2D(a,f)*Constants.RAD2DEG;o=t.forwardAzimuth2D(h,e)*Constants.RAD2DEG;r=n-o;if(r<0)r+=360;if(r>90&&r<270)return false}return true}i=closestPointOnGeodesic(this._baseShape.getPoint(u-2),this._baseShape.getPoint(u-1),e,t,REL_TOLERANCE,ABS_TOLERANCE,h);if(i<=this._width){if(this._endCapStyle===EndCapStyle.CAP_ROUND)return true;else if(t.geodesicDistance(this._baseShape.getPoint(u-1),h)<=ABS_TOLERANCE){s=t.forwardAzimuth2D(this._baseShape.getPoint(u-1),this._baseShape.getPoint(u-2))*Constants.RAD2DEG;o=t.forwardAzimuth2D(h,e)*Constants.RAD2DEG;r=s-o;if(r<0)r+=360;if(r>90&&r<270)return false}return true}return false}contains2DCoordinates(e,t){return this.contains2DPoint(new LLHPoint(this._reference,[e,t]))}_nearPolygonBounds(e,t){const i=this._reference.geodeticDatum.ellipsoid;const n=e.pointCount;if(0===n)return false;if(1===n)return i.geodesicDistance(e.getPoint(0),t)<=this._width;const o=new LLHPoint(this._reference);let s;for(let r=0;r<n-1;++r){s=closestPointOnGeodesic(e.getPoint(r),e.getPoint(r+1),t,i,REL_TOLERANCE,ABS_TOLERANCE,o);if(s<=this._width)return true}if(n>2){s=closestPointOnGeodesic(e.getPoint(n-1),e.getPoint(0),t,i,REL_TOLERANCE,ABS_TOLERANCE,o);if(s<=this._width)return true}return false}}