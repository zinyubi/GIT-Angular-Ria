import{CoordinateType}from"../reference/CoordinateType.js";import{ProgrammingError}from"../error/ProgrammingError.js";import{buildCache}from"../util/Cacher.js";import*as EllipsoidCircleUtil from"../geodesy/EllipsoidCircleUtil.js";import{calculateLLHCircleBounds,contains2D as contains2DImpl}from"../geodesy/EllipsoidCircleUtil.js";import{CircleByCenterPoint}from"./CircleByCenterPoint.js";import{LLHBounds}from"./LLHBounds.js";import{isNumber}from"../util/Lang.js";export class LLHCircleByCenterPoint extends CircleByCenterPoint{constructor(e,r,i){super();this._reference=this.validateReference(e);this._compareReferenceStrict(r.reference,"LLHCircleByCenterPoint::the center point reference must be equal to the circle reference");this._center=r.copy();if(!isNumber(i))throw new ProgrammingError("LLHCircleByCenterPoint::cannot create a circle without a radius");this._radius=i;this._cache=buildCache()}get bounds(){return this._cache.memoize("cached-bounding-box",(()=>{const e=new LLHBounds(this.reference,[0,0,0,0,0,0]);calculateLLHCircleBounds(this.getEllipsoid(),this.center,this.radius,e);return e}))}get coordinateType(){return CoordinateType.GEODETIC}get focusPoint(){return EllipsoidCircleUtil.getFocusPoint(this,this.getEllipsoid())}get center(){return this._center}get radius(){return this._radius}set radius(e){if(e>=0){this._radius=e;this._cache.invalidate()}else throw new ProgrammingError(`Radius should be positive number, but was: ${e}`)}copy(){return new LLHCircleByCenterPoint(this.reference,this.center,this.radius)}contains2DCoordinates(e,r){return this.bounds.contains2DCoordinates(e,r)&&contains2DImpl(this.getEllipsoid(),this.center,this.radius,e,r)}getEllipsoid(){return this.reference.geodeticDatum.ellipsoid}}