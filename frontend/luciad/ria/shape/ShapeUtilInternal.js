import{flipOrientationSFCT_flat,orientation2D_flat}from"../util/Cartesian.js";import{ProgrammingError}from"../error/ProgrammingError.js";import{InvalidReferenceError}from"../error/InvalidReferenceError.js";import{ReferenceType}from"../reference/ReferenceType.js";import{isShape}from"./Shape.js";import{CoordinateType}from"../reference/CoordinateType.js";import{ShapeType}from"./ShapeType.js";function fixOrientationSFCT_flat(e){if(e.length>0){const n=orientation2D_flat(e[0]);for(let r=e.length-1;r>0;r--)if(n===orientation2D_flat(e[r]))flipOrientationSFCT_flat(e[r])}}function validateIndexForInsertionOrBounce(e,n,r){if(e<0||e>n.length)throw new ProgrammingError(r||"Invalid index: '"+e+"', must be between 0 and "+n.length)}function validateIndexForRemovalOrBounce(e,n,r){if(e<0||e>n.length-1)throw new ProgrammingError(r||`Invalid index: '${e}', must be between 0 and ${n.length-1}`)}function referencesEqual(e,n){return e?e.equals(n):!n}function validateReferencesOrBounce(e,n){if(referencesEqual(e,n))return true;throw new InvalidReferenceError("References are not equal")}function forEachPointFromIndex(e,n,r){const t=n.pointCount;let o=e;while(o<t){r(n.getPoint(o));o+=1}}function forEachShapeInShapeList(e,n){const r=e.shapeCount;let t=0;while(t<r){n(e.getShape(t));t+=1}}function isGeodeticReference(e){return!!e&&e.coordinateType===CoordinateType.GEODETIC}function isGeodeticCoordinateType(e){return e===ReferenceType.GEODETIC}function isSimpleShapeClosed(e){return ShapeType.contains(e.type,ShapeType.POLYGON)||ShapeType.contains(e.type,ShapeType.BOUNDS)||ShapeType.contains(e.type,ShapeType.ELLIPSE)||ShapeType.contains(e.type,ShapeType.CIRCLE)||ShapeType.contains(e.type,ShapeType.GEO_BUFFER)||ShapeType.contains(e.type,ShapeType.SECTOR)||ShapeType.contains(e.type,ShapeType.ARC_BAND)||ShapeType.contains(e.type,ShapeType.COMPLEX_POLYGON)}function isShapeClosed(e){if(isSimpleShapeClosed(e))return true;if(ShapeType.contains(e.type,ShapeType.SHAPE_LIST)){const n=e;for(let e=0;e<n.shapeCount;e++)if(!isShapeClosed(n.getShape(e)))return false;return true}return ShapeType.contains(e.type,ShapeType.EXTRUDED_SHAPE)&&isShapeClosed(e.baseShape)}function hasDepth(e){if(!e||!isShape(e))return false;const n=e.bounds;const r=e.reference?.referenceType===ReferenceType.GEOCENTRIC;const t=e.reference?.referenceType===ReferenceType.CARTESIAN;return r||t||((n&&(0!==n.depth||0!==n.z))??false)}export const ShapeUtilInternal={fixOrientationSFCT_flat:fixOrientationSFCT_flat,validateIndexForInsertionOrBounce:validateIndexForInsertionOrBounce,validateIndexForRemovalOrBounce:validateIndexForRemovalOrBounce,referencesEqual:referencesEqual,validateReferencesOrBounce:validateReferencesOrBounce,forEachPointFromIndex:forEachPointFromIndex,forEachShapeInShapeList:forEachShapeInShapeList,isGeodeticReference:isGeodeticReference,isGeodeticCoordinateType:isGeodeticCoordinateType,isShapeClosed:isShapeClosed,hasDepth:hasDepth};