import{Shape}from"./Shape.js";import{ShapeUtil}from"./ShapeUtil.js";import{ShapeType}from"./ShapeType.js";import{ProgrammingError}from"../error/ProgrammingError.js";import{clamp}from"../util/Cartesian.js";import{VecMath}from"../util/VecMath.js";const EQUAL_POINTS_EPSILON=1e-18;export class BezierCurve extends Shape{_points=[];_curvePolyline=null;_pointParams=[];_totalLength=0;constructor(e,t){super();const r=t.length-1;if(2!==r&&3!==r)throw new ProgrammingError("BezierCurve constructor: only a quadratic or a cubic curve can be created");this._degree=r;this._reference=this.validateReference(e);this._points=t.map((e=>e.copy()))}get type(){return 2===this._degree?ShapeType.BEZIER_CURVE|ShapeType.BEZIER_CURVE_QUADRATIC:ShapeType.BEZIER_CURVE|ShapeType.BEZIER_CURVE_CUBIC}get focusPoint(){return this.interpolate(.5)}get bounds(){return this.curvePolyline.bounds}get degree(){return this._degree}get points(){return this._points}get pointParams(){return this._pointParams}get curvePolyline(){if(!this._curvePolyline)this._curvePolyline=this.getDiscretizedPolyline();return this._curvePolyline}invalidate(){this.calculatePointParams();this._curvePolyline=this.getDiscretizedPolyline();this._totalLength=this.calculateTotalLength()}getStartPoint(){return this.points[0].copy()}getEndPoint(){return this.points[this._points.length-1].copy()}getLength2D(){return this._totalLength}interpolate(e){const t=clamp(e,0,1);const r=this._points[0].copy();const i=this.evaluateBezier(0,this._points.length-1,t,0);const n=this.evaluateBezier(0,this._points.length-1,t,1);r.move2D(i,n);return r}contains2DPoint(e){return this.contains2DCoordinates(e.x,e.y)}contains2DCoordinates(e,t){return this.isPointOnCurve({x:e,y:t,z:0},EQUAL_POINTS_EPSILON)}translate2D(e,t){this._points.forEach((r=>r.translate(e,t)));this.invalidate()}moveControlPoint(e,t){if(e<0||e>=this._points.length)throw new ProgrammingError("BezierCurve: Index is out of range of the control points");this.points[e].move2DToCoordinates(t.x,t.y);this.invalidate()}toString(){const e=undefined;return`${isCubicBezierCurve(this)?"BezierCurveCubic":"BezierCurveQuadratic"}[points: ${this.points.map((e=>e.toString()))}]`}equals(e){if(this===e)return true;if(!isBezierCurve(e)||!ShapeUtil.referencesEqual(this.reference,e.reference)||this.degree!==e.degree)return false;for(let t=0;t<this.points.length;t++)if(!this.points[t].equals(e.points[t]))return false;return true}getControlPoint(e){if(e<0||e>=this._points.length)throw new ProgrammingError("BezierCurve: Index is out of range of the control points");return this._points[e].copy()}getControlPointCount(){return this._points.length}hashCode(e){e.appendUInt32(this.type);for(let t=0;t<this.points.length;t++)this.points[t].hashCode(e)}getDiscretizedPoints(e=11){const t=1/(e-1);const r=new Array(e);for(let i=0;i<e;i++)r[i]=this.interpolate(i*t);return r}isPointOnCurve(e,t){let r=0;let i=1;const n=100;let o=1/0;const s=undefined;if(!this._points.reduce(((e,t)=>{e.setToIncludePoint2D(t);return e}),this.bounds.copy()).contains2DCoordinates(e.x,e.y))return false;for(let s=0;s<n;s++){const n=(i-r)/3;const s=r+n;const a=i-n;const h=this.interpolate(s);const u=this.interpolate(a);const p=VecMath.length2(VecMath.sub([h,e]));const c=VecMath.length2(VecMath.sub([u,e]));if(p<c){i=a;if(p<o)o=p}else{r=s;if(c<o)o=c}if(o<=t)return true}return false}evaluateBezier(e,t,r,i){const n=this.getNormalizedCoordinates();if(t-e===1){const o=undefined;const s=undefined;return(1-r)*n[e][i]+r*n[t][i]}else if(t-e===2){const t=n[e][i];const o=undefined;const s=undefined;return t+r*(2*(1-r)*(n[e+1][i]-t)+r*(n[e+2][i]-t))}else return(1-r)*this.evaluateBezier(e,t-1,r,i)+r*this.evaluateBezier(e+1,t,r,i)}}export function isBezierCurve(e){return ShapeType.contains(ShapeType.BEZIER_CURVE,e.type)}export function isQuadraticBezierCurve(e){return ShapeType.contains(ShapeType.BEZIER_CURVE_QUADRATIC,e.type)}export function isCubicBezierCurve(e){return ShapeType.contains(ShapeType.BEZIER_CURVE_CUBIC,e.type)}