import{ShapeType}from"./ShapeType.js";import{LLHPoint}from"./LLHPoint.js";import{Constants}from"../util/Constants.js";import{containsAngle,containsAnglePragmatic}from"../util/Cartesian.js";import{calculateLLHBoundsCircular}from"../geodesy/EllipsoidCircleUtil.js";export function contains2D(e,t,n){const o=e.reference.geodeticDatum.ellipsoid;const i=o.forwardAzimuth2D(e.center,new LLHPoint(null,[t,n]))*Constants.RAD2DEG;let s=containsAnglePragmatic(e.startAzimuth,e.sweepAngle,i);if(s){const i=o.geodesicDistance(e.center,new LLHPoint(null,[t,n]));s=Math.abs(i-e.radius)<=Constants.ABSOLUTE_DISTANCE_TOLERANCE+Constants.RELATIVE_DISTANCE_TOLERANCE*e.radius}return s}export function interpolate(e,t,n){if(ShapeType.contains(e.type,ShapeType.CIRCULAR_ARC_BY_3_POINTS)&&_isIntermediateEqualToStartOrEnd(e))e.reference.geodeticDatum.ellipsoid.geodesicPositionAtFractionSFCT(e.startPoint,e.endPoint,t,n);else e.reference.geodeticDatum.ellipsoid.geodesicPositionSFCT(e.center,e.radius,e.startAzimuth+t*e.sweepAngle,n)}function _isIntermediateEqualToStartOrEnd(e){const t=e.startPoint;const n=e.intermediatePoint;const o=e.endPoint;return n.x===t.x&&n.y===t.y||n.x===o.x&&n.y===o.y}export function boundsSFCT(e,t){const n=e.reference.geodeticDatum.ellipsoid;calculateLLHBoundsCircular(n,e.center,e.radius,e.startAzimuth,e.sweepAngle,t)}export function getStartAngle3Points(e,t,n){return getAngle(e,t,n)}export function getArcAngle3Points(e,t,n,o,i){return getArcAngleByAngles(getAngle(e,t,n),getAngle(e,t,o),getAngle(e,t,i))}function getAngle(e,t,n){return e.forwardAzimuth2D(t,n)*Constants.RAD2DEG}function getArcAngleByAngles(e,t,n){if(e<0)e+=360;if(t<0)t+=360;if(n<0)n+=360;const o=n-e;if(e<n)return containsAngle(e,o,t)?o:o-360;else return containsAngle(e,o+360,t)?o+360:o}export function getMidPoint(e,t){const n=e.startPoint;const o=e.endPoint;const i=e.bulge;const s=e.reference.geodeticDatum.ellipsoid;const r=new LLHPoint(e.reference);let c;s.geodesicPositionAtFractionSFCT(n,o,.5,r);if(n.x===o.x&&n.y===o.y){t.move2DToPoint(n);return}else{const t=new LLHPoint(e.reference);const i=new LLHPoint(e.reference);s.geodesicPositionAtFractionSFCT(n,o,.5-.001,t);s.geodesicPositionAtFractionSFCT(n,o,.5+.001,i);c=s.forwardAzimuth2D(t,i)*Constants.RAD2DEG}let a;if(i>0)a=c-90;else a=c+90;const l=.5*s.geodesicDistance(n,o);s.geodesicPositionSFCT(r,Math.abs(i)*l,a,t)}