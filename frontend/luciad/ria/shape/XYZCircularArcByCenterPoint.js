import{buildCache}from"../util/Cacher.js";import{Constants}from"../util/Constants.js";import{ProgrammingError}from"../error/ProgrammingError.js";import{XYZPoint}from"./XYZPoint.js";import{XYZBounds}from"./XYZBounds.js";import*as XYZCircularArcUtil from"./XYZCircularArcUtil.js";import{CircularArcByCenterPoint}from"./CircularArcByCenterPoint.js";import{ShapeType}from"./ShapeType.js";import{CoordinateType}from"../reference/CoordinateType.js";import{ellipticalDistance2D,forwardAzimuth2D}from"../util/Cartesian.js";export class XYZCircularArcByCenterPoint extends CircularArcByCenterPoint{constructor(t,r,e,i,n){super();this._reference=this.validateReference(t);if(r&&r.type===ShapeType.POINT){this._compareReferenceStrict(r.reference,"XYZCircularArcByCenterPoint::the arc reference must match the center point reference");this._center=r.copy()}else throw new ProgrammingError("XYZCircularArcByCenterPoint::cannot create an arc without a center point");if("number"!==typeof e)throw new ProgrammingError("XYZCircularArcByCenterPoint::cannot create an arc without a radius");this._radius=e;if("number"!==typeof i)throw new ProgrammingError("XYZCircularArcByCenterPoint::cannot create an arc without a start azimuth");this._startAzimuth=i;if("number"!==typeof n)throw new ProgrammingError("XYZCircularArcByCenterPoint::cannot create an arc without an arc angle");this._sweepAngle=n;this._cache=buildCache()}get coordinateType(){return this._reference?this._reference.coordinateType:CoordinateType.CARTESIAN}get center(){return this._center}get focusPoint(){return this._center}get radius(){return this._radius}set radius(t){if(t>=0){this._radius=t;this.invalidate()}else throw new ProgrammingError(`Radius should be positive number, but was: ${t}`)}get startAzimuth(){return this._startAzimuth}set startAzimuth(t){this._startAzimuth=t;this.invalidate()}get sweepAngle(){return this._sweepAngle}set sweepAngle(t){this._sweepAngle=t;this.invalidate()}get bounds(){return this._cache.memoize("bounds",(()=>{const t=new XYZBounds(this.reference);XYZCircularArcUtil.boundsSFCT(this,t);return t}))}get startPoint(){return this._cache.memoize("start-point",(()=>calculatePointOnCircle(this.center,this.radius,this.startAzimuth,this.reference)))}get endPoint(){return this._cache.memoize("end-point",(()=>calculatePointOnCircle(this.center,this.radius,this.startAzimuth+this.sweepAngle,this.reference)))}contains2DCoordinates(t,r){return XYZCircularArcUtil.contains2D(this,t,r)}invalidate(){this._cache.invalidate()}copy(){return new XYZCircularArcByCenterPoint(this._reference,this._center.copy(),this._radius,this._startAzimuth,this._sweepAngle)}forwardAzimuth(t,r){return Constants.RAD2DEG*forwardAzimuth2D(t,r)}}function calculatePointOnCircle(t,r,e,i){const n=new XYZPoint(i);const a=ellipticalDistance2D(r,r,90-e);const o=(90-e)*Constants.DEG2RAD;n.move2DToCoordinates(t.x+a*Math.cos(o),t.y+a*Math.sin(o));return n}