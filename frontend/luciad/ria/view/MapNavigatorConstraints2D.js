import{createPoint}from"../shape/ShapeFactory.js";import{ReferenceType}from"../reference/ReferenceType.js";import{GoogleLayer}from"./google/GoogleLayer.js";import{isUndefined}from"../util/Lang.js";import{ProgrammingError}from"../error/ProgrammingError.js";import{clamp}from"../util/Cartesian.js";import{CoordinateType}from"../reference/CoordinateType.js";import{Log}from"../util/Log.js";import{Constants}from"../util/Constants.js";function applyLayerConstraints(t,e){e.correctWorldViewTransformation2D(t,t);return t}function snapToAnyLayer(t,e){if(t.snapToLayer_stop)return t;e.snapScale(t.scalex,t.scaley,t.rounding,t);if(e instanceof GoogleLayer)t.snapToLayer_stop=true;return t}function snapToGoogleLayer(t,e){if(t.snapToLayer_stop)return t;if(e instanceof GoogleLayer){if(isUndefined(t.rounding))throw new ProgrammingError("Missing round function.");e.snapScale(t.scalex,t.scaley,t.rounding,t);t.snapToLayer_stop=true}return t}export class MapNavigatorConstraints2D{constructor(t){this._map=t}violatesRotation(){return this.violatesRotationImpl()}violatesLeftEdge(){if(this._map.is3D())return false;return this.violatesLeftEdgeImpl(this._map.mapToViewTransformationInternal)}violatesRightEdge(){if(this._map.is3D())return false;return this.violatesRightEdgeImpl(this._map.mapToViewTransformationInternal)}violatesTopEdge(){if(this._map.is3D())return false;return this.violatesTopEdgeImpl(this._map.mapToViewTransformationInternal)}violatesBottomEdge(){if(this._map.is3D())return false;return this.violatesBottomEdgeImpl(this._map.mapToViewTransformationInternal)}violatesRotationImpl(){if(this._map.is3D())return false;if(this._map.reference.coordinateType===CoordinateType.CARTESIAN)if(this._map.axisRenderer){Log.warn("MapNavigatorConstraints2D: Cannot rotate map with axes");return true}else if(!this._map.reference.hasUniformAxes2D()){Log.log("MapNavigatorConstraints2D: Cannot combine rotation with non-uniform scaling");return true}return false}violatesLeftEdgeImpl(t){if(!this._map.constraintBounds)return false;return Math.round(t.forwardX(this._map.constraintBounds.x,0))-this._map.constraintPadding.left>=Math.round(this._map.viewBounds.x)}violatesRightEdgeImpl(t){if(!this._map.constraintBounds)return false;const e=this._map.constraintBounds.x+this._map.constraintBounds.width;return Math.round(t.forwardX(e,0))+this._map.constraintPadding.right<=Math.round(this._map.viewBounds.x+this._map.viewBounds.width)+this._map.border.left}violatesBottomEdgeImpl(t){if(!this._map.constraintBounds)return false;return Math.round(t.forwardY(0,this._map.constraintBounds.y))+this._map.constraintPadding.bottom<=Math.round(this._map.viewBounds.y+this._map.viewBounds.height)}violatesTopEdgeImpl(t){if(!this._map.constraintBounds)return false;const e=this._map.constraintBounds.y+this._map.constraintBounds.height;return Math.round(t.forwardY(0,e))-this._map.constraintPadding.top>=Math.round(this._map.viewBounds.y)-this._map.border.bottom}getSnappedScale(t,e,o,n,a){if(this._map.is3D()){a.scalex=t;a.scaley=e;return}a.rounding=o;a.scalex=t;a.scaley=e;a.snapToLayer_stop=false;this._map.layerTree._reduceLeaves(n?snapToGoogleLayer:snapToAnyLayer,a)}hasBoundsConstraint(){if(this._map.is3D())return false;return null!==this._map.getBoundsNavigationRestriction()}correctWorldViewTransformation2D(t,e){if(this._map.getViewWidth()<1||this._map.getViewHeight()<1){e.setToWVT(this._map.mapToViewTransformationInternal);return}e.setToWVT(t);if(this._map.axisRenderer)correctWVTToZeroRotation(e.copy(),e);this.correctWVTToLayerConstraints(e.copy(),e);this.correctWVTToMinMaxScaleConstraint(e.copy(),e);this.correctWVTToBoundsConstraint(e.copy(),e);this.correctWVTToWrapAroundWorldConstraint(e.copy(),e)}correctWVTToLayerConstraints(t,e){e.setToWVT(t);this._map.layerTree._reduceLeaves(applyLayerConstraints,e)}correctWVTToBoundsConstraint(t,e){e.setToWVT(t);if(!this.hasBoundsConstraint())return;correctWVTToZeroRotation(e.copy(),e);if(!(this.violatesBottomEdgeImpl(t)||this.violatesTopEdgeImpl(t)||this.violatesLeftEdgeImpl(t)||this.violatesRightEdgeImpl(t)))return;const o=e.inverseTransformation.transformBounds(this._map.viewBounds);const n=e._inverseXDistance(this._map.constraintPadding.left);const a=e._inverseXDistance(this._map.constraintPadding.right);const r=-e._inverseYDistance(this._map.constraintPadding.bottom);const i=-e._inverseYDistance(this._map.constraintPadding.top);const s=this._map.constraintBounds;const c=Math.min(s.width+(n+a),o.width);const p=Math.min(s.height+(r+i),o.height);let h=o.width/Math.max(c,1);let m=o.height/Math.max(p,1);if(this._map.reference.referenceType===ReferenceType.GRID||this._map.reference.referenceType===ReferenceType.GEODETIC){h=Math.max(h,m);m=Math.max(h,m)}o.scaleAroundCenter(h,m);const d=Math.min(0,o.x-(s.x-n))+Math.max(0,o.x+o.width-(s.x+s.width+a));const l=Math.min(0,o.y-(s.y-r))+Math.max(0,o.y+o.height-(s.y+s.height+i));o.x-=d;o.y-=l;const g=e.getViewCenter();const u=createPoint(null,[g.x+this._map.border.left,g.y]);e.setTo(o.focusPoint,u,this._map.viewBounds.width/o.width,this._map.viewBounds.height/o.height,e.getRotation());const f=t.getViewOrigin();const T=e.toWorld(f);e.setTo(T,f,e.getScaleX(),e.getScaleY(),e.getRotation())}correctWVTToMinMaxScaleConstraint(t,e){const o=this._map.getAdjustedMinScale();const n=this._map.getAdjustedMaxScale();const a=clamp(t.getScaleX(),o[0],n[0]);const r=clamp(t.getScaleY(),o[1],n[1]);e.setTo(t.getWorldOrigin(),t.getViewOrigin(),a,r,t.getRotation())}correctWVTToWrapAroundWorldConstraint(t,e){if(!(this._map.wrapAroundWorld&&this._map.mapNavigator.constraints.wrapAroundWorld&&this._map.mapNavigator.constraints.wrapAroundWorld.maxNumberOfWorlds))return;const o=t.getWorldOrigin();const n=t.getScaleX();const a=t.getViewOrigin();const r=t.getViewWidth();const i=t.getViewHeight();const s=Math.abs(Math.sin(t.getRotation()*Constants.DEG2RAD));const c=Math.abs(Math.cos(t.getRotation()*Constants.DEG2RAD));const p=c*a.x+s*a.y;const h=c*(r-a.x)+s*(i-a.y);const m=o.x-p/n;const d=o.x+h/n;const l=this._map.reference.bounds;const g=(d-m)/l.width;const u=this._map.mapNavigator.constraints.wrapAroundWorld.maxNumberOfWorlds;if(g>u){const o=(p+h)/(u*l.width);e.setTo(t.getWorldOrigin(),t.getViewOrigin(),o,o,t.getRotation())}}static create(t){return new MapNavigatorConstraints2D(t)}}function correctWVTToZeroRotation(t,e){e.setTo(t.getWorldOrigin(),t.getViewOrigin(),t.getScaleX(),t.getScaleY(),0)}