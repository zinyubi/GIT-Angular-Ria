import{QueryProvider}from"../QueryProvider.js";import{ScaleLevelCursor}from"./ScaleLevelCursor.js";import{ScaleZoneUtil}from"./ScaleZoneUtil.js";const BOUNDS_DIFFERENCE_RATE=.07;const MAX_FEATURE_BOUNDS_DIFFERENCE_THRESHOLD=.2;export class LoadSpatiallySupport{constructor(){}multiScaleShouldQuery(e,t,r,s){if(!this._queryParams)return true;const n=this._queryParams;const o=this.getParamsByScaleLevel(e,t,r);if(o.length!==n.length)return true;let u=false;for(let e=0;e<o.length;e++){const t=n[e];const r=o[e];if(t.level!==r.level)u=true;else if(!t.bounds.contains2DBounds(r.bounds)){r.bounds.setTo2DUnion(t.bounds);const e=undefined;if(getBoundsAreaDifferenceFactor(r.bounds,t.bounds)>BOUNDS_DIFFERENCE_RATE)u=true}if(u)break}if(!u&&s&&1===o.length){const e=getBoundsAreaDifferenceFactor(n[0].bounds,o[0].bounds);u=shouldQueryBecauseOfMaxFeatures(o[0].query,s,e)}return u}multiScaleQueryModel(e,t,r){const s=e.model;const n=this.getParamsByScaleLevel(e,t,r);this._queryParams=n;return this.executeQuery(s.store,n)}async executeQuery(e,t){const r=t.map((async t=>e.spatialQuery(t.bounds,t.query)));const s=await Promise.all(r);return new ScaleLevelCursor(s)}getParamsByScaleLevel(e,t,r){const s=e.map;const n=r.getQueryLevelScales(e,s);const o=getScaleRanges(e.scaleRange,n);const u=ScaleZoneUtil.getScaleZones(s,o,t);const a=[];u.forEach((({level:e,bounds:t})=>{if(t){const s=r.getQueryForLevel(e);if(s!==QueryProvider.QUERY_NONE)a.push({level:e,query:s,bounds:t})}}));return a}}function getScaleRanges(e,t){const r=Math.max(e.min,0);const s=Math.min(e.max,1);if(0===t.length)return[r,s];const n=[r];for(let e=0;e<t.length;e++){const o=t[e];if(o>r&&o<s)n.push(o)}n.push(s);return n}export function getBoundsAreaDifferenceFactor(e,t){const r=e.width*e.height;const s=t.width*t.height;return s?r/s-1:0}export function shouldQueryBecauseOfMaxFeatures(e,t,r){const s=e?.maxFeatures;if(s){if(r>=0&&t<s)return false;if(Math.abs(r)>MAX_FEATURE_BOUNDS_DIFFERENCE_THRESHOLD)return true}return false}