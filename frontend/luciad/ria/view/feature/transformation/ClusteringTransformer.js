import{ProgrammingError}from"../../../error/ProgrammingError.js";import{Feature}from"../../../model/feature/Feature.js";import{MemoryStore}from"../../../model/store/MemoryStore.js";import{createTransformation}from"../../../transformation/TransformationFactory.js";import{isArray,isBoolean,isFunction}from"../../../util/Lang.js";import{AutoIncrement}from"./AutoIncrement.js";import{Classifier}from"./Classifier.js";import{ClusteredPoint}from"./ClusteredPoint.js";import{ClosestToCenterClusterShapeProvider}from"./ClosestToCenterClusterShapeProvider.js";import{ClusterStore}from"./ClusterStore.js";import{HierarchicalClusteringAlgorithm}from"./HierarchicalClusteringAlgorithm.js";import{ModelTransformer}from"./ModelTransformer.js";import{NULL_FEATURE}from"../loadingstrategy/ScaleLevelCursor.js";import{Hash}from"../../../util/Hash.js";import{OutOfBoundsError}from"../../../error/OutOfBoundsError.js";import{Log}from"../../../util/Log.js";function _isCluster(e){return isArray(e?.properties?.clusteredElements)}const idGenerator=new AutoIncrement;const DEFAULT_CLASSIFICATION="Default";class DefaultClassifier extends Classifier{constructor(){super()}getClassification(){return DEFAULT_CLASSIFICATION}}const SCALE_CHANGE_TRANSFORMATION_THRESHOLD=8;const MIN_CLUSTERING_SCALE=1e-9;const DEFAULT_CLUSTER_SIZE=200;const DEFAULT_MIN_PTS=2;const DEFAULT_CLASSIFIER=new DefaultClassifier;class ClusteringTransformerImpl extends ModelTransformer{get options(){return this._options}_classifiedObjects=new Map;_clusterShapeProvider=new ClosestToCenterClusterShapeProvider;_defaultMinimumPoints=DEFAULT_MIN_PTS;_clusterSize=0;_classifier=DEFAULT_CLASSIFIER;_defaultDisableClustering=false;_classParameters=[{classification:DEFAULT_CLASSIFICATION,parameters:{}}];_clusterScale=null;_modelBounds=null;_clusterSceneBounds=null;constructor(e={}){super(true);const{levelScales:t,clusteringTransformers:s}=e;if(t||s){if(!t||!s)throw new ProgrammingError("The levelScales and clusteringTransformers properties must be use together.");if(t.length+1!==s.length)throw new ProgrammingError("The length of the clusteringTransformers array should be equal to the length of the levelScales array + 1");this._levelScales=t;this._clusteringTransformers=s}else{this._levelScales=[];this.updateConfiguration(e)}this._options=e||null;this._queriedClustersStore=new MemoryStore;this._lastViewParameters=null;this._classifiedObjects.clear();this._handleTimeoutId=null;this._updatedFeatures=[];this._algorithm=new HierarchicalClusteringAlgorithm;this._previousClusters=new ClusterStore}release(){super.release();if(this._handleTimeoutId){clearTimeout(this._handleTimeoutId);this._handleTimeoutId=null}}resetCaches(){this._previousClusters.clear()}updateConfiguration(e){const{clusterShapeProvider:t,clusterSize:s,minimumPoints:r,noClustering:i}=e.defaultParameters||{};this._classifiedObjects.clear();this._classifier=e.classifier||DEFAULT_CLASSIFIER;this._clusterShapeProvider=t||new ClosestToCenterClusterShapeProvider;this._clusterSize=s||DEFAULT_CLUSTER_SIZE;this._defaultMinimumPoints=r||DEFAULT_MIN_PTS;this._defaultDisableClustering=!!i;this._classParameters=e.classParameters||[]}doTransformation(e,t){this.cluster(e,t,[]);return this._queriedClustersStore.query()}addToClassifiedObjects(e,t,s,r){const{points:i,noiseFeatures:o,nonClusterableFeatures:n,noClustering:a}=this.getFeatureClassification(e);const l=e.shape?.focusPoint;if(!a&&l&&!t.has(e.id))try{const t={x:0,y:0,z:0};s.transform(l,t);const n={x:0,y:0,z:0};r.transform(t,n);i.push(new ClusteredPoint(e,l,t,n));o.push(e)}catch(t){if(!(t instanceof OutOfBoundsError)){const e=t instanceof Error?t.message:"function"===typeof t?.toString?t.toString():"an unknown error occurred";Log.error(`ClusteringTransformer could not transform a point - ${e}`)}n.push(e)}else n.push(e)}updateClassificationForEvent(e,t,s,r,i){if("remove"===s){this.removeFromClassifiedObjectsForEvent(e);this.notifyClusterStoreOfRemovedElements(e)}else if("update"===s||"add"===s)this.addToClassifiedObjectsForEvent(e,t,r,i)}notifyClusterStoreOfRemovedElements(e){if(_isCluster(e)){const t=clusteredFeatures(e);for(let e=0;e<t.length;e++)this._previousClusters.remove(t[e])}else this._previousClusters.remove(e)}addToClassifiedObjectsForEvent(e,t,s,r){const{points:i,noiseFeatures:o,nonClusterableFeatures:n}=this.getFeatureClassification(e);if(e.shape?.focusPoint&&!t.has(e.id))try{const t=s.transform(e.shape.focusPoint);const n=r.transform(t);const a=new ClusteredPoint(e,e.shape.focusPoint,t,n);const l=i.filter((t=>e.id===t.modelElement.id));if(l.length>0){const t=i.indexOf(l[0]);i.splice(t,1,a);o.splice(t,1,e)}else{i.push(a);o.push(e)}}catch(t){const s=n.indexOf(e);if(s>-1)n.splice(s,1,e);else n.push(e)}else{const t=n.indexOf(e);if(t>-1)n.splice(t,1,e);else n.push(e)}}removeFromClassifiedObjectsForEvent(e){const{points:t,noiseFeatures:s,nonClusterableFeatures:r}=this.getFeatureClassification(e);if(e?.shape?.focusPoint){const r=t.filter((t=>e.id===t.modelElement.id));if(r.length>0){const e=t.indexOf(r[0]);t.splice(e,1);s.splice(e,1)}}else{const t=r.indexOf(e);if(t>-1)r.splice(t,1)}}getFeatureClassification(e){const t=this._classifier.getClassification(e);if(!this._classifiedObjects.has(t))this.addNewClassification(t);return this._classifiedObjects.get(t)}addNewClassification(e){const t=this.getClassConfig(e);this._classifiedObjects.set(e,{points:[],noiseFeatures:[],nonClusterableFeatures:[],clusterSize:t.clusterSize,clusterShapeProvider:t.clusterShapeProvider,minimumPoints:t.minimumPoints,noClustering:t.noClustering})}getClassConfig(e){const t={clusterSize:this._clusterSize,clusterShapeProvider:this._clusterShapeProvider,minimumPoints:this._defaultMinimumPoints,noClustering:this._defaultDisableClustering};let s=0;const r=this._classParameters.length;let i;while(s<r){const t=this._classParameters[s];const r=t;const o=t;if(r.classification&&r.classification===e){i=r.parameters;break}else if(o.classMatcher&&o.classMatcher(e)){i=o.parameters;break}s++}if(i){t.clusterSize=i.clusterSize||this._clusterSize;t.clusterShapeProvider=i.clusterShapeProvider||this._clusterShapeProvider;t.minimumPoints=i.minimumPoints||this._defaultMinimumPoints;t.noClustering=isBoolean(i.noClustering)?i.noClustering:this._defaultDisableClustering}return t}getConfigurationForCurrentScale(e){for(let t=0;t<this._levelScales.length;t++)if(e<=this._levelScales[t])return this._clusteringTransformers[t].options;return this._clusteringTransformers[this._clusteringTransformers.length-1].options}cluster(e,t,s){this._lastViewParameters=t;const{mapReference:r,modelReference:i,mapToViewTransformation:o,mapScale:n,mapViewSize:a,modelBounds:l,sceneBounds:u,layer:c}=t;const d=isPointInViewFactory(a,.2);this._clusterScale=n[0];this._modelBounds=l;this._clusterSceneBounds=u;const h=createTransformation(i,r);if(this._levelScales.length>0)this.updateConfiguration(this.getConfigurationForCurrentScale(this._clusterScale));this._classifiedObjects.clear();const f=c.filter;const m=isFunction(f);const p=getFeaturesNotToCluster(c);while(e.hasNext()){const t=e.next();if(t!==NULL_FEATURE){if(m&&!f(t))p.set(t.id,t);else if(t.shape?.bounds&&!u?.interacts2D(t.shape.bounds))p.set(t.id,t);this.addToClassifiedObjects(t,p,h,o)}}for(const{feature:e,eventType:t}of s)this.updateClassificationForEvent(e,p,t,h,o);let C=[];for(const[e,t]of this._classifiedObjects){const{noClustering:s,noiseFeatures:r,points:o,clusterSize:n,minimumPoints:a,clusterShapeProvider:l,nonClusterableFeatures:u}=t;C=C.concat(u);if(s)continue;const c=[];const h=[];for(let e=0;e<o.length;e++){const t=o[e];if(d(t.viewLocation))c.push(t);else h.push(t)}const f=new Set(r);const m=this.getClassClusters(c,f,n,a,l,i,e);const p=this.getClassClusters(h,f,n,a,l,i,e);C=C.concat(m,p);f.forEach((e=>C.push(e)))}this._queriedClustersStore=new MemoryStore({data:C});return C}getClassClusters(e,t,s,r,i,o,n){if(0===e.length)return[];const a=[];const l=this._previousClusters.restoreClusters(e);const u=this._algorithm.cluster(e,l,{clusterSize:s,minimumPoints:r});this._previousClusters.storeClusters(e,u);for(const e of u){const s=[];const r=e.getPoints();for(const e of r){s.push(e.modelElement);t.delete(e.modelElement)}const o=isFunction(i.getAdvancedLocation)?i.getAdvancedLocation(r):i.getShape(s);if(o){const e=new Feature(o.focusPoint,{clusteredElements:s,classification:n},getClusterId(s));a.push(e)}}return a}canPut(e){return!_isCluster(e)}async put(e,t,s){if(_isCluster(t))throw new ProgrammingError("Clusters cannot be updated");else{const r=await e.put(t,s);this._queriedClustersStore.put(t);this._eventedSupport.emitModelChangedEvent("update",t,t.id);return r}}async add(e,t,s){if(_isCluster(t)){const r=clusteredFeatures(t).map((t=>e.add(t,s)));await Promise.all(r);if(!t.id)t.id=`cluster_${idGenerator.nextKey()}`;return t.id}else{const r=await e.add(t,s);this._queriedClustersStore.add(t);this._eventedSupport.emitModelChangedEvent("add",t,t.id);return r}}findTransformedFeature(e){return this._queriedClustersStore.get(e)}async remove(e,t){const s=this.findTransformedFeature(t);if(!s)return false;if(_isCluster(s)){const t=clusteredFeatures(s).map((t=>e.remove(t.id)));const r=undefined;return(await Promise.all(t)).every((e=>e))}return e.remove(s.id)}needsTransformation(e){if(e.mapScale[0]<MIN_CLUSTERING_SCALE)return false;if(!this._clusterScale||!this._modelBounds)return true;const t=e.getMapBounds({reference:this._modelBounds.reference})[0];if(!t.interacts2D(this._modelBounds))return false;const s=undefined;if(100*Math.abs(1-this._clusterScale/e.mapScale[0])>SCALE_CHANGE_TRANSFORMATION_THRESHOLD)return true;if(this._clusterSceneBounds?.contains2DBounds(t))return false;return true}clusterForModelUpdates(e){if(!this._lastViewParameters)throw new Error("ClusteringTransformation: unexpected situation - missing lastViewParameters");const t=new Map;const s=new Map;const r=this._queriedClustersStore.query();while(r.hasNext()){const e=r.next();t.set(e.id,e)}const i=this.cluster(e.query(),this._lastViewParameters,this._updatedFeatures);for(const e of i)s.set(e.id,e);t.forEach(((e,t)=>{if(!s.has(t))this._eventedSupport.emitModelChangedEvent("remove",e,t)}));const o=new Set(this._updatedFeatures.map((e=>e.id)));s.forEach(((e,s)=>{const r=!t.has(s);if(r)this._eventedSupport.emitModelChangedEvent("add",e,e.id);if(!r&&o.size)if(isCluster(e)){let t=false;clusteredFeatures(e).forEach((e=>{if(o.has(e.id)){o.delete(e.id);t=true}}));if(t)this._eventedSupport.emitModelChangedEvent("update",e,s)}else if(o.has(s)){o.delete(s);this._eventedSupport.emitModelChangedEvent("update",e,s)}}));this._updatedFeatures.length=0}handleSourceModelChange(e,t,s,r){this._updatedFeatures.push({eventType:t,feature:s,id:r});if(null===this._handleTimeoutId)this._handleTimeoutId=setTimeout((()=>{this.clusterForModelUpdates(e);this._handleTimeoutId=null}),0)}prepareForSelection(e,t){if(!t)return;if(this._queriedClustersStore.get(e));else{const t=this._queriedClustersStore.query();while(t.hasNext()){const s=t.next();if(_isCluster(s)){const{clusteredElements:t,classification:r}=s.properties;const{minimumPoints:i}=this.getClassConfig(r);for(let r=0;r<t.length;r++){let o=t[r];if(o.id===e){if(t.length-1<i){this._queriedClustersStore.remove(s.id);this._eventedSupport.emitModelChangedEvent("remove",s,s.id);for(let e=0;e<t.length;e++){o=t[e];this._queriedClustersStore.add(o);this._eventedSupport.emitModelChangedEvent("add",o,o.id)}}else{t.splice(r,1);this._queriedClustersStore.put(s);this._eventedSupport.emitModelChangedEvent("update",s,s.id);this._queriedClustersStore.add(o);this._eventedSupport.emitModelChangedEvent("add",o,o.id)}return}}}}}}}function isPointInViewFactory([e,t],s=.2){const r=s*e;const i=s*t;const o=-r;const n=e+r;const a=-i;const l=t+i;return({x:e,y:t})=>e>o&&e<n&&t>a&&t<l}export function create(e){return new ClusteringTransformerImpl(e)}export function isCluster(e){return _isCluster(e)}export function clusteredFeatures(e){if(_isCluster(e))return e.properties.clusteredElements;throw new ProgrammingError("The clusteredFeatures method should only be called with objects which pass the isCluster check.")}export function createScaleDependent(e){if(e&&e.clusteringTransformers)for(const t of e.clusteringTransformers){const{clusteringTransformers:e,levelScales:s}=t.options;if(e||s)throw new ProgrammingError("Each of the clustering transformers contained in the options of passed to the createScaleDependent method "+"should have been created by the create method. "+"None of those clustering transformers should be a scale dependent transformer.")}return new ClusteringTransformerImpl(e)}function getClusterId(e){const t=e.map((e=>e.id)).sort();const s=new Hash;for(let e=0;e<t.length;e++)s.append(t[e]);return s.getHashCode()}function getFeaturesNotToCluster(e){const t=new Map;const s=e.getSelectedFeatures();for(const e of s)t.set(e.id,e);const r=e.getEditedFeature();if(r&&void 0!==r.id)t.set(r.id,r);return t}