import{InvalidReferenceError}from"../../error/InvalidReferenceError.js";import{ProgrammingError}from"../../error/ProgrammingError.js";import{boolean,color,icon,number}from"../../util/expression/ExpressionFactory.js";import{ExpressionResolver}from"../../util/expression/ExpressionResolver.js";import{ExpressionValidator}from"../../util/expression/ExpressionValidator.js";import{isDefined,isFunction,isString,isUndefined}from"../../util/Lang.js";import{Log}from"../../util/Log.js";import{ObjectReleaseTracker}from"../../util/ObjectReleaseTracker.js";import{FeaturePainter}from"./FeaturePainter.js";import{FunctionProvider}from"./FunctionProvider.js";import{PropertyProvider}from"./PropertyProvider.js";import{StyleIdGenerator}from"./StyleIdGenerator.js";import{DrapeTarget}from"../style/DrapeTarget.js";import{isAboveGroundReference}from"./photon/command/ZStyleUtil.js";class ParameterizedPointPainter extends FeaturePainter{NOPE=()=>{};constructor(e){super();this._dirty=true;this._expressionResolver=ExpressionResolver;this._expressionValidator=new ExpressionValidator(this._expressionResolver);const s=(e=e||{}).attributes||{};this._attributes=[];for(const e in s)if(s.hasOwnProperty(e)){let t;if(isString(s[e]))t=new PropertyProvider(s[e]);else if(isFunction(s[e]))t=new FunctionProvider(s[e]);else throw new ProgrammingError("Specify either the name of a feature property, or a function that calculates the attribute value");this._attributes.push({name:e,provider:t})}const t=e.regular||{};this._regularExpressions=this._unpackExpressionOptions(t,false,this._expressionResolver.createDefaultParameterizedPointStyle());const r=e.selected||{};this._selectedExpressions=this._unpackExpressionOptions(r,true,this._expressionResolver.createDefaultParameterizedPointStyle());if(e.visibilityExpression)this._visibilityExpression=e.visibilityExpression;else this._visibilityExpression=boolean(true);if(e.heading)if(isString(e.heading))this._headingProvider=new PropertyProvider(e.heading);else if(isFunction(e.heading))this._headingProvider=new FunctionProvider(e.heading);else throw new ProgrammingError("Specify either the name of a feature property or a function that calculates the heading");else this._headingProvider=new FunctionProvider((()=>Number.NaN));this.zOrder=e.zOrder||0;let i=e.drapeTarget;if(isDefined(e.draped)&&isUndefined(e.drapeTarget))i=e.draped?DrapeTarget.TERRAIN:DrapeTarget.NOT_DRAPED;this._drapeTarget=i??DrapeTarget.NOT_DRAPED;const o=new StyleIdGenerator;this._regularStyleId=o.get();this._selectedStyleId=o.get();this._createStyle=true;this._usedInSoftwareWarning=false;this._usedWithAboveGround=false}_unpackExpressionOptions(e,s,t){const r={};if(e.colorExpression)r.colorExpression=e.colorExpression;else r.colorExpression=s?color("rgba(0, 0, 255, 1)"):color("rgba(255, 255, 255, 1)");if(e.iconExpression)r.iconExpression=e.iconExpression;else r.iconExpression=icon(t);if(e.scaleExpression)r.scaleExpression=e.scaleExpression;else r.scaleExpression=number(1);return r}get colorExpression(){return this._regularExpressions.colorExpression}set colorExpression(e){this._dirty=true;this._regularExpressions.colorExpression=e;this._updateStyle()}get selectedColorExpression(){return this._selectedExpressions.colorExpression}set selectedColorExpression(e){this._dirty=true;this._selectedExpressions.colorExpression=e;this._updateStyle()}get iconExpression(){return this._regularExpressions.iconExpression}set iconExpression(e){this._dirty=true;this._regularExpressions.iconExpression=e;this._updateStyle()}get selectedIconExpression(){return this._selectedExpressions.iconExpression}set selectedIconExpression(e){this._dirty=true;this._selectedExpressions.iconExpression=e;this._updateStyle()}get scaleExpression(){return this._regularExpressions.scaleExpression}set scaleExpression(e){this._dirty=true;this._regularExpressions.scaleExpression=e;this._updateStyle()}get selectedScaleExpression(){return this._selectedExpressions.scaleExpression}set selectedScaleExpression(e){this._dirty=true;this._selectedExpressions.scaleExpression=e;this._updateStyle()}get visibilityExpression(){return this._visibilityExpression}set visibilityExpression(e){this._dirty=true;this._visibilityExpression=e;this._updateStyle()}get density(){return super.density}set density(e){super.density=e;this._updateStyle()}paintBody(e,s,t,r,i,o){if(this._usedInSoftwareWarning||"Photon"!==i.viewPaintingStrategy.techContext.type){if(!this._usedInSoftwareWarning){this._usedInSoftwareWarning=true;Log.warn("ParameterizedPointPainter should not be used in Software rendering.")}return}if(this._dirty){this._validateColorExpression(this._regularExpressions.colorExpression,false);this._validateColorExpression(this._selectedExpressions.colorExpression,false);this._validateIconExpression(this._regularExpressions.iconExpression,false);this._validateIconExpression(this._selectedExpressions.iconExpression,true);this._validateScaleExpression(this._regularExpressions.scaleExpression);this._validateScaleExpression(this._selectedExpressions.scaleExpression);this._validateVisibilityExpression(this._visibilityExpression);this._dirty=false}if(this._usedWithAboveGround||isAboveGroundReference(t)){if(!this._usedWithAboveGround){this._usedWithAboveGround=true;throw new InvalidReferenceError("ParameterizedPointPainter used with a model that has an ABOVE_TERRAIN height reference.")}return}const n=this._headingProvider.get(s,t);const a=[];for(let e=0;e<this._attributes.length;e++)a[e]=this._attributes[e].provider.get(s,t);const l=o.selected?this._selectedStyleId:this._regularStyleId;const h={isPlotStyle:true,syncWithShapePainter:this.syncWithShapePainter.bind(this),fillAttributes:this.fillAttributes.bind(this),getAttributeCount:this.getAttributeCount.bind(this),getPackedAttributeNames:this._getPackedAttributeNames.bind(this),id:l,renderPassId:l,selected:o.selected,zOrder:this.zOrder,drapeTarget:this._drapeTarget,heading:n,attributes:a};e.drawShape(t,h)}_updateStyle(){if(this._shapePainter){let e;let s;let t;let r;let i;let o;let n;const a=new ObjectReleaseTracker;const l=this;try{const h=this._shapePainter;const p=this._regularExpressions.colorExpression;const d=this._selectedExpressions.colorExpression;const c=this._regularExpressions.iconExpression;const u=this._selectedExpressions.iconExpression;const _=this._regularExpressions.scaleExpression;const E=this._selectedExpressions.scaleExpression;const x=this._visibilityExpression;e=a.track(this._resolveExpression(p));s=a.track(this._resolveExpression(d));t=a.track(this._resolveExpression(c,(()=>{l._updateStyle()})));r=a.track(this._resolveExpression(u,(()=>{l._updateStyle()})));i=a.track(this._resolveExpression(_));o=a.track(this._resolveExpression(E));n=a.track(this._resolveExpression(x));if(this._createStyle){h.setPlotRenderPass(this._regularStyleId);h.setPlotRenderPass(this._selectedStyleId);h.createPlotStyle(this._regularStyleId,this._getPackedAttributeNames(),e,n,t,i,this.zOrder,this._regularStyleId,false,this._drapeTarget);h.createPlotStyle(this._selectedStyleId,this._getPackedAttributeNames(),s,n,r,o,this.zOrder,this._selectedStyleId,true,this._drapeTarget)}else{h.updatePlotStyleForAll(this._regularStyleId,e,n,t,i);h.updatePlotStyleForAll(this._selectedStyleId,s,n,r,o)}let g;if(this.density&&this.density.colorMap)g=a.track(this.density.colorMap.toPhotonBuffers(this._photon));else{const e=this._photon.BufferFactory.createFloat32BufferFromLength(0);const s=this._photon.BufferFactory.createFloat32BufferFromLength(0);g=a.track({levels:e,colors:s,release:()=>{e.release();s.release()}})}h.updatePlotDensityRenderPass(this._regularStyleId,g.levels,g.colors);this._invalidator.invalidate()}finally{a.release()}}}syncWithShapePainter(e,s,t,r,i){if(this._shapePainter!==e){this._photon=s;this._shapePainter=e;this._invalidator=t;this._imageProvider=r;this._hash=i;this._createStyle=true}if(this._createStyle){this._updateStyle();this._createStyle=false}}_resolveExpression(e,s=this.NOPE){return this._expressionResolver.resolve(e,this._invalidator,this._imageProvider,this._hash,s)}_validateColorExpression(e,s=false){this._validateExpression(e,s,"getErrorMessageForColorExpression","color")}_validateIconExpression(e,s=false){this._validateExpression(e,s,"getErrorMessageForIconExpression","icon")}_validateScaleExpression(e,s=false){this._validateExpression(e,s,"getErrorMessageForScaleExpression","scale")}_validateVisibilityExpression(e){this._validateExpression(e,false,"getErrorMessageForVisibilityExpression","visibility")}_validateExpression(e,s,t,r){const i=this._expressionValidator[t](e);if(i)throw new ProgrammingError(`There is a problem with the ${s?"selected ":""}${r} expression:\n${i}`)}_getPackedAttributeNames(){if(this._attributes.length<1)return"";let e=this._attributes[0].name;for(let s=1;s<this._attributes.length;s++)e+=`,${this._attributes[s].name}`;return e}getAttributeCount(){return this._attributes.length}fillAttributes(e,s,t,r,i){if(t!==r.length)Log.error("Heading array to fill has incorrect size");if(t*this.getAttributeCount()!==i.length)Log.error("Attribute array to fill has incorrect size");const o=this._headingProvider.get(e,s);let n=0;for(let e=0;e<t;e++)r[n++]=o;if(n!==r.length)Log.error(`Incorrect length: expected ${r.length} but was ${n}`);let a=0;for(let r=0;r<this._attributes.length;r++){const o=this._attributes[r].provider.get(e,s);for(let e=0;e<t;e++)i[a++]=o}if(a!==i.length)Log.error(`Incorrect length: expected ${i.length} but was ${a}`)}}export{ParameterizedPointPainter};