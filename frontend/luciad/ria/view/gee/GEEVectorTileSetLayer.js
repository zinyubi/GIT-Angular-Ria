import{ProgrammingError}from"../../error/ProgrammingError.js";import{Photon}from"../../gen/photon/photon_painter.js";import{PhotonReferenceProvider}from"../../reference/photon/PhotonReferenceProvider.js";import{createPhotonColorFromString}from"../../util/Color.js";import{Hash}from"../../util/Hash.js";import{ObjectReleaseTracker,releaseObject}from"../../util/ObjectReleaseTracker.js";import{PhotonImageProvider}from"../feature/photon/PhotonImageProvider.js";import{QueryStatus}from"../feature/QueryStatus.js";import{Layer}from"../Layer.js";import{PaintRepresentation}from"../PaintRepresentation.js";import{PhotonCanvasImageDecoder}from"../photon/image/PhotonCanvasImageDecoder.js";import{resolveIconImage,StyleUtil}from"../style/StyleUtil.js";import{DrawFlagType}from"./GEEDbRootDecoder.js";import{GEEPhotonVectorTileSetAdapter}from"./GEEPhotonVectorTileSetAdapter.js";import*as StyleMap from"./GEEVectorStyleMap.js";import{resolveIconStyle}from"../style/complexstroke/photon/PhotonStateResolver.js";import{toPhotonViewBounds}from"../photon/PhotonShapeUtils.js";const PICKINFO_RECORD_SIZE=6;const NO_COLOR=Object.seal({r:0,g:0,b:0,a:0});export class GEEVectorTileSetLayer extends Layer{constructor(e,t){super(e,t);this._translationsMap=t?.translationsMap?.reduce(((e,{stringId:t,stringValue:r})=>{e[t]=r;return e}),{})??{};this._sceneReadyState=false;this._objectReleaseTracker=new ObjectReleaseTracker;this._photonReferenceProvider=this._objectReleaseTracker.track(new PhotonReferenceProvider(Photon));this._pickInfosBuffer=this._objectReleaseTracker.track(Photon.BufferFactory.createUint32BufferFromLength(3e4*PICKINFO_RECORD_SIZE));this._imageProvider=this._objectReleaseTracker.track(new PhotonImageProvider(new PhotonCanvasImageDecoder(Photon),StyleUtil.getFallbackIconUrl));this._vectorPainter=null;this._photonVectorTileSetAdapter=null;this._workingSet=new DummyWorkingSet}get supportedPaintRepresentations(){return[PaintRepresentation.BODY]}get model(){return super.model}set model(e){throw new ProgrammingError("model property is not mutable")}isPaintRepresentationSupported(e){return PaintRepresentation.BODY===e}isReady(){return this._sceneReadyState}_addedToMap(e){if("Photon"!==e.viewPaintingStrategy.techContext.type)throw new ProgrammingError("A MeshLayer can only be added to a WebGLMap");super._addedToMap(e);e.onReady((()=>{const t=e.viewPaintingStrategy.techContext;this._initializePhotonVectorPainter(t);this._map=e}))}_removedFromMap(e){super._removedFromMap(e);this._map=null}_paintBodyLabels(e,t,r){if(!this._vectorPainter||t||r.paintOutput!==Photon.PaintOutput.Normal)return true;this._vectorPainter.update();return this._vectorPainter.paint(e.photonGraphics,false,r.paintOpacity,r.paintDraping,r.paintOutput,r.clip)}pickInfo(e){const t=this._vectorPainter.pickInfo(toPhotonViewBounds(e,this.map.displayScale),this._pickInfosBuffer,true);const r=this._pickInfosBuffer.typedArray;const o=[];for(let e=0;e<t;e++){const t=e*PICKINFO_RECORD_SIZE;const n={level:r[t],x:r[t+1],y:r[t+2],geometryId:r[t+3],styleId:r[t+4],shapeType:getShapeTypeName(r[t+5])};o.push(n)}return o}addStyle(e,t,r,o,n,a){if(a)this.addIconStyle(e,{url:a});if(t||r){const n=this._vectorPainter?.addStyle(e,o||1,t?getPhotonColorFromString(t):NO_COLOR,r?getPhotonColorFromString(r):NO_COLOR);if(n)this._invalidate()}}addIconStyle(e,t){this.resolveToPhotonIcon(t).then((t=>{try{const r=undefined;if(this._vectorPainter.addIconStyle(e,t.photonImage,t.width,t.rotation,t.opacity))this._invalidate()}finally{t.photonImage?.release()}}))}resolveToPhotonIcon(e){const{url:t,image:r,credentials:o}=e;const n=Promise.resolve(resolveIconImage(t,r instanceof HTMLImageElement?r:void 0,Boolean(o)));const a=this._imageProvider;return n.then((e=>resolveIconStyle(a,new Hash,{image:e},false)))}setupStylesOnPainter(){const{baseURL:e}=this.model;this.model.styleAttribute.forEach((t=>{const r=Number.parseInt(t.styleId,16);const o=t.placemarkIconColorAbgr;const n=t.placemarkIconPath?t.placemarkIconPath.stringId?this.getIconPath(t.placemarkIconPath.stringId):t.placemarkIconPath.value:void 0;if(0===t.drawFlag.length){this.addStyle(r,null,null,null,o,n);return}const a=t.drawFlag[0].drawFlagType;const i=a===DrawFlagType.TYPE_FILL_ONLY?null:t.lineColorAbgr;const s=a===DrawFlagType.TYPE_OUTLINE_ONLY?null:t.polyColorAbgr;StyleMap.set(e,r,t.drawFlag[0].drawFlagType);this.addStyle(r,i,s,t.lineWidth,o,n)}))}getIconPath(e){const t=this._translationsMap[e];if(!t)return;return`${this.model.baseURL}/flatfile?lf-0-${t}`}release(){this._objectReleaseTracker.release()}_initializePhotonVectorPainter(e){this._resetPhotonVectorPainter();const t=this._photonVectorTileSetAdapter=this._objectReleaseTracker.track(new GEEPhotonVectorTileSetAdapter(this.model,{},this._photonReferenceProvider));this._vectorPainter=this._objectReleaseTracker.track(Photon.VectorTilePainter.create(e.photonView,e.photonGraphics,t,"VECTOR_PAINTER"));this.on("PaintRepresentationVisibilityChanged",this._scenePainterEnabledUpdate.bind(this));this.on("VisibilityChanged",this._scenePainterEnabledUpdate.bind(this));this.setupStylesOnPainter()}_resetPhotonVectorPainter(){this._vectorPainter=releaseObject(this._vectorPainter)}_scenePainterEnabledUpdate(){this._vectorPainter.setEnabled(this.visible&&this.isPaintRepresentationVisibleInTree(PaintRepresentation.BODY))}}class DummyWorkingSet{constructor(){this._bounds=null;this._idMap=new Map;this._queryStatus=QueryStatus.QUERY_ERROR}get bounds(){return this._bounds}set bounds(e){this._bounds=e}get queryStatus(){return this._queryStatus}set queryStatus(e){this._queryStatus=e}clearAll(){}forEachVisibleNode(){}getIdMapSnapshot(){return this._idMap}getNode(){return null}search(){}_addObject(){}_clearData(){}_registerError(){}_registerFinish(){}_registerInterruption(){}_registerPending(){}_registerStart(){}_registerSuccess(){}_removeObject(){}_updateObject(){}add(){return 0}cancelPending(){}forEachNode(){}forEachVisibleFeature(){}get(){return[]}getFeature(){return null}isReady(){return false}on(){return{remove(){}}}put(){return 0}refreshWorkingSet(){}remove(){return 0}setDelegateWorkingSet(){}setEdited(){return null}setSelected(){return null}}const SHAPE_TYPE=["POINT","POLYLINE","POLYGON"];function getShapeTypeName(e){return SHAPE_TYPE[e]||"UNKNOWN SHAPE TYPE"}function getPhotonColorFromString(e){const t=undefined;const r=undefined;const o=undefined;const n=undefined;return createPhotonColorFromString("rgba("+(255&e)+","+(e>>8&255)+","+(e>>16&255)+","+(e>>24&255)/255+")")??NO_COLOR}