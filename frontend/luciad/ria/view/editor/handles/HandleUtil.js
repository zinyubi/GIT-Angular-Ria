import{ReferenceType}from"../../../reference/ReferenceType.js";import{squaredDistance2D_flat}from"../../../util/Cartesian.js";import{OutOfBoundsError}from"../../../error/OutOfBoundsError.js";import{getHeightAboveTerrainReference}from"../../../reference/ReferenceProvider.js";import{createPoint}from"../../../shape/ShapeFactory.js";import{VecMath}from"../../../util/VecMath.js";import{createTransformation}from"../../../transformation/TransformationFactory.js";import{LayerTreeVisitor}from"../../LayerTreeVisitor.js";import{isBoolean}from"../../../util/Lang.js";import{LayerTreeNode}from"../../LayerTreeNode.js";import{rayPlaneIntersection}from"../../../util/Intersection.js";import{OrthographicCamera}from"../../camera/OrthographicCamera.js";export function viewToModel(e,r,t,n){try{if(r.map.is3D()&&!r.map.isGeospatial()&&!!n)return viewToModel_horizontalPlane(e,r,n);const o=r.onTerrainViewModelTransformation.transform(e);const a=t?0:o.z;o.move3D(o.x,o.y,a);return o}catch(e){OutOfBoundsError.isOrThrow(e);return null}}export function viewToModel_horizontalPlane(e,r,t){try{const n=createTransformation(t.reference,r.map.reference);const o=n.transform(t);const{rayOrigin:a,rayDirection:i}=r.map.camera.getViewingRay(e);let s=VecMath.normalize(o);if(r.map.is3D()&&!r.map.isGeospatial())s={x:0,y:0,z:-1*Math.sign(i.z)};const c=rayPlaneIntersection(s,o,a,i,false);if(!c)return null;return n.inverseTransformation.transform(createPoint(r.map.reference,[c.x,c.y,c.z]))}catch(e){if(e instanceof OutOfBoundsError)return null;throw e}}export function viewToModelOnHeightAxis(e,r,t){if(!r.map.is3D())return null;const n=r.map.camera.toWorld(e);const o=createTransformation(t.reference,r.map.reference);const a=t.copy();const i=a.copy();i.translate3D(0,0,1e3);const s=o.transform(a);const c=o.transform(i);const{rayOrigin:f,rayDirection:m}=r.map.camera.getViewingRay(e);const u=f;const l=closestPointOnLine(s,c,u);const p=VecMath.normalize({x:u.x-l.x,y:u.y-l.y,z:u.z-l.z});let y=VecMath.normalize({x:n.x-u.x,y:n.y-u.y,z:n.z-u.z});if(r.map.camera instanceof OrthographicCamera)y=m;const T=rayPlaneIntersection(p,l,u,y);if(!T)return null;const O=closestPointOnLine(s,c,T);const d=createPoint(r.map.reference,[O.x,O.y,O.z]);const x=createTransformation(r.map.reference,t.reference);try{return x.transform(d)}catch(e){OutOfBoundsError.isOrThrow(e);return null}}export function closestPointOnLine(e,r,t){const n=(r.x-e.x)*(r.x-e.x)+(r.y-e.y)*(r.y-e.y)+(r.z-e.z)*(r.z-e.z);const o=((t.x-e.x)*(r.x-e.x)+(t.y-e.y)*(r.y-e.y)+(t.z-e.z)*(r.z-e.z))/n;return{x:e.x+o*(r.x-e.x),y:e.y+o*(r.y-e.y),z:e.z+o*(r.z-e.z)}}export function convertToAboveGround(e,r){const t=undefined;if(!e.is3D())return r;const n=e.getOnTerrainModelWorldTransformation(r.reference);const o=e.reference.referenceType===ReferenceType.CARTESIAN?n.inputReference:getHeightAboveTerrainReference(n.inputReference.identifier);return createPoint(o,[r.x,r.y,0])}export function removeNullHandles(e){return e.filter((e=>null!==e))}export function squaredViewDistance(e,r,t){try{const n=e.onTerrainModelMapTransformation.transform(r);const o=e.map.mapToViewTransformation.transform(n);return squaredDistance2D_flat(o,t)}catch(e){OutOfBoundsError.isOrThrow(e);return Number.POSITIVE_INFINITY}}export function isDrapableMeshOnMap(e){let r=false;const t={visitLayer(e){const t=e;if(isBoolean(t.isDrapeTarget)&&t.isDrapeTarget){r=true;return LayerTreeVisitor.ReturnValue.ABORT}return LayerTreeVisitor.ReturnValue.CONTINUE},visitLayerGroup(e){e.visitChildren(t,LayerTreeNode.VisitOrder.TOP_DOWN);return r?LayerTreeVisitor.ReturnValue.ABORT:LayerTreeVisitor.ReturnValue.CONTINUE}};e.layerTree.visitChildren(t,LayerTreeNode.VisitOrder.TOP_DOWN);return r}