import{drawClippedPath}from"./util/DashLineClipStroke.js";import{PathIterator}from"./complexstroke/PathIterator.js";import{SimpleXYZPoint}from"../../shape/SimpleXYZPoint.js";import{rotatePointOnOriginCW}from"../../util/Cartesian.js";const tempOutCoordinates=[];export function virtualClipAndAppendWorldPath(t,e,o,r=false,n){const i=o._forwardBatch(t,tempOutCoordinates);if(0===i)return;virtualClipAndAppendViewPath(e,tempOutCoordinates,i,n)}export function virtualClipAndAppendViewPath(t,e,o,r){drawClippedPath(t,e,o,r)}export function appendPath(t,e,o,r=false){let n=o._forwardBatch(t,tempOutCoordinates);let i=0;if(n>1){e.moveTo(tempOutCoordinates[0],tempOutCoordinates[1]);i=2;while(i<n)e.lineTo(tempOutCoordinates[i++],tempOutCoordinates[i++]);if(r){n=t.length;if(t[n-3]===t[0]&&t[n-2]===t[1])e.closePath()}}}export function appendViewPathNoClose(t,e){t.moveTo(e[0],e[1]);let o=2;const r=e.length;while(o<r)t.lineTo(e[o++],e[o++])}export function dashPath(t,e,o,r,n){t.moveTo(e[0],e[1]);let i=2;let a=0;let l=r[0];let p,h,s,u,f,d,m,c,C;let I,P;while(i<o){p=e[i-2];h=e[i-1];s=e[i];u=e[i+1];f=Math.sqrt((s-p)*(s-p)+(u-h)*(u-h));d=(s-p)/f;m=(u-h)/f;I=f;P=0;while(I>l){if(0===l){a=(a+1)%n;l=r[a];continue}P+=l;c=p+P*d;C=h+P*m;if(a%2)t.moveTo(c,C);else t.lineTo(c,C);I-=l;a=(a+1)%n;l=r[a]}if(I>0){if(a%2)t.moveTo(s,u);else t.lineTo(s,u);l-=I}i+=2}}export function calculateOffsetPattern(t,e){let o,r,n,i,a,l;if(!e)return t;if(!t||0===t.length)return[];if(t.length%2)t=t.concat(t);for(i=0,a=t.length;i<a;i++){l=t[i];if("number"!==typeof l||l<0||l===Number.POSITIVE_INFINITY||l===Number.NEGATIVE_INFINITY)return[]}r=0;while(e>0){l=t[r];if(e>=l){e-=l;r=(r+1)%t.length}else break}if(0===e){o=t.slice(r);o=o.concat(t.slice(0,r));if(r%2){o.unshift(0);o.push(0)}}else{o=[t[r]-e];for(i=1,a=t.length;i<a;i++){n=(r+i)%a;o.push(t[n])}o.push(e);if(r%2)o.unshift(0);else o.push(0)}return o}const pathIterator=new PathIterator([0,0,0,0],0,4);export function appendPathSFCT(t,e,o,r,n){let i=o._forwardBatch(t,tempOutCoordinates),a;pathIterator.reload(tempOutCoordinates,0,i);let l=n;if(pathIterator.needToInvertOffset())l*=-1;let p=[];if(0!==l){while(!pathIterator.atEnd()){const t=pathIterator.angle();const e=pathIterator.bisector();const o=-l;const r=l/Math.tan(e);const n=new SimpleXYZPoint(null,r,o,0);rotatePointOnOriginCW(r,o,-t,n);p.push(pathIterator.x()+n.x);p.push(pathIterator.y()+n.y);pathIterator.advanceToNextVertex()}p.push(p[0]);p.push(p[1])}else p=tempOutCoordinates;if(i>1){e.moveTo(p[0],p[1]);a=2;while(a<i)e.lineTo(p[a++],p[a++])}i=Math.min(r.length,i);for(a=0;a<i;a++)r[a]=tempOutCoordinates[a];return i}