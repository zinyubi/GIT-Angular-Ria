import{isOutsideLayerClip}from"../LayerStyle.js";const CELL_SIZE=64;export const LABEL_CONFLICT_PADDING=3;export let ConflictType=function(t){t[t["NO_CONFLICT"]=0]="NO_CONFLICT";t[t["OVERLAP_WITH_LABEL"]=1]="OVERLAP_WITH_LABEL";t[t["OUTSIDE_VIEW"]=2]="OUTSIDE_VIEW";t[t["PARTIALLY_OUTSIDE_VIEW"]=3]="PARTIALLY_OUTSIDE_VIEW";return t}({});class Bucket{constructor(){this._extent=[];this._elements=[];this.size=0}clear(){this.size=0}add(t){this._elements[this.size++]=t}get extent(){return this._extent}set extent(t){this._extent=t}get elements(){return this._elements}}export class LabelConflictChecker{constructor(){this._viewBottom=0;this._viewTop=0;this._viewLeft=0;this._viewRight=0;this._mapHeight=0;this._mapWidth=0;this._cellSize=0;this._buckets=[]}resetViewWidthHeight(t,e,i,s){if(this._viewRight!==i||this._viewBottom!==s){this._viewRight=i;this._viewBottom=s;this._viewLeft=t;this._viewTop=e;const h=undefined;const n=CELL_SIZE*1|0;this._cellSize=n;this._mapWidth=Math.ceil(i/n);this._mapHeight=Math.ceil(s/n);this._buckets=new Array(this._mapWidth*this._mapHeight);for(let t=0;t<this._mapWidth;t++)for(let e=0;e<this._mapHeight;e++){const i=t*n;const s=e*n;const h=new Bucket;h.extent=[i,s,i+n,s+n];this._buckets[t+e*this._mapWidth]=h}}}clear(){for(let t=this._buckets.length-1;t>=0;t--)this._buckets[t].clear()}isValidPosition(t,e){if(isOutsideLayerClip(t,this._viewBottom,e))return ConflictType.OUTSIDE_VIEW;const i=t.getOLeft(true);const s=t.getORight(true);const h=t.getOTop(true);const n=t.getOBottom(true);if(this._viewLeft<this._viewRight&&this._viewTop<this._viewBottom&&this._viewLeft<=i&&this._viewTop<=h&&this._viewRight>=s&&this._viewBottom>=n)return this.intersects(t)?ConflictType.OVERLAP_WITH_LABEL:ConflictType.NO_CONFLICT;if(this._viewLeft<s&&i<this._viewRight&&this._viewTop<n&&h<this._viewBottom)return this.intersects(t)?ConflictType.OVERLAP_WITH_LABEL:ConflictType.PARTIALLY_OUTSIDE_VIEW;return ConflictType.OUTSIDE_VIEW}addPosition(t){const{minX:e,minY:i,width:s,height:h}=this.getBoxSize(t);const n=this._mapWidth;const o=i*n+h*n;for(let h=i*n;h<o;h+=n)for(let i=h+e,n=i+s;i<n;i++)this._buckets[i].add(t)}intersects(t){const{minX:e,minY:i,width:s,height:h}=this.getBoxSize(t);const n=this._mapWidth;const o=i*n+h*n;for(let h=i*n;h<o;h+=n){const i=h+e+s;for(let s=h+e;s<i;s++){const e=this._buckets[s];const i=e.elements;for(let s=0,h=e.size;s<h;s+=1)if(i[s].intersects(t,true))return true}}return false}getBoxSize(t){const e=Math.max(0,t.getOLeft(true)/this._cellSize|0);const i=Math.max(0,t.getOTop(true)/this._cellSize|0);const s=undefined;const h=undefined;const n=undefined;const o=undefined;return{minX:e,minY:i,width:Math.min(this._mapWidth,(t.getORight(true)/this._cellSize|0)+1)-e,height:Math.min(this._mapHeight,(t.getOBottom(true)/this._cellSize|0)+1)-i}}isLabelAllowed(t){const e=this.isValidPosition(t);return e===ConflictType.NO_CONFLICT||e===ConflictType.PARTIALLY_OUTSIDE_VIEW||e===ConflictType.OUTSIDE_VIEW}}