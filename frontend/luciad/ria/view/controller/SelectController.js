import{HandleEventResult}from"./HandleEventResult.js";import{SelectionType}from"../SelectionType.js";import{ModifierType}from"../input/ModifierType.js";import{GestureEventType}from"../input/GestureEventType.js";import{isFunction}from"../../util/Lang.js";import{FeatureLayer}from"../feature/FeatureLayer.js";import{PickController}from"./PickController.js";import{isPoint}from"../../shape/Point.js";import{LocationMode}from"../../transformation/LocationMode.js";export class SelectController extends PickController{constructor(){super();this._displayedBalloonFor=null}getCandidates(e,t,o,i){if(!this.map||!e)return[];const n=!i;const l=1+2*t;const r=this.map._pickRect(e.x,e.y,l,l,n,false,(e=>!!e.selectable),o);return Array.isArray(r)?r:r?[r]:[]}handleCandidates(e,t){if(!this.map)return HandleEventResult.EVENT_IGNORED;let o;if(t.length>0){const i=t[0];o=i.layer.onClick(i.objects[0]);if(!o)o=this.map.onClick(e);if(!o){const t=this.getSelectionType(e);this.selectAndShowBalloon(e,i,t)}}else{o=this.map.onClick(e);if(!o){this.map.clearSelection();this.map.hideBalloon();o=true}}return o?HandleEventResult.EVENT_HANDLED:HandleEventResult.EVENT_IGNORED}isPickEvent(e){return e.type===GestureEventType.SINGLE_CLICK_CONFIRMED}isShowBalloon(e,t){return true}getSelectionType(e){if(e.modifier===ModifierType.SHIFT)return SelectionType.TOGGLE;return SelectionType.NEW}selectAndShowBalloon(e,t,o){if(!this.map)return;this.map.selectObjects([t],{editSelection:o});const i=this.map.isSelected(t.layer,t.objects[0]);const n=this._displayedBalloonFor&&this._displayedBalloonFor.feature.id!==t.objects[0].id&&this._displayedBalloonFor.layer!==t.layer;if(i&&n){this.map.hideBalloon();this._displayedBalloonFor=null}if(t.objects.length>=0&&i&&this.isShowBalloon(e,t))this.showBalloonFor(t,e.viewPoint)}showBalloonFor({layer:e,objects:t},o){if(this.map&&isFunction(e.balloonContentProvider)){const i=t[0];const n=e instanceof FeatureLayer&&!isPoint(i.shape)?this.getBalloonAnchor(o):void 0;this._displayedBalloonFor={feature:i,layer:e,anchor:n};this.map.showBalloon(this._displayedBalloonFor)}}getBalloonAnchor(e){try{return this.map?.getViewToMapTransformation(LocationMode.CLOSEST_SURFACE).transform(e)}catch(e){}}}