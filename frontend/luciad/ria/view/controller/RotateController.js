import{Controller}from"./Controller.js";import{HandleEventResult}from"./HandleEventResult.js";import{GestureEventType}from"../input/GestureEventType.js";import{createPoint}from"../../shape/ShapeFactory.js";import{Constants}from"../../util/Constants.js";import{createTransformation}from"../../transformation/TransformationFactory.js";const ROTATION_DAMPING_FACTOR_3D=-10;const RIGHT_MOUSE_BUTTON=2;function isTouchRotate(t,e){const n=e?GestureEventType.ROTATE_END:GestureEventType.ROTATE;return"touch"===t.inputType&&t.type===n}function isTouchTwoFingerDrag(t,e){const n=e?GestureEventType.TWO_FINGER_DRAG_END:GestureEventType.TWO_FINGER_DRAG;return"touch"===t.inputType&&t.type===n}function isRightMouseDrag(t,e){const n=e?GestureEventType.DRAG_END:GestureEventType.DRAG;return"mouse"===t.inputType&&t.type===n&&isRightMouseButtonDown(t)}function isRightMouseButtonDown(t){if("mouse"===t.inputType){const e=undefined;const n=t.downEvent.domEvent;const o=undefined;return(n?n.button:0)===RIGHT_MOUSE_BUTTON}return false}function getTouchRotateAngle(t){const e=t.downEvent;let n=t.angle-e.angle;if(n>180)n-=360;return n}export class RotateController extends Controller{constructor(){super();this._isRotating=false}onGestureEvent(t){if(!this.map)return HandleEventResult.EVENT_IGNORED;const e=this.isRotateEvent(t);const n=this.isRotateEndEvent(t);if(e&&!n){const e=this.getRotationCenter(t);if(!this._isRotating){if(null===e.reference)this.map.mapNavigator.beginRotate(e.x,e.y);else{const t=undefined;const n=createTransformation(e.reference,this.map.reference).transform(e);this.map.mapNavigator.beginRotateWorld(n)}this._isRotating=true}else{const e=undefined;if(this.map.is3D()){const e=this.getYawAngle(t);const n=this.getPitchAngle(t);this.map.mapNavigator.incrementalRotateAngles(e,n)}else{const e=this.getRotationAngle(t);this.map.mapNavigator.incrementalRotateAngles(e,0)}}return HandleEventResult.EVENT_HANDLED}else if(e&&n){this.map.mapNavigator.endRotate();this._isRotating=false;return HandleEventResult.EVENT_HANDLED}return HandleEventResult.EVENT_IGNORED}isRotateEvent(t){return isRightMouseDrag(t,false)||isTouchRotate(t,false)||isTouchTwoFingerDrag(t,false)||this.isRotateEndEvent(t)}isRotateEndEvent(t){return isRightMouseDrag(t,true)||isTouchRotate(t,true)||isTouchTwoFingerDrag(t,true)}getRotationCenter(t){if(isRightMouseDrag(t,false)&&this.map&&!this.map.is3D())return createPoint(null,[this.map.viewSize[0]/2,this.map.viewSize[1]/2]);return t.viewPoint}getYawAngle(t){if(isRightMouseDrag(t,false)){const e=t;const n=e.downEvent;const o=undefined;return(e.viewPoint.x-n.viewPoint.x)/ROTATION_DAMPING_FACTOR_3D}if(isTouchRotate(t,false))return getTouchRotateAngle(t);return 0}getPitchAngle(t){if(isRightMouseDrag(t,false)||isTouchTwoFingerDrag(t,false)){const e=t.downEvent;const n=undefined;return(t.viewPoint.y-e.viewPoint.y)/ROTATION_DAMPING_FACTOR_3D}return 0}getRotationAngle(t){if(!this.map)return 0;if(isRightMouseDrag(t,false)){const e=t;const n=e.downEvent;const o=createPoint(null,[this.map.viewSize[0]/2,this.map.viewSize[1]/2]);const i=undefined;const s=undefined;return(Math.atan2(n.viewPoint.y-o.y,n.viewPoint.x-o.x)*Constants.RAD2DEG-Math.atan2(e.viewPoint.y-o.y,e.viewPoint.x-o.x)*Constants.RAD2DEG)%360}if(isTouchRotate(t,false))return getTouchRotateAngle(t);return 0}}