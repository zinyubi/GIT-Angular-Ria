import{ProgrammingError}from"../../error/ProgrammingError.js";import{Vector3 as Vector3Int}from"../../geometry/mesh/math/Vector3.js";import{ReferenceType}from"../../reference/ReferenceType.js";import{createTransformation}from"../../transformation/TransformationFactory.js";import{distance3D}from"../../util/Cartesian.js";import{Constants}from"../../util/Constants.js";import{isNumber}from"../../util/Lang.js";import{Camera}from"./Camera.js";export class PerspectiveCamera extends Camera{constructor(e,t,r,s,i,n,o,a,h){super(e,t,r,s,i,n,o,h);if(!isNumber(a))throw new ProgrammingError("PerspectiveCamera fovY is not a number");this._fovY=a}get fovY(){return this._fovY}getScaleAt(e){const t=undefined;const r=2*distance3D(this._eye,e)*Math.tan(.5*this._fovY*Math.PI/180);return this.height/r}getViewingRay(e){const t=this.toWorld(e);const r=new Vector3Int(t.x,t.y,t.z);r.sub(this._eye);r.normalize();return{rayOrigin:this.eye,rayDirection:r}}computeProjectionMatrix(e){const t=this.width/this.height;e.perspectiveGLMatrixJS(this._fovY*Constants.DEG2RAD,t,this.near,this.far)}copy(){const e=new PerspectiveCamera(this.eye,this.forward,this.up,this.near,this.far,this.width,this.height,this.fovY,this.worldReference);this._copyLookAtLookFromIfPossible(e);return e}copyAndSet(e){let t="undefined"!==typeof e.eye?e.eye:this.eye;const r="undefined"!==typeof e.worldReference?e.worldReference:this.worldReference;if(t.reference&&!t.reference.equals(r))t=createTransformation(t.reference,r).transform(t);const s=new PerspectiveCamera(t,e.forward??this.forward,e.up??this.up,e.near??this.near,e.far??this.far,e.width??this.width,e.height??this.height,e.fovY??this.fovY,r);this._copyLookAtLookFromIfPossible(s);return s}equals(e){if(!(e instanceof PerspectiveCamera))return false;return Math.abs(this._eye.x-e._eye.x)<=Constants.ABSOLUTE_DISTANCE_TOLERANCE&&Math.abs(this._eye.y-e._eye.y)<=Constants.ABSOLUTE_DISTANCE_TOLERANCE&&Math.abs(this._eye.z-e._eye.z)<=Constants.ABSOLUTE_DISTANCE_TOLERANCE&&Math.abs(this._forward.x-e._forward.x)<=Constants.ABSOLUTE_DISTANCE_TOLERANCE&&Math.abs(this._forward.y-e._forward.y)<=Constants.ABSOLUTE_DISTANCE_TOLERANCE&&Math.abs(this._forward.z-e._forward.z)<=Constants.ABSOLUTE_DISTANCE_TOLERANCE&&Math.abs(this._up.x-e._up.x)<=Constants.ABSOLUTE_DISTANCE_TOLERANCE&&Math.abs(this._up.y-e._up.y)<=Constants.ABSOLUTE_DISTANCE_TOLERANCE&&Math.abs(this._up.z-e._up.z)<=Constants.ABSOLUTE_DISTANCE_TOLERANCE&&this._near===e._near&&this._far===e._far&&this._width===e._width&&this._height===e._height&&this._fovY===e._fovY&&this.worldReference.equals(e.worldReference)}toString(){return`PerspectiveCamera: \n\teye: [${this._eye.x}, ${this._eye.y}, ${this._eye.z}]\n\tforward: [${this._forward.x}, ${this._forward.y}, ${this._forward.z}]\n\tup: [${this._up.x}, ${this._up.y}, ${this._up.z}]\n\twidth: ${this._width}\n\theight: ${this._height}\n\tnear: ${this.near}\n\tfar: ${this.far}\n\tfovY: ${this._fovY}\n\taspectRatio: ${this.aspectRatio}\n\treference: ${this.worldReference.identifier}`}static createDefaultCamera(e,t,r){if(e.referenceType===ReferenceType.GEOCENTRIC)return new PerspectiveCamera(new Vector3Int(12755302.578841701,0,-111313.83923667668),new Vector3Int(-.9998476951563913,0,.017452406437283595),new Vector3Int(.017452406437283595,0,.9998476951563914),1e3,1e15,t,r,60,e);else if(e.referenceType===ReferenceType.GRID){const s=e.bounds;return new PerspectiveCamera(new Vector3Int(0,0,s.width),new Vector3Int(0,0,-1),new Vector3Int(0,1,0),1,4*s.width,t,r,60,e)}else return new PerspectiveCamera(new Vector3Int(0,0,1),new Vector3Int(0,1,0),new Vector3Int(0,0,1),.3,1e3,t,r,60,e)}lookFrom(e){return super.lookFrom(e)}lookAt(e){return super.lookAt(e)}createCamera(e,t,r){return new PerspectiveCamera(e,t,r,this.near,this.far,this.width,this.height,this.fovY,this.worldReference)}}