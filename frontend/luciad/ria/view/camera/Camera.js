import{Vector4}from"../../geometry/mesh/math/Vector4.js";import{Matrix4}from"../../geometry/mesh/math/Matrix4.js";import{Vector3 as Vector3Int}from"../../geometry/mesh/math/Vector3.js";import{ProgrammingError}from"../../error/ProgrammingError.js";import{createPoint}from"../../shape/ShapeFactory.js";import{createTransformation,createTransformationWithOptions,isTransformationRequired}from"../../transformation/TransformationFactory.js";import{isNumber}from"../../util/Lang.js";import{XYZBounds}from"../../shape/XYZPointBounds.js";import{createTopocentricReference,getReference}from"../../reference/ReferenceProvider.js";import{ReferenceType}from"../../reference/ReferenceType.js";import{TopocentricGeocentricTransformation}from"../../transformation/TopocentricGeocentricTransformation.js";import{clamp,normalizeAngle0To360,orientedAngleOnPlane}from"../../util/Cartesian.js";import{Constants}from"../../util/Constants.js";function isVector3(t){return isNumber(t.x)&&isNumber(t.y)&&isNumber(t.z)}export class Camera{constructor(t,e,o,r,n,i,s,c){if(!isVector3(t))throw new ProgrammingError("Camera eye is not a Vector3 (x, y and z are not all numbers)");if(!isVector3(e))throw new ProgrammingError("Camera forward is not a Vector3 (x, y and z are not all numbers)");if(!isVector3(o))throw new ProgrammingError("Camera up is not Vector3 (x, y and z are not all numbers)");this._eye=new Vector3Int(t.x,t.y,t.z);this._forward=new Vector3Int(e.x,e.y,e.z);this._up=new Vector3Int(o.x,o.y,o.z);if(!isNumber(r))throw new ProgrammingError("Camera near is not a number");this._near=r;if(!isNumber(n))throw new ProgrammingError("Camera far is not a number");this._far=n;if(!isNumber(i))throw new ProgrammingError("Camera width is not a number");this._width=i;if(!isNumber(s))throw new ProgrammingError("Camera height is not a number");this._height=s;this.__matricesDirty=true;this._lookAt=new Vector3Int;this._viewMatrix=new Matrix4;this._projectionMatrix=new Matrix4;this._viewProjectionMatrix=new Matrix4;this._viewProjectionMatrixInverse=new Matrix4;this._tempXYZ=new Vector4;this._worldReference=c;this._tempWorldPoint=createPoint(c,[0,0,0])}get eye(){return this._eye.clone()}get eyePoint(){return createPoint(this._worldReference,[this._eye.x,this._eye.y,this._eye.z])}get forward(){return this._forward.clone()}get up(){return this._up.clone()}get near(){return this._near}get far(){return this._far}get aspectRatio(){if(0===this._width||0===this._height)return 1;return this._width/this._height}get width(){return this._width}get height(){return this._height}get worldReference(){return this._worldReference}_copyLookAtLookFromIfPossible(t){const e=t.eye.x===this.eye.x&&t.eye.y===this.eye.y&&t.eye.z===this.eye.z&&t.forward.x===this.forward.x&&t.forward.y===this.forward.y&&t.forward.z===this.forward.z&&t.up.x===this.up.x&&t.up.y===this.up.y&&t.up.z===this.up.z;if(e&&this._lookFromInternal)t._lookFromInternal={eye:new Vector3Int(this._lookFromInternal.eye.x,this._lookFromInternal.eye.y,this._lookFromInternal.eye.z),yaw:this._lookFromInternal.yaw,pitch:this._lookFromInternal.pitch,roll:this._lookFromInternal.roll};if(e&&this._lookAtInternal)t._lookAtInternal={ref:new Vector3Int(this._lookAtInternal.ref.x,this._lookAtInternal.ref.y,this._lookAtInternal.ref.z),distance:new Vector3Int(this._lookAtInternal.ref.x,this._lookAtInternal.ref.y,this._lookAtInternal.ref.z),yaw:this._lookAtInternal.yaw,pitch:this._lookAtInternal.pitch,roll:this._lookAtInternal.roll}}createTopoToGeocTrans=(()=>{const t=createPoint(LLH_REF,[0,0,0]);return(e,o)=>{const r=createPoint(o,[e.x,e.y,e.z]);const n=undefined;createTransformation(o,LLH_REF).transform(r,t);const i=createTopocentricReference({origin:t});return new TopocentricGeocentricTransformation(i,t,r,o,{createTransformation:createTransformation,createTransformationWithOptions:createTransformationWithOptions,isTransformationRequired:isTransformationRequired})}})();lookFrom(t){return this._lookFrom(t)}_lookFrom=(()=>{const t=new Vector3Int;const e=new Vector3Int;const o=new Vector3Int;const r=new Vector3Int;const n=new Vector3Int;const i=new Vector3Int;const s=new Vector3Int(0,0,0);return c=>{if(!c)throw new ProgrammingError("Camera.lookFrom: lookFrom argument missing");if(c.eye.reference&&!c.eye.reference.equals(this.worldReference)){const e=undefined;createTransformation(c.eye.reference,this.worldReference).transform(c.eye,this._tempWorldPoint);t.copy(this._tempWorldPoint)}else t.copy(c.eye);if(this.worldReference.referenceType!==ReferenceType.GEOCENTRIC){let t=new Vector3Int(0,1,0);let e=new Vector3Int(0,0,1);t=t.applyMatrix4((new Matrix4).makeRotationZ(-c.yaw*Constants.DEG2RAD));e=e.applyMatrix4((new Matrix4).makeRotationZ(-c.yaw*Constants.DEG2RAD));const o=t.clone().cross(e).normalize();t=t.applyMatrix4((new Matrix4).makeRotationAxis(o,c.pitch*Constants.DEG2RAD));e=e.applyMatrix4((new Matrix4).makeRotationAxis(o,c.pitch*Constants.DEG2RAD));e=e.applyMatrix4((new Matrix4).makeRotationAxis(t,c.roll*Constants.DEG2RAD));i.set(e.x,e.y,e.z);r.set(t.x,t.y,t.z)}else{calculateRefPointsCartesian(s,1e5,c.yaw,c.pitch,e,o);e.normalize();o.normalize();const a=this.createTopoToGeocTrans(t,this.worldReference);a.forwardDirection(e,r);a.forwardDirection(o,n);calculateUpVectorGeocentricZeroRoll(r,t,n,i);calculateUpVectorGeocentric(r,i,c.roll,i)}const a=this.createCamera(t,r,i);a._lookFromInternal={eye:new Vector3Int(t.x,t.y,t.z),yaw:c.yaw,pitch:c.pitch,roll:c.roll};return a}})();asLookFrom(){return this._asLookFrom()}_asLookFrom=(()=>{const t=new Vector3Int;const e=new Vector3Int;const o=new Vector3Int;const r=new Vector3Int;const n=new Vector3Int;const i=new Vector3Int;const s=new Vector3Int;const c=new Vector3Int;const a=new Vector3Int;const l=new Vector3Int(0,0,0);return()=>{if(this._lookFromInternal)return{eye:new Vector3Int(this._lookFromInternal.eye.x,this._lookFromInternal.eye.y,this._lookFromInternal.eye.z),yaw:this._lookFromInternal.yaw,pitch:this._lookFromInternal.pitch,roll:this._lookFromInternal.roll};t.copy(this._eye);e.copy(this._forward);o.copy(this._up);if(this.worldReference.referenceType!==ReferenceType.GEOCENTRIC){const r=orientedAngleOnPlane(e,new Vector3Int(0,1,0),new Vector3Int(0,0,1));const n=(null!=r?r:0)*Constants.RAD2DEG;const i=e.clone().cross(o).normalize();const s=orientedAngleOnPlane(o,new Vector3Int(0,0,1),i);const c=orientedAngleOnPlane(e,new Vector3Int(0,1,0),i);const a=-(null!=s?s:null!=c?c:0)*Constants.RAD2DEG;const l=orientedAngleOnPlane(o,new Vector3Int(0,0,1),e);const h=orientedAngleOnPlane(i,new Vector3Int(1,0,0),e);const m=-(null!=l?l:null!=h?h:0)*Constants.RAD2DEG;return{eye:t.clone(),yaw:n,pitch:a,roll:m}}r.addVectors(t,e);const h=this.createTopoToGeocTrans(t,this.worldReference);h.inverseDirection(e,n);const m=calculateYawPitchTopocentric(n,o,r);const w=m.yaw;const p=m.pitch;calculateRefPointsCartesian(l,1,w,p,i,c);i.normalize();c.normalize();h.forwardDirection(i,s);h.forwardDirection(c,a);const f=calculateRoll(s,t,a,o);return{eye:t.clone(),yaw:w,pitch:p,roll:f}}})();lookAt(t){return this.__lookAt(t)}__lookAt=(()=>{const t=new Vector3Int;const e=new Vector3Int;const o=new Vector3Int;const r=new Vector3Int;const n=new Vector3Int;const i=new Vector3Int;const s=new Vector3Int;const c=new Vector3Int;const a=new Vector3Int;const l=new Vector3Int;const h=new Vector3Int;return m=>{if(!m)throw new ProgrammingError("Camera.lookAt: lookAt argument missing");if(m.ref.reference&&!m.ref.reference.equals(this.worldReference)){const e=undefined;createTransformation(m.ref.reference,this.worldReference).transform(m.ref,this._tempWorldPoint);t.copy(this._tempWorldPoint)}else t.copy(m.ref);if(this.worldReference.referenceType!==ReferenceType.GEOCENTRIC){const e=new Vector3Int;calculateEyePointCartesian_1(t,m.distance,m.yaw,m.pitch,e);return this.lookFrom({eye:e,...m})}const w=this.createTopoToGeocTrans(t,this.worldReference);const p=createPoint(w.srcTopocentricReference,[0,0,0]);w.inversePoint(t,p);e.copy(p);calculateEyePointsCartesian(e,m.distance,m.yaw,m.pitch,o,r);s.subVectors(e,o);c.subVectors(e,r);w.forwardDirection(s,a);w.forwardDirection(c,l);a.normalize();l.normalize();w.transform(o,this._tempWorldPoint);n.copy(this._tempWorldPoint);w.transform(r,this._tempWorldPoint);i.copy(this._tempWorldPoint);calculateUpVectorGeocentricZeroRoll(a,i,l,h);calculateUpVectorGeocentric(a,h,m.roll,h);const f=this.createCamera(n,a,h);f._lookAtInternal={ref:new Vector3Int(t.x,t.y,t.z),distance:m.distance,yaw:m.yaw,pitch:m.pitch,roll:m.roll};return f}})();asLookAt(t){return this._asLookAt(t)}_asLookAt=(()=>{const t=new Vector3Int;const e=new Vector3Int;const o=new Vector3Int;const r=new Vector3Int;const n=new Vector3Int;const i=new Vector3Int;const s=new Vector3Int;const c=new Vector3Int;const a=new Vector3Int;const l=new Vector3Int;const h=new Vector3Int;const m=new Vector3Int;const w=new Vector3Int;return p=>{p=p||1;if(this._lookAtInternal&&p===this._lookAtInternal.distance)return{ref:new Vector3Int(this._lookAtInternal.ref.x,this._lookAtInternal.ref.y,this._lookAtInternal.ref.z),distance:this._lookAtInternal.distance,yaw:this._lookAtInternal.yaw,pitch:this._lookAtInternal.pitch,roll:this._lookAtInternal.roll};t.copy(this._eye);e.copy(this._forward);o.copy(this._up);if(this.worldReference.referenceType!==ReferenceType.GEOCENTRIC){const o=this._asLookFrom();const r=undefined;return{ref:t.add(e.multiplyScalar(p)),distance:p,...o}}r.copy(t);r.addScaledVector(e,p);const f=this.createTopoToGeocTrans(r,this.worldReference);f.inverseDirection(e,i);const _=calculateYawPitchTopocentric(i,o,r);const y=_.yaw;const u=_.pitch;const I=createPoint(f.srcTopocentricReference,[0,0,0]);f.inversePoint(r,I);n.copy(I);calculateEyePointsCartesian(n,p,y,u,s,c);l.subVectors(n,s);h.subVectors(n,c);f.forwardDirection(l,m);f.forwardDirection(h,w);m.normalize();w.normalize();f.transform(c,this._tempWorldPoint);a.copy(this._tempWorldPoint);const d=calculateRoll(m,a,w,o);return{ref:r.clone(),distance:p,yaw:y,pitch:u,roll:d}}})();get viewProjectionMatrix(){this._updateMatrices();return this._viewProjectionMatrix}get bounds(){const t=0;const e=this._width;const o=0;const r=this._height;const n=0;const i=1;const s=new XYZBounds(this._worldReference);for(let c=0;c<8;c++){const a=this.toWorld({x:c%2<1?t:e,y:c%4<2?o:r,z:c%8<4?n:i});if(0===c)s.move3D(a.x,a.y,a.z);else s.includeCoordinate3D(a.x,a.y,a.z)}return s}toView(t,e){this._updateMatrices();this._tempXYZ.set(t.x||0,t.y||0,t.z||0,1);this._tempXYZ.applyMatrix4(this._viewProjectionMatrix);if(this._tempXYZ.w<=0)return{x:NaN,y:NaN,z:NaN};this._tempXYZ.multiplyScalar(1/this._tempXYZ.w);this._toPixelsSFCT(this._tempXYZ);if(!e)return{x:this._tempXYZ.x,y:this._tempXYZ.y,z:this._tempXYZ.z};e.x=this._tempXYZ.x;e.y=this._tempXYZ.y;e.z=this._tempXYZ.z;return e}toViewPoint(t,e){if(null!=t.reference&&!this._worldReference.equals(t.reference)){const e=undefined;createTransformation(t.reference,this._worldReference).transform(t,this._tempWorldPoint)}else this._tempWorldPoint.move3DToPoint(t);if(!e)e=createPoint(null,[]);this.toView(this._tempWorldPoint,e);return e}toWorld(t,e){this._updateMatrices();this._tempXYZ.set(t.x||0,t.y||0,t.z||0,1);this._toNDCSFCT(this._tempXYZ);this._tempXYZ.applyMatrix4(this._viewProjectionMatrixInverse);this._tempXYZ.multiplyScalar(1/this._tempXYZ.w);if(!e)return{x:this._tempXYZ.x,y:this._tempXYZ.y,z:this._tempXYZ.z};e.x=this._tempXYZ.x;e.y=this._tempXYZ.y;e.z=this._tempXYZ.z;return e}toWorldPoint(t,e){if(!e)e=createPoint(this._worldReference,[0,0,0]);this.toWorld(t,this._tempWorldPoint);if(null!=e.reference&&!this._worldReference.equals(e.reference)){const t=undefined;createTransformation(this._worldReference,e.reference).transform(this._tempWorldPoint,e)}else e.move3DToPoint(this._tempWorldPoint);return e}computeViewMatrix(t){this._lookAt.addVectors(this._eye,this._forward);t.lookAtGLMatrixJS(this._eye,this._lookAt,this._up)}_updateMatrices(){if(!this.__matricesDirty)return;this.__matricesDirty=false;this.computeViewMatrix(this._viewMatrix);this.computeProjectionMatrix(this._projectionMatrix);this._viewProjectionMatrix.multiplyMatrices(this._projectionMatrix,this._viewMatrix);this._viewProjectionMatrixInverse.getInverse(this._viewProjectionMatrix)}_toPixelsSFCT(t){const e=(t.x+1)*(this._width/2);const o=(-t.y+1)*(this._height/2);const r=.5*(t.z+1);t.set(e,o,r,t.w)}_toNDCSFCT(t){const e=t.x/(this._width/2)-1;const o=-(t.y/(this._height/2)-1);const r=2*t.z-1;t.set(e,o,r,t.w)}}const MIN_DISTANCE=1e-8;const MAX_DISTANCE=5e8;const LLH_REF=getReference("CRS:84");const PITCH_SENSITIVITY=.01;const calculateYawPitchTopocentric=(()=>{const t=new Vector3Int;const e=new Vector3Int;const o=new Vector3Int;const r=new Vector3Int;const n=new Vector3Int;return(i,s,c)=>{t.copy(i);const a=Math.atan2(t.z,Math.sqrt(t.x*t.x+t.y*t.y));let l;if(Math.abs(a)<.5*Math.PI-PITCH_SENSITIVITY||Math.abs(a)>.5*Math.PI-PITCH_SENSITIVITY)l=Math.atan2(t.x,t.y);else{e.copy(s);o.copy(c);o.normalize();r.set(o.y,-o.x,0);r.normalize();n.crossVectors(o,r);const t=e.dot(o);e.subVectors(e,o.multiplyScalar(t));e.normalize();l=Math.acos(n.dot(e));r.crossVectors(n,e);if(o.dot(r)>0)l=-l;l+=Math.PI}const h=undefined;const m=undefined;return{yaw:normalizeAngle0To360(l*Constants.RAD2DEG),pitch:a*Constants.RAD2DEG}}})();const calculateRefPointsCartesian=(t,e,o,r,n,i)=>{calculateRefPointCartesian_1(t,e,o,r,n);if(r<-85)calculateRefPointCartesian_1(t,e,o,-85,i);else if(r>85)calculateRefPointCartesian_1(t,e,o,85,i);else i.copy(n)};const calculateRefPointCartesian_1=(()=>{const t=new Vector4;const e=new Matrix4;const o=new Matrix4;return(r,n,i,s,c)=>{t.set(0,1,0,1);const a=s*Constants.DEG2RAD;e.makeRotationX(a);const l=-i*Constants.DEG2RAD;o.makeRotationZ(l);t.applyMatrix4(e);t.applyMatrix4(o);n=clamp(n,MIN_DISTANCE,MAX_DISTANCE);t.multiplyScalar(n);c.addVectors(r,t)}})();const calculateEyePointsCartesian=(t,e,o,r,n,i)=>{calculateEyePointCartesian_1(t,e,o,r,n);if(r<-85)calculateEyePointCartesian_1(t,e,o,-85,i);else if(r>85)calculateEyePointCartesian_1(t,e,o,85,i);else i.copy(n)};const calculateEyePointCartesian_1=(()=>{const t=new Vector4;const e=new Matrix4;const o=new Matrix4;return(r,n,i,s,c)=>{t.set(0,1,0,1);const a=s*Constants.DEG2RAD;e.makeRotationX(a);const l=-i*Constants.DEG2RAD;o.makeRotationZ(l);t.applyMatrix4(e);t.applyMatrix4(o);n=clamp(n,MIN_DISTANCE,MAX_DISTANCE);t.multiplyScalar(n);c.subVectors(r,t)}})();const calculateRoll=(()=>{const t=new Vector3Int;const e=new Vector3Int;return(o,r,n,i)=>{calculateUpVectorGeocentricZeroRoll(o,r,n,t);const s=clamp(t.dot(i),-1,1);let c=Math.acos(s);e.crossVectors(t,i);if(o.dot(e)<0)c=-c;return normalizeAngle0To360(c*Constants.RAD2DEG)}})();const calculateUpVectorGeocentricZeroRoll=(()=>{const t=new Vector3Int;const e=new Vector3Int;const o=new Vector3Int;return(r,n,i,s)=>{t.copy(n);t.normalize();e.crossVectors(i,t);e.normalize();t.crossVectors(e,i);e.crossVectors(r,t);o.crossVectors(e,r);o.normalize();o.normalize();s.copy(o)}})();const calculateUpVectorGeocentric=(()=>{const t=new Matrix4;const e=new Vector3Int;return(o,r,n,i)=>{const s=n*Constants.DEG2RAD;t.makeRotationAxis(o,s);e.copy(r);e.applyMatrix4(t);e.normalize();i.copy(e)}})();