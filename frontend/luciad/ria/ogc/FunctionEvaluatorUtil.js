import{isPolyline}from"../shape/Polyline.js";import{isPolygon}from"../shape/Polygon.js";import{createBounds,createShapeList}from"../shape/ShapeFactory.js";import{isPoint}from"../shape/Point.js";import{getReference}from"../reference/ReferenceProvider.js";import{createTransformation,isTransformationRequired}from"../transformation/TransformationFactory.js";import{Log}from"../util/Log.js";import{interpolateColor}from"../util/Color.js";import{clamp}from"../util/Cartesian.js";import{isShapeList}from"../shape/ShapeList.js";import{isComplexPolygon}from"../shape/ComplexPolygon.js";import{createGeodesy}from"../geodesy/GeodesyFactory.js";import{isArray,isString}from"../util/Lang.js";import{isArc}from"../shape/Arc.js";const logger=new Log({avoidDuplicateMessages:true});export function createEvaluationFunction(e){return new Function(FUNCTION_EVALUATORS_PARAMETER_NAME,FEATURE_PARAMETER_NAME,SHAPE_PARAMETER_NAME,e)}export function defaultFunctionNameForExpectedOutput(e){if("string"===e)return"defaultStringEvaluator";else if("number"===e)return"defaultNumberEvaluator";else if("Shape | null"===e)return"defaultShapeEvaluator";else if("boolean"===e)return"defaultBooleanEvaluator";return"defaultBooleanEvaluator"}export function returnValueFromDefault(e){if("defaultStringEvaluator"===e)return"";else if("defaultNumberEvaluator"===e)return"0";else if("defaultBooleanEvaluator"===e)return"false";else if("defaultShapeEvaluator"===e)return`${FEATURE_PARAMETER_NAME}[${SHAPE_PARAMETER_NAME}]`;return""}export const PRE_DEFINED_FUNCTION_EVALUATORS={defaultStringEvaluator:()=>"",defaultNumberEvaluator:()=>0,defaultBooleanEvaluator:()=>false,defaultShapeEvaluator:e=>e.shape,interactsWithBbox:interactsWithBbox,vertices:vertices,startPoint:startPoint,endPoint:endPoint,startAngle:startAngle,endAngle:endAngle,Recode:recode,Categorize:categorize,Interpolate:interpolate,strTrim:strTrim,parameter:parameter,dateParse:dateParse,dateFormat:dateFormat};function interactsWithBbox(e,t,n,r,o,i){const s=e.reference;const a=e.bounds;if(s&&a){let e;if(t)e=getReference(t);else e=s;const l=createBounds(e,[n,o-n,r,i-r]);let f;if(!isTransformationRequired(e,s))f=l;else{const t=createTransformation(e,s);f=createBounds(s);t.transformBounds(l,f)}return f.interacts2D(a)}else{Log.error("Symbology Encoding Painter: ignoring spatial filter");return true}}function vertices(...e){return getPoints(LOCATION.all,e[0])}function startPoint(...e){const t=e[0];if(isArc(t)){const e=t.startAzimuth-t.rotationAzimuth;return t.interpolate(e/360)}return getPoints(LOCATION.start,t)}function endPoint(...e){const t=e[0];if(isArc(t)){const e=t.startAzimuth+t.sweepAngle-t.rotationAzimuth;return t.interpolate(e/360)}return getPoints(LOCATION.end,t)}function startAngle(...e){const t=e[0];if(isArc(t)){const e=t.startPoint;const n=t.startAzimuth-t.rotationAzimuth;const r=t.interpolate(n/360+.01);return 180+createGeodesy(e.reference).forwardAzimuth(e,r)}return getAngle(LOCATION.start,t)}function endAngle(...e){const t=e[0];if(isArc(t)){const e=t.endPoint;const n=t.startAzimuth+t.sweepAngle-t.rotationAzimuth;const r=t.interpolate(n/360-.01);return 180+createGeodesy(e.reference).forwardAzimuth(e,r)}return getAngle(LOCATION.end,t)}var LOCATION=function(e){e[e["start"]=0]="start";e[e["end"]=1]="end";e[e["all"]=2]="all";return e}(LOCATION||{});function getPoints(e,t){const n=[];addVertices(n,t);if(0===n.length)return null;else if(1===n.length)return n[0];else switch(e){case LOCATION.start:return n[0];case LOCATION.end:return n[n.length-1];case LOCATION.all:default:return createShapeList(n[0].reference,n)}}function getAngle(e,t){if(e===LOCATION.all)return null;const n=[];addVertices(n,t);if(n.length<2)return null;else{const t=e===LOCATION.start?n[0]:n[n.length-1];const r=e===LOCATION.start?n[1]:n[n.length-2];return 180+createGeodesy(t.reference).forwardAzimuth(t,r)}}function addVertices(e,t){const n=t.type?t:t.shape;if(null===n||null===n.reference)return;if(isShapeList(n))for(let t=0;t<n.shapeCount;t++)addVertices(e,n.getShape(t));else if(isComplexPolygon(n))for(let t=0;t<n.polygonCount;t++)addVertices(e,n.getPolygon(t));else if(isPolyline(n)||isPolygon(n))for(let t=0;t<n.pointCount;t++)e.push(n.getPoint(t));else if(isPoint(n))e.push(n);else if(null!==n.focusPoint)e.push(n.focusPoint)}function recode(...e){const t=`${e[0]}`;for(let n=1;n<e.length;n+=2){const r=e[n];const o=e[n+1];if(t===r)return o}return}function categorize(...e){const t=e[0];let n=Number.MIN_VALUE;let r=Number.MIN_VALUE;for(let o=1;o<e.length;o+=2){const i=e[o];n=r;r=o+1<e.length?e[o+1]:Number.MAX_VALUE;if(t>=n&&t<=r)return i}return}const possibleInterpolationModes=["linear","cubic","cosine"];const possibleInterpolationMethods=["color","numeric"];function interpolate(...e){const t=e[0];const n=e[e.length-1];const r=possibleInterpolationModes.indexOf(n)>-1;const o=possibleInterpolationMethods.indexOf(n)>-1;const i=e[e.length-2];const s=possibleInterpolationModes.indexOf(i)>-1;const a=possibleInterpolationMethods.indexOf(i)>-1;const l="linear";let f="linear";if(r)f=n;else if(s)f=i;if(f!==l)logger.warn(`The interpolation mode ${f} that you provided is not supported, it will be replaced with ${l}.`);let c="color";if(o)c=n;else if(a)c=i;let u=e.length-1;if(r||o)u--;if(a||s)u--;const d=[];const p=[];for(let t=1;t<u;t+=2){d.push(Number.parseFloat(e[t]));p.push(e[t+1])}let m=0;let g=0;for(let e=0;e<d.length-1;e++)if(t>=d[e]){m=e;g=(t-d[e])/(d[e+1]-d[e])}g=clamp(g,0,1);switch(c){case"numeric":{const e=Number.parseFloat(p[m]);const t=undefined;return e+g*(Number.parseFloat(p[m+1])-e)}case"color":default:return interpolateColor(p[m],p[m+1],g)}}function strTrim(...e){const t=undefined;return e[0].replaceAll("^\\s+|\\s+$","")}function parameter(...e){if(!isArray(e))return`${e}`;let t=``;for(const n of e)t+=`${n}`;return t}function dateParse(e){return new Date(e)}function dateFormat(...e){if(e.length<2)return"";let t=e[0];let n=e[1];if(isString(t)&&isString(n)){t=t.trim();n=n.trim();const e=0===t.length?NaN:Number(t).valueOf();if(!isNaN(e))t=e;const r=0===n.length?NaN:Number(n).valueOf();if(!isNaN(r))n=r}const r=new Date(t);const o=new Date(n);const i=r.getTime();const s=o.getTime();if(isNaN(i)&&isNaN(s))return"Invalid Date";else{const e=isNaN(i)?o:r;let s=isNaN(i)?t:n;s=s.replace("dd","DD");s=s.replace("d","D");s=s.replace("yyyy","YYYY");s=s.replace("yy","YY");let a="";let l="short";if(s.indexOf("MMMMM")>-1){const e=s.indexOf("MMMMM");a=s.substring(e+5,e+7);l="long"}else if(s.indexOf("MMM")>-1){const e=s.indexOf("MMM");a=s.substring(e+3,e+5);l="short"}let f="en";let c="";if(LANGUAGE_CODES.indexOf(a)>-1){f=a;c=a}const u=undefined;const d=new Intl.DateTimeFormat(f,{month:l}).format(e);if(s.indexOf("MMMMM")>-1)s=s.replace(`MMMMM${c}`,`MMMMMM`);else if(s.indexOf("MMM")>-1)s=s.replace(`MMM${c}`,`MMMM`);const p=`${e.getFullYear()}`;if(s.indexOf("YYYY")>-1)s=s.replace("YYYY",p);else if(s.indexOf("YY")>-1)s=s.replace("YY",p.substring(2));let m=`${e.getDate()}`;if(s.indexOf("DD")>-1){if(1===m.length)m=`0${m}`;s=s.replace("DD",m)}else if(s.indexOf("D")>-1)s=s.replace("D",m);let g=e.getHours();const M=g<=12?"am":"pm";if(s.indexOf("a")>-1&&g>12)g-=12;let h=`${g}`;if(s.indexOf("hh")>-1){if(1===h.length)h=`0${h}`;s=s.replace("hh",h)}else if(s.indexOf("h")>-1)s=s.replace("h",h);let A=`${e.getMinutes()}`;if(s.indexOf("mm")>-1){if(1===A.length)A=`0${A}`;s=s.replace("mm",A)}else if(s.indexOf("m")>-1)s=s.replace("m",A);let O=`${e.getSeconds()}`;if(s.indexOf("ss")>-1){if(1===O.length)O=`0${O}`;s=s.replace("ss",O)}else if(s.indexOf("s")>-1)s=s.replace("s",O);if(s.indexOf("a")>-1)s=s.replace("a",M);if(s.indexOf("z")>-1)s=s.replace("z","");let E=`${e.getMonth()+1}`;if(s.indexOf("MMMMMM")>-1)s=s.replace(`MMMMMM`,d);else if(s.indexOf("MMMM")>-1)s=s.replace(`MMMM`,d.toUpperCase());else if(s.indexOf("MM")>-1){if(1===E.length)E=`0${E}`;s=s.replace("MM",E)}else if(s.indexOf("M")>-1)s=s.replace("M",E);return s}}const LANGUAGE_CODES=["aa","ab","ae","af","ak","am","an","ar","as","av","ay","az","ba","be","bg","bi","bm","bn","bo","br","bs","ca","ce","ch","co","cr","cs","cu","cv","cy","da","de","dv","dz","ee","el","en","eo","es","et","eu","fa","ff","fi","fj","fo","fr","fy","ga","gd","gl","gn","gu","gv","ha","he","hi","ho","hr","ht","hu","hy","hz","ia","id","ie","ig","ii","ik","io","is","it","iu","ja","jv","ka","kg","ki","kj","kk","kl","km","kn","ko","kr","ks","ku","kv","kw","ky","la","lb","lg","li","ln","lo","lt","lu","lv","mg","mh","mi","mk","ml","mn","mr","ms","mt","my","na","nb","nd","ne","ng","nl","nn","no","nr","nv","ny","oc","oj","om","or","os","pa","pi","pl","ps","pt","qu","rm","rn","ro","ru","rw","sa","sc","sd","se","sg","si","sk","sl","sm","sn","so","sq","sr","ss","st","su","sv","sw","ta","te","tg","th","ti","tk","tl","tn","to","tr","ts","tt","tw","ty","ug","uk","ur","uz","ve","vi","vo","wa","wo","xh","yi","yo","za","zh","zu"];export const FEATURE_PARAMETER_NAME="feature";export const SHAPE_PARAMETER_NAME="shape";export const FUNCTION_EVALUATORS_PARAMETER_NAME="functionEvaluators";