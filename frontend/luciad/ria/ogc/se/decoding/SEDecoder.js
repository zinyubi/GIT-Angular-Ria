import{XML}from"../../../util/XML.js";import{Log}from"../../../util/Log.js";import{StyleUtil}from"../../../view/style/StyleUtil.js";import{FilterDecoder}from"../../filter/FilterDecoder.js";import{AnchorPoint}from"../model/AnchorPoint.js";import{Description}from"../model/Description.js";import{Displacement}from"../model/Displacement.js";import{ExternalGraphic}from"../model/ExternalGraphic.js";import{FeatureTypeStyle}from"../model/FeatureTypeStyle.js";import{Fill}from"../model/Fill.js";import{Font}from"../model/Font.js";import{Graphic}from"../model/Graphic.js";import{GraphicFill}from"../model/GraphicFill.js";import{GraphicStroke}from"../model/GraphicStroke.js";import{Halo}from"../model/Halo.js";import{InlineContent}from"../model/InlineContent.js";import{LabelPlacement}from"../model/LabelPlacement.js";import{LineSymbolizer}from"../model/symbolizer/LineSymbolizer.js";import{LinePlacement}from"../model/LinePlacement.js";import{Parameter}from"../model/Parameter.js";import{PointSymbolizer}from"../model/symbolizer/PointSymbolizer.js";import{PointPlacement}from"../model/PointPlacement.js";import{PolygonSymbolizer}from"../model/symbolizer/PolygonSymbolizer.js";import{TextSymbolizer}from"../model/symbolizer/TextSymbolizer.js";import{Rule}from"../model/Rule.js";import{Stroke}from"../model/Stroke.js";import{DEFAULT_WELL_KNOWN_NAME,Mark}from"../model/Mark.js";import{SVGParameter}from"../model/SVGParameter.js";import{SEDecoderErrorHandler}from"./SEDecoderErrorHandler.js";import{SEElementType}from"../model/SEElementType.js";import{getUom,isPrimitive,toBoolean}from"../util/SEUtil.js";import{isBoolean,isNumber,isString}from"../../../util/Lang.js";import{ConflictResolution,getVendorOptionValue,GraphicMargin,GraphicResize,Inclusion,SupportedVendorOptions}from"../model/VendorOption.js";import{Geometry}from"../model/Geometry.js";let filterDecoder;let seDecoderErrorHandler;const logger=new Log({avoidDuplicateMessages:true});export function decodeXML(e,r){if("object"!==typeof r)r={};const n=!!r.strict;seDecoderErrorHandler=new SEDecoderErrorHandler(r);filterDecoder=new FilterDecoder(r);const o=XML.xmlToJson(e);const a=undefined;if(o.searchNodes((function(e){return"parsererror"===e.$name})).length>0)seDecoderErrorHandler.warnAbout(" XML is not well-formed."+(n?"":" Proceeding anyway..."));if(!o||"FeatureTypeStyle"!==o.$name)seDecoderErrorHandler.fatalAbout("missing FeatureTypeStyle element.");return parseFeatureTypeStyleNode(o,r)}function parseFeatureTypeStyleNode(e,r){const n=new FeatureTypeStyle;parseNameAndDescription(n,e);seDecoderErrorHandler.warnIfInvalidElement(e,FeatureTypeStyle.VALID_CHILDREN,"FeatureTypeStyle");parseVendorOptions(e,n);if(!Array.isArray(e.Rules))seDecoderErrorHandler.fatalAbout("no Rule elements in FeatureTypeStyle element"+(n.name?" '"+n.name+"'.":"."));const o=e.Rules;for(let e=0;e<o.length;e++){const a=parseRuleNode(o[e],r);if(!a)return null;n.addRule(a)}return n}function parseRuleNode(e,r){const n=new Rule(r?.functionEvaluators);const o=parseNameAndDescription(n,e);seDecoderErrorHandler.warnIfInvalidElement(e,Rule.VALID_CHILDREN,"Rule "+o);if(e.MinScaleDenominators){seDecoderErrorHandler.warnIfMoreThanOne(e.MinScaleDenominators,"Rule "+o,"MinScaleDenominator");const r=e.MinScaleDenominators[0].$value;if("number"!==typeof r)seDecoderErrorHandler.fatalAbout("MinScaleDenominator in Rule "+o+"must contain a numerical value");else n.minScaleDenominator=r}if(e.MaxScaleDenominators){seDecoderErrorHandler.warnIfMoreThanOne(e.MaxScaleDenominators,"Rule "+o,"MaxScaleDenominator");const r=e.MaxScaleDenominators[0].$value;if("number"!==typeof r)seDecoderErrorHandler.fatalAbout("MaxScaleDenominator in Rule "+o+"must contain a numerical value");else n.maxScaleDenominator=r}parseVendorOptions(e,n);if(e.Filters&&e.ElseFilters)seDecoderErrorHandler.fatalAbout("Rule "+o+"can not have both a Filter and an ElseFilter Element");if(e.Filters){if(e.Filters.length>1)seDecoderErrorHandler.warnAbout((n.name?"Rule '"+n.name+"'":"a Rule ")+"should only have one Filter element, ignoring all but the first Filter element");n.filter=filterDecoder.decodeJsonNode(e.Filters[0])}if(e.ElseFilters)n.hasElseFilter=true;const a=e.$chil.filter(isSymbolizerNode);if(0===a.length)seDecoderErrorHandler.fatalAbout("no Symbolizers in Rule"+o);let t=null;for(let e=0;e<a.length;e++){const o=a[e];switch(o.$name){case"PointSymbolizer":t=parsePointSymbolizerNode(o,r);break;case"LineSymbolizer":t=parseLineSymbolizerNode(o,r);break;case"PolygonSymbolizer":t=parsePolygonSymbolizerNode(o,r);break;case"TextSymbolizer":t=parseTextSymbolizerNode(o,r);break;case"RasterSymbolizer":default:seDecoderErrorHandler.fatalAbout("Encountered a Symbolizer "+(n.name?"in Rule '"+n.name+"'":"in a Rule")+" that should not exist")}if(t)n.addSymbolizer(t)}return n}function parsePointSymbolizerNode(e,r){const n=new PointSymbolizer;const o=parseNameAndDescription(n,e);if(e.Geometrys){seDecoderErrorHandler.warnIfMoreThanOne(e.Geometrys,"PointSymbolizer","Geometry");const o=parseGeometryNode(e.Geometrys[0],r);n.geometry=o}seDecoderErrorHandler.warnIfInvalidElement(e,PointSymbolizer.VALID_CHILDREN,"PointSymbolizer "+o);parseUom(n,e.$attr.uom,o);if(e.Graphics)for(let o=0;o<e.Graphics.length;o++){const a=parseGraphicNode(e.Graphics[o],r);if(a)n.addGraphic(a)}parseVendorOptions(e,n);return n}function parseLineSymbolizerNode(e,r){const n=new LineSymbolizer;const o=parseNameAndDescription(n,e);if(e.Geometrys){seDecoderErrorHandler.warnIfMoreThanOne(e.Geometrys,"LineSymbolizer","Geometry");const o=parseGeometryNode(e.Geometrys[0],r);n.geometry=o}seDecoderErrorHandler.warnIfInvalidElement(e,LineSymbolizer.VALID_CHILDREN,"LineSymbolizer "+o);parseUom(n,e.$attr.uom,o);if(e.Strokes){seDecoderErrorHandler.warnIfMoreThanOne(e.Strokes,"LineSymbolizer","Stroke");n.stroke=parseStrokeNode(e.Strokes[0],r)}if(e.PerpendicularOffsets){seDecoderErrorHandler.warnIfMoreThanOne(e.PerpendicularOffsets,"LineSymbolizer","PerpendicularOffset");n.perpendicularOffset=parseParameterNode(e.PerpendicularOffsets[0],r)}parseVendorOptions(e,n);return n}function parsePolygonSymbolizerNode(e,r){const n=new PolygonSymbolizer;const o=parseNameAndDescription(n,e);if(e.Geometrys){seDecoderErrorHandler.warnIfMoreThanOne(e.Geometrys,"PolygonSymbolizer","Geometry");const o=parseGeometryNode(e.Geometrys[0],r);n.geometry=o}seDecoderErrorHandler.warnIfInvalidElement(e,PolygonSymbolizer.VALID_CHILDREN,"PolygonSymbolizer "+o);parseUom(n,e.$attr.uom,o);if(e.Strokes){seDecoderErrorHandler.warnIfMoreThanOne(e.Strokes,"PolygonSymbolizer","Stroke");n.stroke=parseStrokeNode(e.Strokes[0],r)}if(e.Fills){seDecoderErrorHandler.warnIfMoreThanOne(e.Fills,"PolygonSymbolizer","Fill");n.fill=parseFillNode(e.Fills[0],r)}if(e.PerpendicularOffsets){seDecoderErrorHandler.warnIfMoreThanOne(e.PerpendicularOffsets,"PolygonSymbolizer","PerpendicularOffset");n.perpendicularOffset=parseParameterNode(e.PerpendicularOffsets[0],r)}if(e.Displacements){seDecoderErrorHandler.warnIfMoreThanOne(e.Displacements,"PolygonSymbolizer","Displacement");n.displacement=parseDisplacementNode(e.Displacements[0],r)}parseVendorOptions(e,n);return n}function parseTextSymbolizerNode(e,r){const n=new TextSymbolizer;const o=parseNameAndDescription(n,e);if(e.Geometrys){seDecoderErrorHandler.warnIfMoreThanOne(e.Geometrys,"TextSymbolizer","Geometry");const o=parseGeometryNode(e.Geometrys[0],r);n.geometry=o}seDecoderErrorHandler.warnIfInvalidElement(e,TextSymbolizer.VALID_CHILDREN,"TextSymbolizer "+o);parseUom(n,e.$attr.uom,o);if(e.Labels){seDecoderErrorHandler.warnIfMoreThanOne(e.Labels,"TextSymbolizer","Label");n.label=parseLabelNode(e.Labels[0],r)}if(e.Fonts){seDecoderErrorHandler.warnIfMoreThanOne(e.Fonts,"TextSymbolizer","Font");n.font=parseFontNode(e.Fonts[0],r)}if(e.Fills){seDecoderErrorHandler.warnIfMoreThanOne(e.Fills,"TextSymbolizer","Fill");n.fill=parseFillNode(e.Fills[0],r)}if(e.LabelPlacements){seDecoderErrorHandler.warnIfMoreThanOne(e.LabelPlacements,"TextSymbolizer","LabelPlacement");n.labelPlacement=parsePlacementNode(e.LabelPlacements[0],r)}if(e.Halos){seDecoderErrorHandler.warnIfMoreThanOne(e.Halos,"TextSymbolizer","Halo");n.halo=parseHaloNode(e.Halos[0],r)}parseVendorOptions(e,n);if(e.Graphics){seDecoderErrorHandler.warnIfMoreThanOne(e.Graphics,"TextSymbolizer","Graphic");const o=parseGraphicNode(e.Graphics[0],r);if(0===o.marks.length||"square"!==o.marks[0].wellKnownName.content[0])seDecoderErrorHandler.warnAbout("Only 'square' mark graphics are supported to define labelBoxes for text.");else{const e=undefined;if("stretch"===getVendorOptionValue(n,SupportedVendorOptions.VENDOR_OPTION_GRAPHIC_RESIZE))n.graphic=o}}return n}function parseFontNode(e,r){const n=new Font;parseSvgParametersForNode(e,n,r);return n}function parsePointPlacement(e,r){const n=new PointPlacement;seDecoderErrorHandler.warnIfInvalidElement(e,PointPlacement.VALID_CHILDREN,"PointPlacement");if(e.Displacements){seDecoderErrorHandler.warnIfMoreThanOne(e.Displacements,"PointPlacement","Displacement");n.displacement=parseDisplacementNode(e.Displacements[0],r)}if(e.AnchorPoints){seDecoderErrorHandler.warnIfMoreThanOne(e.AnchorPoints,"PointPlacement","AnchorPoint");n.anchorPoint=parseAnchorPoint(e.AnchorPoints[0],r)}if(e.Rotations){seDecoderErrorHandler.warnIfMoreThanOne(e.Rotations,"PointPlacement","Rotation");n.rotation=parseParameterNode(e.Rotations[0],r)}return n}function parseLinePlacement(e,r){const n=new LinePlacement;seDecoderErrorHandler.warnIfInvalidElement(e,LinePlacement.VALID_CHILDREN,"LinePlacement");if(e.PerpendicularOffsets){seDecoderErrorHandler.warnIfMoreThanOne(e.PerpendicularOffsets,"LinePlacement","PerpendicularOffset");n.perpendicularOffset=parseParameterNode(e.PerpendicularOffsets[0],r)}if(e.InitialGaps){seDecoderErrorHandler.warnIfMoreThanOne(e.InitialGaps,"LinePlacement","InitialGap");n.initialGap=parseParameterNode(e.InitialGaps[0],r)}if(e.Gaps){seDecoderErrorHandler.warnIfMoreThanOne(e.Gaps,"LinePlacement","Gap");n.gap=parseParameterNode(e.Gaps[0],r)}if(e.IsRepeateds){seDecoderErrorHandler.warnIfMoreThanOne(e.IsRepeateds,"LinePlacement","IsRepeated");n.isRepeated=toBoolean(e.IsRepeateds[0].$value,false)}else n.isRepeated=false;if(e.GeneralizeLines){seDecoderErrorHandler.warnIfMoreThanOne(e.GeneralizeLines,"LinePlacement","GeneralizeLine");n.generalizeLine=e.GeneralizeLines[0].$value}if(e.IsAligneds){seDecoderErrorHandler.warnIfMoreThanOne(e.IsAligneds,"LinePlacement","IsAligned");n.isAligned=toBoolean(e.IsAligneds[0].$value,true)}else n.isAligned=true;return n}function parsePlacementNode(e,r){const n=new LabelPlacement;seDecoderErrorHandler.warnIfInvalidElement(e,LabelPlacement.VALID_CHILDREN,"LabelPlacement");if(!e.PointPlacements&&!e.LinePlacements)seDecoderErrorHandler.fatalAbout("a LabelPlacement element must have a PointPlacement or LinePlacement child.");if(e.PointPlacements&&e.LinePlacements)seDecoderErrorHandler.fatalAbout("a LabelPlacement element must not have both PointPlacement and LinePlacement children.");if(e.PointPlacements){seDecoderErrorHandler.warnIfMoreThanOne(e.PointPlacements,"LabelPlacement","PointPlacement");n.placement=parsePointPlacement(e.PointPlacements[0],r)}else if(e.LinePlacements){seDecoderErrorHandler.warnIfMoreThanOne(e.LinePlacements,"LabelPlacement","LinePlacement");n.placement=parseLinePlacement(e.LinePlacements[0],r)}return n}function parseHaloNode(e,r){const n=new Halo;seDecoderErrorHandler.warnIfInvalidElement(e,Halo.VALID_CHILDREN,"Halo");if(e.Radiuss){seDecoderErrorHandler.warnIfMoreThanOne(e.Radiuss,"Halo","Radius");n.radius=parseParameterNode(e.Radiuss[0],r)}if(e.Fills){seDecoderErrorHandler.warnIfMoreThanOne(e.Fills,"Halo","Fill");n.fill=parseFillNode(e.Fills[0],r)}return n}function parseAnchorPoint(e,r){const n=new AnchorPoint;seDecoderErrorHandler.warnIfInvalidElement(e,AnchorPoint.VALID_CHILDREN,"AnchorPoint");if(e.AnchorPointXs){seDecoderErrorHandler.warnIfMoreThanOne(e.AnchorPointXs,"AnchorPoint","AnchorPointX");const o=parseParameterNode(e.AnchorPointXs[0],r);n.x=parseAnchorPointValue(o,"AnchorPointX",r)}else seDecoderErrorHandler.fatalAbout("An AnchorPoint element must have an AnchorPointX child");if(e.AnchorPointYs){seDecoderErrorHandler.warnIfMoreThanOne(e.AnchorPointYs,"AnchorPoint","AnchorPointY");const o=parseParameterNode(e.AnchorPointYs[0],r);n.y=parseAnchorPointValue(o,"AnchorPointY",r)}else seDecoderErrorHandler.fatalAbout("An AnchorPoint element must have an AnchorPointY child");return n}function parseAnchorPointValue(e,r,n){let o=e;const a=e.content[0];if(isPrimitive(a)&&isString(a)){const e=parseFloat(a);if(e<0){const e=StyleUtil.getValueRangeWarningMessage(r,0,1,0);logger.warn(e);o=createParameterNode("0",n)}else if(e>1){const e=StyleUtil.getValueRangeWarningMessage(r,0,1,1);logger.warn(e);o=createParameterNode("1",n)}}return o}function parseGraphicFillNode(e,r){const n=new GraphicFill;seDecoderErrorHandler.warnIfInvalidElement(e,GraphicFill.VALID_CHILDREN,"GraphicFill");seDecoderErrorHandler.fatalIfMissing(e.Graphics,"GraphicFill","Graphic");seDecoderErrorHandler.warnIfMoreThanOne(e.Graphics,"GraphicFill","Graphic");for(let o=0;o<e.Graphics.length;o++)if(0===o)n.graphic=parseGraphicNode(e.Graphics[o],r);return n}function parseGraphicNode(e,r){const n=new Graphic;seDecoderErrorHandler.warnIfInvalidElement(e,Graphic.VALID_CHILDREN,"GraphicFill");if(e.ExternalGraphics){const o=e.ExternalGraphics;const a=o.length;for(let e=0;e<a;e++)n.addExternalGraphic(parseExternalGraphicNode(o[e],r))}if(e.Marks){const o=e.Marks;const a=o.length;for(let e=0;e<a;e++)n.addMark(parseMarkNode(o[e],r))}if(e.Sizes){seDecoderErrorHandler.warnIfMoreThanOne(e.Sizes,"Graphic","Size");n.size=parseParameterNode(e.Sizes[0],r)}if(e.Displacements){seDecoderErrorHandler.warnIfMoreThanOne(e.Displacements,"Graphic","Displacement");n.displacement=parseDisplacementNode(e.Displacements[0],r)}if(e.Rotations){seDecoderErrorHandler.warnIfMoreThanOne(e.Rotations,"Graphic","Rotation");n.rotation=parseParameterNode(e.Rotations[0],r)}if(e.AnchorPoints){seDecoderErrorHandler.warnIfMoreThanOne(e.AnchorPoints,"Graphic","AnchorPoint");n.anchorPoint=parseAnchorPoint(e.AnchorPoints[0],r)}if(e.Opacitys){seDecoderErrorHandler.warnIfMoreThanOne(e.Opacitys,"Graphic","Opacity");n.opacity=parseParameterNode(e.Opacitys[0],r)}return n}function parseMarkNode(e,r){const n=new Mark(r?.iconProvider);seDecoderErrorHandler.warnIfInvalidElement(e,Mark.VALID_CHILDREN,"Mark");let o=DEFAULT_WELL_KNOWN_NAME;if(e.WellKnownNames){seDecoderErrorHandler.warnIfMoreThanOne(e.WellKnownNames,"Mark","WellKnownName");o=parseWellKnownNameNode(e.WellKnownNames[0],r)}n.wellKnownName=o;if(e.Strokes){seDecoderErrorHandler.warnIfMoreThanOne(e.Strokes,"Mark for WellKnownName","Stroke");n.stroke=parseStrokeNode(e.Strokes[0],r)}if(e.Fills){seDecoderErrorHandler.warnIfMoreThanOne(e.Fills,"Mark for WellKnownName","Fill");n.fill=parseFillNode(e.Fills[0],r)}return n}function parseExternalGraphicNode(e,r){const n=new ExternalGraphic(r?.iconProvider);seDecoderErrorHandler.warnIfInvalidElement(e,ExternalGraphic.VALID_CHILDREN,"ExternalGraphic");seDecoderErrorHandler.fatalIfMissing(e.Formats,"ExternalGraphic","Format");seDecoderErrorHandler.warnIfMoreThanOne(e.Formats,"ExternalGraphic","Format");const o=e.Formats[0];if("[object String]"!==Object.prototype.toString.call(o.$text))seDecoderErrorHandler.fatalAbout("Encountered an ExternalGraphic Element with invalid Format");n.format=o.$text.trim();const a=n.supportedFormat;if(!a)seDecoderErrorHandler.fatalAbout("Encountered an ExternalGraphic node without a valid format, the format '"+n.format+"' is not supported");if(!e.OnlineResources&&!e.InlineContents)seDecoderErrorHandler.fatalAbout("ExternalGraphic node does not have an OnlineResource or InlineContent node");let t;let i;let l;if(e.OnlineResources){seDecoderErrorHandler.warnIfMoreThanOne(e.OnlineResources,"ExternalGraphics","OnlineResource");t=e.OnlineResources[0].$attr.href;if(!t)seDecoderErrorHandler.fatalAbout("Encountered an OnlineResource without href attribute")}if(!t&&e.InlineContents){seDecoderErrorHandler.warnIfMoreThanOne(e.InlineContents,"ExternalGraphics","InlineContent");const r=e.InlineContents[0];i=r.$attr.encoding;if(i&&r&&!n.isSupportedEncoding(i))if(!a)seDecoderErrorHandler.fatalAbout("Encountered an ExternalGraphic node without a valid encoding, the format was parsed to null");else seDecoderErrorHandler.fatalAbout("Encountered an ExternalGraphic node without a valid encoding, the format '"+a.mimeType+"' doesn't support '"+i+"' encodings");const o=a.encoders;for(let e=0;e<o.length;e++)if(o[e].canEncode(i)){o[e].validate(r,seDecoderErrorHandler);const n=o[e].encode(r);if(n){l=n.content[0];i=n.encoding;break}}}if(t)n.onlineResource=t;else if(i&&l){n.inlineContent=new InlineContent(i);n.inlineContent.content.push(l.trim())}else seDecoderErrorHandler.fatalAbout("Encountered an ExternalGraphic node without a valid OnlineResource or InlineContent node");return n}function parseDisplacementNode(e,r){seDecoderErrorHandler.warnIfInvalidElement(e,Displacement.VALID_CHILDREN,"Displacement");seDecoderErrorHandler.fatalIfMissing(e.DisplacementXs,"Displacement","DisplacementX");seDecoderErrorHandler.warnIfMoreThanOne(e.DisplacementXs,"Displacement","DisplacementX");seDecoderErrorHandler.fatalIfMissing(e.DisplacementYs,"Displacement","DisplacementY");seDecoderErrorHandler.warnIfMoreThanOne(e.DisplacementYs,"Displacement","DisplacementY");const n=new Displacement;n.x=parseParameterNode(e.DisplacementXs[0],r);n.y=parseParameterNode(e.DisplacementYs[0],r);return n}function parseStrokeNode(e,r){const n=new Stroke;seDecoderErrorHandler.warnIfInvalidElement(e,Stroke.VALID_CHILDREN,"Stroke");if(e.graphicFills&&e.GraphicStrokes)seDecoderErrorHandler.warnAbout("A LineSymbolizer cannot have both a graphicStroke and a graphicFill. The graphicStroke overrides the graphicFill.");if(e.GraphicFills){seDecoderErrorHandler.warnIfMoreThanOne(e.GraphicFills,"Fill","GraphicFill");n.graphicFill=parseGraphicFillNode(e.GraphicFills[0],r)}parseGraphicStroke(e.GraphicStrokes,n,r);parseSvgParametersForNode(e,n,r);return n}function parseFillNode(e,r){const n=new Fill;seDecoderErrorHandler.warnIfInvalidElement(e,Fill.VALID_CHILDREN,"Fill");if(e.GraphicFills){seDecoderErrorHandler.warnIfMoreThanOne(e.GraphicFills,"Fill","GraphicFill");n.graphicFill=parseGraphicFillNode(e.GraphicFills[0],r)}parseSvgParametersForNode(e,n,r);return n}function parseSvgParametersForNode(e,r,n){if(e.SvgParameters){const o=e.SvgParameters.length;for(let a=0;a<o;a++){const o=parseSvgParameterNode(e.SvgParameters[a],n);const t=o.name;if(null!=t)if(r.hasSVGParameter(t))r.addSVGParameter(o);else seDecoderErrorHandler.fatalAbout("SVGParameter name "+o.name+" is not supported")}}}function parseGraphicStroke(e,r,n){if(e){seDecoderErrorHandler.warnIfMoreThanOne(e,"Stroke","GraphicStroke");const o=e[0];seDecoderErrorHandler.warnIfInvalidElement(o,GraphicStroke.VALID_CHILDREN,"GraphicStroke");seDecoderErrorHandler.fatalIfMissing(o.Graphics,"GraphicStroke","Graphic");seDecoderErrorHandler.warnIfMoreThanOne(o.Graphics,"GraphicStroke","Graphic");const a=new GraphicStroke;for(let e=0;e<o.Graphics.length;e++)if(0===e)a.graphic=parseGraphicNode(o.Graphics[e],n);if(o.InitialGaps){seDecoderErrorHandler.warnIfMoreThanOne(o.InitialGaps,"LinePlacement.Stroke","InitialGap");a.initialGap=parseParameterNode(o.InitialGaps[0],n)}if(o.Gaps){seDecoderErrorHandler.warnIfMoreThanOne(o.Gaps,"LinePlacement.Stroke","Gaps");a.gap=parseParameterNode(o.Gaps[0],n)}r.graphicStroke=a}}function parseSvgParameterNode(e,r){if(!e.$attr.name)seDecoderErrorHandler.fatalAbout("Encountered an SVGParameter Element without name attribute");const n=new SVGParameter(e.$attr.name,r?.functionEvaluators);parseParameterContent(e,n);return n}function parseVendorOptions(e,r){if(e.VendorOptions)for(let n=0;n<e.VendorOptions.length;n++){const o=e.VendorOptions[n];if(!o.$attr.name)seDecoderErrorHandler.fatalAbout("Encountered a VendorOption Element without name attribute");if(-1===r.validVendorOptions.indexOf(o.$attr.name))seDecoderErrorHandler.warnAbout("Encountered a non-supported VendorOption "+o.name+"for this "+r.type);parseVendorOption(o,r)}}function parseVendorOption(e,r){switch(e.$attr.name){case SupportedVendorOptions.VENDOR_OPTION_CONFLICT_RESOLUTION:if(!isBoolean(e.$value))seDecoderErrorHandler.warnAbout("Encountered a VendorOption 'conflictResolution' value that is not supported: "+e.$text+" (expected a boolean)");else r.addVendorOption(new ConflictResolution(e.$value));break;case SupportedVendorOptions.VENDOR_OPTION_GRAPHIC_MARGIN:if(!isNumber(e.$value))seDecoderErrorHandler.warnAbout("Encountered a VendorOption 'graphic-margin' value that is not supported: "+e.$text+" (expected a number)");else r.addVendorOption(new GraphicMargin(e.$value));break;case SupportedVendorOptions.VENDOR_OPTION_GRAPHIC_RESIZE:if(-1===GraphicResize.VALID_VALUES.indexOf(e.$text.trim()))seDecoderErrorHandler.warnAbout("Encountered a VendorOption 'graphic-resize' value that is not supported: "+e.$text);else r.addVendorOption(new GraphicResize(e.$text.trim()));break;case SupportedVendorOptions.VENDOR_OPTION_INCLUSION:if(-1===Inclusion.VALID_VALUES.indexOf(e.$text.trim()))seDecoderErrorHandler.warnAbout("Encountered a VendorOption 'inclusion' value that is not supported: "+e.$text);else r.addVendorOption(new Inclusion(e.$text.trim()));break;default:seDecoderErrorHandler.warnAbout("Encountered a VendorOption Element that is not supported: "+e.$attr.name);break}}function createParameterNode(e,r){const n=new Parameter(SEElementType.PARAMETER,r?.functionEvaluators);n.addContent(e);return n}function parseLabelNode(e,r){const n=new Parameter(SEElementType.LABEL,r?.functionEvaluators);parseParameterContent(e,n);return n}function parseWellKnownNameNode(e,r){const n=new Parameter(SEElementType.WELLKNOWNNAME,r?.functionEvaluators);parseParameterContent(e,n);return n}function parseParameterNode(e,r){const n=new Parameter(SEElementType.PARAMETER,r?.functionEvaluators);parseParameterContent(e,n);return n}function parseParameterContent(e,r){const n=e.$chil.length;for(let o=0;o<n;o++){const n=e.$chil[o];if("#text"===n.$name){const e=n.$text.trim();if(""!==e)r.addContent(e)}else{preprocessspecialSEFunctionNode(n);const e=filterDecoder.decodeJsonNode(n);if(null!==e)r.addContent(e)}}}function preprocessspecialSEFunctionNode(e){const r=e.$name;if(SE_SPECIAL_FUNCTIONS.indexOf(r)>-1){e.$name="Function";e.$attr.name=SE_SPECIAL_FUNCTIONS_MAPPER.get(r);const n=SE_SPECIAL_FUNCTIONS_CHILDREN_MAPPER.get(r);if(n&&n.length>0)for(const r of e.$chil){const e=r.$name;if(n.indexOf(e)>-1)preprocessspecialSEFunctionNode(r)}}else if(SE_SPECIAL_PARAMETERS.indexOf(r)>-1)preprocessSESpecialParameterNode(e)}function preprocessSESpecialParameterNode(e){e.$name="Function";e.$attr.name="parameter";for(const r of e.$chil)if("#text"===r.$name){const n=r.$text.trim();if(""!==n){r.$name="Literal";e.$text=n}}}const SE_SPECIAL_FUNCTIONS=["FormatDate"];const SE_SPECIAL_PARAMETERS=["Pattern","DateValue"];const SE_SPECIAL_FUNCTIONS_MAPPER=createSEFunctionMapper();const SE_SPECIAL_FUNCTIONS_CHILDREN_MAPPER=createSEFunctionChildrenMapper();function createSEFunctionMapper(){const e=new Map;e.set("FormatDate","dateFormat");return e}function createSEFunctionChildrenMapper(){const e=new Map;e.set("FormatDate",["DateValue","Pattern"]);return e}function parseGeometryNode(e,r){const n=new Geometry(r?.functionEvaluators);parseGeometryContent(e,n);return n}function parseGeometryContent(e,r){const n=e.$chil.length;for(let o=0;o<n;o++){const n=e.$chil[o];if("#text"===n.$name){const e=undefined;if(""!==n.$text.trim())seDecoderErrorHandler.warnAbout("A Geometry node should only contain expressions")}else{const e=filterDecoder.decodeJsonNode(n);if(null!==e)r.content=e}}}function isSymbolizerNode(e){return"PointSymbolizer"===e.$name||"LineSymbolizer"===e.$name||"PolygonSymbolizer"===e.$name||"TextSymbolizer"===e.$name||"RasterSymbolizer"===e.$name}function parseNameAndDescription(e,r){if(r.Names)e.name=r.Names[0].$value;const n=e.name?" ("+e.name+") ":" ";seDecoderErrorHandler.warnIfMoreThanOne(r.Names,n,"Name");if(r.Descriptions){seDecoderErrorHandler.warnIfMoreThanOne(r.Descriptions,n,"Description");const o=r.Descriptions[0];const a=new Description;e.description=a;if(o.Titles){if(o.Titles.length>1)seDecoderErrorHandler.warnAbout("Encountered an element"+n+"with multiple Title children in its Description");a.title=o.Titles[0].$text}if(o.Abstracts){if(o.Abstracts.length>1)seDecoderErrorHandler.warnAbout("Encountered an element"+n+"with multiple Abstract children in its Description");a.abstract=o.Abstracts[0].$text}}return e.name?"'"+e.name+"'":"Node"}function parseUom(e,r,n){try{const n=getUom(r);if(n)e.uomString=n}catch(e){const r=e instanceof Error?e.name:void 0;seDecoderErrorHandler.warnAbout("unrecognized uom for "+n+(r||e))}}