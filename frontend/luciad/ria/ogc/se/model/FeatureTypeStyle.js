import{SEElementType}from"./SEElementType.js";import{SENamedElement}from"./SENamedElement.js";import{EventedSupport}from"../../../util/EventedSupport.js";import{PointSymbolizer}from"./symbolizer/PointSymbolizer.js";import{PolygonSymbolizer}from"./symbolizer/PolygonSymbolizer.js";import{LineSymbolizer}from"./symbolizer/LineSymbolizer.js";import{TextSymbolizer}from"./symbolizer/TextSymbolizer.js";import{addEventSupportToParameterOfLineSymbolizer,addEventSupportToParameterOfPointSymbolizer,addEventSupportToParameterOfPolygonSymbolizer,addEventSupportToParameterOfTextSymbolizer}from"./AddRuleHelper.js";import{SupportedVendorOptions}from"./VendorOption.js";export class FeatureTypeStyle extends SENamedElement{static VALID_CHILDREN=(new Array).concat(SENamedElement.VALID_CHILDREN,["FeatureTypeName","SemanticTypeIdentifier","Rule","OnlineResource","VendorOption"]);static VALID_VENDOR_OPTIONS=[SupportedVendorOptions.VENDOR_OPTION_INCLUSION];_scaleBoundaries=null;_detailLevelScales=null;_applicableRulesPerLevel=null;constructor(){super(SEElementType.FEATURE_TYPE_STYLE);this._rules=[];super.eventedSupport=new EventedSupport(["StyleChanged","ScaleChanged"],true);const e=this.on("ScaleChanged",(e=>{console.log("change happened: "+e);this.emptyScaleBounderies();const t=this.detailLevelScales}))}isReady(){const e=new Array(this._rules.length);for(let t=0;t<this._rules.length;t++)e[t]=this._rules[t].isReady();return Promise.all(e).then((()=>{}))}get validVendorOptions(){return FeatureTypeStyle.VALID_VENDOR_OPTIONS}addRule(e){e.eventedSupport=this.eventedSupport;for(let t of e.symbolizers){t.eventedSupport=this.eventedSupport;let e;switch(t.type){case SEElementType.POLYGON_SYMBOLIZER:e=PolygonSymbolizer.VALID_CHILDREN;for(let l of e)addEventSupportToParameterOfPolygonSymbolizer(l,t,this.eventedSupport);break;case SEElementType.LINE_SYMBOLIZER:e=LineSymbolizer.VALID_CHILDREN;for(let l of e)addEventSupportToParameterOfLineSymbolizer(l,t,this.eventedSupport);break;case SEElementType.TEXT_SYMBOLIZER:e=TextSymbolizer.VALID_CHILDREN;for(let l of e)addEventSupportToParameterOfTextSymbolizer(l,t,this.eventedSupport);break;case SEElementType.POINT_SYMBOLIZER:e=PointSymbolizer.VALID_CHILDREN;for(let l of e)addEventSupportToParameterOfPointSymbolizer(l,t,this.eventedSupport);break;default:break}}this._rules.push(e)}removeRule(e){const t=this._rules.indexOf(e);if(t>=0){this._rules.splice(t,1);this._applicableRulesPerLevel?.forEach(((t,l)=>{const r=t.indexOf(e);if(r>=0)t.splice(r,1)}))}this.eventedSupport?.emit("ScaleChanged","RemoveRule scale");this.eventedSupport?.emit("StyleChanged","RemoveRule")}get rules(){return this._rules}get scaleBoundaries(){if(!this._scaleBoundaries)this._scaleBoundaries=this.calculateScaleBoundaries();return this._scaleBoundaries}get detailLevelScales(){if(!this._detailLevelScales){this._scaleBoundaries=this.scaleBoundaries;this._detailLevelScales=this._scaleBoundaries.map(reciprocal)}return this._detailLevelScales}get applicableRulesPerLevel(){if(!this._applicableRulesPerLevel)this._applicableRulesPerLevel=this.fillMapOfRulesPerLevel();return this._applicableRulesPerLevel}emptyScaleBounderies(){this._scaleBoundaries=null;this._detailLevelScales=null}calculateScaleBoundaries(){const e=[];for(let t=0;t<this.rules.length;t++){const l=this.rules[t];if(l.minScaleDenominator&&e.indexOf(l.minScaleDenominator)<0)e.push(l.minScaleDenominator);if(l.maxScaleDenominator&&e.indexOf(l.maxScaleDenominator)<0)e.push(l.maxScaleDenominator)}e.sort(sortDescending);return e}fillMapOfRulesPerLevel(){const e=new Map;const t=this.scaleBoundaries.length;if(t>0){for(let l=0;l<=t;l++)e.set(l,[]);const l=this._rules.length;for(let t=0;t<l;t++){const l=this._rules[t].calculateApplicableScaleLevels(this.scaleBoundaries);const r=l.length;for(let o=0;o<r;o++)e.get(l[o])?.push(this._rules[t])}}return e}getRulesToPaint(e){const t=undefined;let l;if(this.scaleBoundaries.length>0){const t=this.applicableRulesPerLevel.get(e);l=t?t:[]}else l=this._rules;return l}getRuleZOrder(e,t){let l=0;const r=this._rules.indexOf(e);const o=this._rules[r].symbolizers.indexOf(t);for(let e=0;e<r;e++)l+=3*this._rules[e].symbolizers.length;l+=3*o;return l}on(e,t,l){return this.eventedSupport.on(e,t,l)}}function sortDescending(e,t){return t-e}function reciprocal(e){return 1/e}