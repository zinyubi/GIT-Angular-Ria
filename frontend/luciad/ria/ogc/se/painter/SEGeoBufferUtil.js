import{createGeoBuffer,createPolyline,createShapeList}from"../../../shape/ShapeFactory.js";import{isShapeList}from"../../../shape/ShapeList.js";import{isComplexPolygon}from"../../../shape/ComplexPolygon.js";import{ProgrammingError}from"../../../error/ProgrammingError.js";import{isPolyline}from"../../../shape/Polyline.js";import{isPolygon}from"../../../shape/Polygon.js";import{CompositeConstructiveGeometryOperator}from"../../../geometry/constructivegeometry/CompositeConstructiveGeometryOperator.js";import{TopologyUtilEllipsoidal}from"../../../geometry/topologyutil/TopologyUtilEllipsoidal.js";import{ConstructiveGeometry}from"../../../geometry/ConstructiveGeometry.js";import{TopologyUtilCartesian}from"../../../geometry/topologyutil/TopologyUtilCartesian.js";import{ShapeUtil}from"../../../shape/ShapeUtil.js";export function addBufferInvalidationListenerForPerpendicularOffset(e,o,r,t,n,i){if(!o.isWorldSized()){const f=r.on("idle",(()=>{const s=undefined;if(o.getPerpendicularOffset(e,n,r.worldSizeSupport)!==i){t.invalidate(e);f.remove()}}))}}export function addBufferInvalidationListenerForStrokeGraphicFill(e,o,r,t,n,i){if(!o.isWorldSized()){const f=r.on("idle",(()=>{const s=undefined;if(o.getBufferWidth(e,n,r.worldSizeSupport)!==i){t.invalidate(e);f.remove()}}))}}function convertBufferToContourShape(e,o=false){if(o)return e.getContour();else return e.getContourShapeList()}export function polyLine2BufferContour(e,o,r=false){if(isShapeList(e)){const r=[];for(let t=0;t<e.shapeCount;t++)r.push(polyLine2BufferContour(e.getShape(t),o));return createShapeList(e.reference,r)}else if(isPolyline(e)){const t=undefined;return convertBufferToContourShape(createGeoBuffer(e.reference,e,o),r)}else throw new ProgrammingError("No valid polyline buffer contour can be created.")}export function polygon2BufferContour(e,o,r=false){if(isShapeList(e)){const r=[];for(let t=0;t<e.shapeCount;t++)r.push(polygon2BufferContour(e.getShape(t),o));return createShapeList(e.reference,r)}else if(isComplexPolygon(e)){const r=[];for(let t=0;t<e.polygonCount;t++)r.push(polygon2BufferContour(e.getPolygon(t),o));return createShapeList(e.reference,r)}else if(isPolygon(e)){const t=e.coordinates[0];const n=createPolyline(e.reference,t);n.insertPoint(e.pointCount,e.getPoint(0));return polyLine2BufferContour(n,o,r)}else throw new ProgrammingError("No valid polygon buffer contour can be created.")}export function polygon2OuterBufferContour(e,o){if(isShapeList(e)){const r=[];for(let t=0;t<e.shapeCount;t++)r.push(polygon2OuterBufferContour(e.getShape(t),o));return createShapeList(e.reference,r)}else if(isComplexPolygon(e))return polygon2OuterBufferContour(e.getPolygon(0),o);else if(isPolygon(e)){const r=undefined;return convertBufferToContourShape(createGeoBuffer(e.reference,e,o),true)}else throw new ProgrammingError("No valid outer buffer contour can be created.")}export function polygon2InnerBufferContour(e,o,r){if(isShapeList(e)){const r=[];for(let t=0;t<e.shapeCount;t++)r.push(polygon2InnerBufferContour(e.getShape(t),o));return createShapeList(e.reference,r)}else if(isComplexPolygon(e)){r=r??createConstructiveGeometry(e.reference);const t=undefined;const n=polygon2InnerBufferContour(e.getPolygon(0),o,r);const i=[];i.push(n);for(let r=1;r<e.polygonCount;r++){const t=e.getPolygon(r);i.push(polygon2OuterBufferContour(t,o))}return r.difference(i)}else if(isPolygon(e))return(r=r??createConstructiveGeometry(e.reference)).difference([e,polygon2BufferContour(e,o,true)]);else throw new ProgrammingError("No valid inner bufferContour can be created.")}function createConstructiveGeometry(e){if(ShapeUtil.isGeodeticReference(e))return new ConstructiveGeometry(new CompositeConstructiveGeometryOperator(new TopologyUtilEllipsoidal(.01,e.geodeticDatum.ellipsoid)));else return new ConstructiveGeometry(new CompositeConstructiveGeometryOperator(new TopologyUtilCartesian(1e-4)))}