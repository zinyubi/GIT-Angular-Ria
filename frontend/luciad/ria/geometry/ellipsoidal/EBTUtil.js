import{Constants}from"../../util/Constants.js";import{LLHPoint}from"../../shape/LLHPoint.js";import{ellipticalDistance2D}from"../../util/Cartesian.js";function isEqual(t,e,s,i){const o=5e-7;if(Math.abs(i-e)>o)return false;const n=Math.abs(s-t);return n<=o||Math.abs(360-n)<=o}export const EBTUtil={circleContains2D:(t,e,s)=>e>=s.reference.geodeticDatum.ellipsoid.geodesicDistance(t,s),addResultSFCT(t,e){const s=t.x;const i=t.y;for(let t=0;t<e.length;t++)if(isEqual(s,i,e[t].x,e[t].y))return;const o=new LLHPoint(t.reference);o.move2D(s,i);e[e.length]=o},closestPointToEllipse(t,e,s,i,o,n,a,l,c){const r=t.reference.geodeticDatum.ellipsoid;const f=r.forwardAzimuth2D(t,e);const D=r.geodesicDistance(t,e);let h=Math.max(l,a*D);if(0===h){h=r.a/Constants.EARTH_RADIUS;if(h<=1.1&&h>=.9)h=1}if(D<=h){c.move2D(t);return r.geodesicDistance(s,t)}const u=h/D;let d=0;let M=1;const m=(3-Math.sqrt(5))/2;const g=2*Math.ceil(Math.abs(Math.log(u)/Math.log(m)))+1;let b=m;r.geodesicPositionSFCT(t,b*D,f,c);let p=r.forwardAzimuth2D(s,c)*Constants.RAD2DEG;let C=r.geodesicDistance(s,c)/ellipticalDistance2D(i,o,90-p-n);let A=b;let E=b;let L=C;let P=C;for(let e=0;e<g;e++){const e=M-d;const a=(d+M)/2;const l=1e-12*Math.abs(A)+u/3;if(Math.abs(A-a)+e/2<=2*l)return L;let h=m*(Math.abs(A)<a?M-A:d-A);if(Math.abs(A-E)>=l){const t=(A-E)*(L-C);let e=(A-b)*(L-P);let s=(A-b)*e-(A-E)*t;e=2*(e-t);if(e>0)s=-s;else e=-e;if(Math.abs(s)<Math.abs(h*e)&&s>e*(d-A+2*l)&&s<e*(M-A-2*l))h=s/e}if(Math.abs(h)<l)if(h>0)h=l;else h=-l;const g=A+h;r.geodesicPositionSFCT(t,g*D,f,c);p=r.forwardAzimuth2D(s,c)*Constants.RAD2DEG;const T=r.geodesicDistance(s,c)/ellipticalDistance2D(i,o,90-p-n);if(T<=L){if(g<A)M=A;else d=A;b=E;E=A;A=g;C=P;P=L;L=T}else{if(g<A)d=g;else M=g;if(T<=P||E===A){b=E;E=g;C=P;P=T}else if(T<=P||b===A||b===E){b=g;C=T}}}return L}};