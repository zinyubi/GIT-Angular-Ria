import{polygonContains2D}from"../../geodesy/EllipsoidPolygonUtil.js";import{closestPointOnGeodesic as closestPointOnGeodesicSphere}from"../../geodesy/SphereUtil.js";import{calculate2DBoundsPoints}from"../../shape/GeodesicBoundsUtil.js";import{LLHBounds}from"../../shape/LLHBounds.js";import{LLHPolygon}from"../../shape/LLHPolygon.js";import{LLHPolyline}from"../../shape/LLHPolyline.js";import{Ellipsoid}from"../../geodesy/Ellipsoid.js";import{closestPointOnGeodesic,intersection2DLineSegments}from"../../geodesy/EllipsoidUtil.js";import{LLHPoint}from"../../shape/LLHPoint.js";import{EllipsoidalAdvancedBinaryTopologyUtil}from"./EllipsoidalAdvancedBinaryTopologyUtil.js";import{TopologyUtil}from"./TopologyUtil.js";import{isPolygon}from"../../shape/Polygon.js";import{simplePointCopy}from"../../shape/SimplePoint.js";const EPSILON=1e-12;const sphericalEllipsoid=Ellipsoid.fromAB({a:1,b:1});export class TopologyUtilEllipsoidal extends TopologyUtil{constructor(e,t){super(e);this._ellipsoid=t;this._advancedBinaryTopologyUtil=new EllipsoidalAdvancedBinaryTopologyUtil(t);this._tempPointArray=[new LLHPoint,new LLHPoint]}get advancedBinaryTopologyUtil(){return this._advancedBinaryTopologyUtil}growBounds(e,t){const n=new LLHPoint(t.reference,[t.x,t.y]);n.translate(-getToleranceLongitude(e,this._ellipsoid.auxRadius,n.y),-getToleranceLatitude(e,this._ellipsoid.auxRadius));const o=new LLHPoint(t.reference,[t.x,t.y]);o.translate(t.width,t.height);o.translate(getToleranceLongitude(e,this._ellipsoid.auxRadius,o.y),getToleranceLatitude(e,this._ellipsoid.auxRadius));t.setToIncludePoint2D(n);t.setToIncludePoint2D(o)}pointsEqual(e,t){return pointsEqualSpherical(e.x,e.y,t.x,t.y,this.toleranceEqualPoints,this._ellipsoid.auxRadius)}boundsDontIntersectSegment(e,t,n){if(null!==t&&e.contains2DPoint(t))return false;if(null!==n&&e.contains2DPoint(n))return false;const o=e.copy();if(this.toleranceEqualPoints>0)this.growBounds(this.toleranceEqualPoints,o);if(null===n)return!o.contains2DPoint(t);const i=new LLHBounds(t.reference);calculate2DBoundsPoints(t,n,this._ellipsoid,i);return!o.interacts2D(i)}distancePointPoint(e,t){return this._ellipsoid.geodesicDistance(e,t)}certainlyNoInteraction3Points(e,t,n){const o=e.reference;const i=getToleranceLongitude(this.toleranceEqualPoints,this._ellipsoid.auxRadius,Math.max(Math.abs(n.y),Math.max(Math.abs(e.y),Math.abs(t.y))));const s=undefined;if(!isAngleBetween(e.x,t.x,n.x,i))return true;const l=new LLHBounds(e.reference);calculate2DBoundsPoints(new LLHPoint(o,[e.x,e.y]),new LLHPoint(o,[t.x,t.y]),this._ellipsoid,l);if(this.toleranceEqualPoints>0)this.growBounds(this.toleranceEqualPoints,l);return!l.contains2DCoordinates(n.x,n.y)}certainlyNoInteraction4Points(e,t,n,o){const i=e.reference;const s=Math.max(Math.max(Math.abs(e.y),Math.abs(t.y)),Math.max(Math.abs(n.y),Math.abs(o.y)));const l=getToleranceLongitude(this.toleranceEqualPoints,this._ellipsoid.auxRadius,s);const r=isAngleBetween(n.x,o.x,e.x,l);const a=isAngleBetween(n.x,o.x,t.x,l);const c=isAngleBetween(e.x,t.x,n.x,l);if(!r&&!a&&!c)return true;const u=new LLHBounds(e.reference);const d=new LLHBounds(e.reference);calculate2DBoundsPoints(new LLHPoint(i,[e.x,e.y]),new LLHPoint(i,[t.x,t.y]),this._ellipsoid,u);calculate2DBoundsPoints(new LLHPoint(i,[n.x,n.y]),new LLHPoint(i,[o.x,o.y]),this._ellipsoid,d);if(this.toleranceEqualPoints>0)this.growBounds(this.toleranceEqualPoints,u);return!u.interacts2D(d)}isPointOnLineSegment(e,t,n){const o=simplePointCopy(n);return this.closestPointOnLineSegment(e,t,n,o)<this.toleranceEqualPoints}closestPointOnLineSegment(e,t,n,o){if(this._ellipsoid.isSphere()){closestPointOnGeodesicSphere(e,t,n,true,o);return this.distancePointPoint(o,n)}else return closestPointOnGeodesic(e,t,n,this._ellipsoid,0,this.toleranceEqualPoints/4,o)}getAveragePoint(e,t){const n=e.copy();this._ellipsoid.geodesicPositionAtFractionSFCT(e,t,.5,n);return n}getAngle(e,t){const n=sphericalEllipsoid.forwardAzimuth2D(e,t);let o=Math.PI/2-n;if(o<-Math.PI)o+=2*Math.PI;else if(o>Math.PI)o-=2*Math.PI;return o}lineSegmentIntersection(e,t,n,o,i){let s=intersection2DLineSegments(e,t,n,o,this._ellipsoid,this.toleranceEqualPoints/4,this._tempPointArray[0],this._tempPointArray[1]);if(-1===s)s=2;for(let t=0;t<s;t++)i[t]=new LLHPoint(e.reference,[this._tempPointArray[t].x,this._tempPointArray[t].y]);return s}getNewEditablePolyline(e,t=[]){return new LLHPolyline(e,t)}getNewEditablePolygon(e,t){return new LLHPolygon(e,t)}getNewEditableBoundsFromPoint(e){return new LLHBounds(e.reference,[e.x,0,e.y,0])}getNewEditableBoundsFromBounds(e){return new LLHBounds(e.reference,[e.x,e.width,e.y,e.height])}getNewEditableBoundsFromCoordinates(e,t,n,o,i){return new LLHBounds(e,[t,o,n,i])}contains2D(e,t){if(isPolygon(e))if(!this._ellipsoid.isSphere())return polygonContains2D(this._ellipsoid,e,t);return e.contains2DPoint(t)}}function pointsEqualSpherical(e,t,n,o,i,s){const l=Math.abs(t-o);let r=Math.abs(e-n);if(r>180)r=360-r;return(l<=EPSILON||l<=getToleranceLatitude(i,s))&&(r<=EPSILON||r<=getToleranceLongitude(i,s,t))}function getToleranceLatitude(e,t){return e/(Math.PI*t/2)*90}function getToleranceLongitude(e,t,n){const o=t*(1-Math.abs(n)/90);const i=0===o?360:e/(Math.PI*o/2)*90;return i>360?360:i}function isAngleBetween(e,t,n,o){const i=Math.min(e,t);const s=Math.max(e,t);if(s-i<180)return n>=i-o&&n<s+o;else return n>s-o||n<i+o}