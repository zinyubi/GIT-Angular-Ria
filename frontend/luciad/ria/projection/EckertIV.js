import{OutOfBoundsError}from"../error/OutOfBoundsError.js";import{Constants}from"../util/Constants.js";import{Hash}from"../util/Hash.js";import{normalizeLon}from"../util/LonLatCoord.js";import{Cylindrical}from"./Cylindrical.js";import{ProjectionType}from"./ProjectionType.js";const sharedOutOfBoundsError=new OutOfBoundsError("EckertIV");export class EckertIV extends Cylindrical{constructor(t=0){super();this.setCentralMeridian(t);this._X=2/Math.sqrt(Math.PI*(4+Math.PI));this._Y=2*Math.sqrt(Math.PI/(4+Math.PI));this._extremumX=this._X*Math.PI*2;this._extremumY=this._Y;this._hash=0;this.calculateCachedValues()}isAllInBounds(){return false}geodetic2cartesianOnSphereSFCT(t,e,s){const n=normalizeLon(t.x-this.getCentralMeridian())*Constants.DEG2RAD;const r=this.calculateTheta(t.y*Constants.DEG2RAD);s.x=this._X*e*n*(1+Math.cos(r));s.y=this._Y*e*Math.sin(r)}calculateTheta(t){const e=(2+Math.PI/2)*Math.sin(t);let s=t/2;const n=1e-10;let r=Number.MAX_VALUE;const a=30;let o=0;while(Math.abs(r)>n&&o<a){const t=Math.sin(s);const n=Math.cos(s);r=-(s+t*n+2*t-e)/(2*n*(1+n));s+=r;o++}return s}cartesian2geodeticOnSphereSFCT(t,e,s){const n=t.x/e;const r=t.y/e;const a=Math.abs(n);if(a>this._extremumX+1e-15||Math.abs(r)>this._extremumY+1e-15)throw sharedOutOfBoundsError;let o=r/this._Y;o=Math.max(o,-1);o=Math.min(o,1);const i=Math.asin(o);const h=Math.cos(i);const c=this._X*(1+h);const u=undefined;if(a>c*Math.PI+1e-7)throw sharedOutOfBoundsError;s.x=this.getCentralMeridian()+n/c*Constants.RAD2DEG;s.y=Math.asin((i+o*(h+2))/(2+Math.PI/2))*Constants.RAD2DEG}inLonLatBounds(t){return true}boundaryLons(t){return[[normalizeLon(-180+this.getCentralMeridian()+this.EPSILON),normalizeLon(180+this.getCentralMeridian()-this.EPSILON)]]}boundaryLats(t){return[[-90,90]]}inWorldBoundsOnSphere(t,e){const s=t.x/e;const n=t.y/e;const r=Math.abs(s);if(r>this._extremumX||Math.abs(n)>this._extremumY)return false;let a=n/this._Y;a=Math.max(a,-1);a=Math.min(a,1);const o=Math.asin(a);const i=Math.cos(o);const h=undefined;const c=undefined;return r<=this._X*(1+i)*Math.PI+1e-7}cartesianBoundsOnSphereSFCT(t,e){const s=(this._extremumX+1e-15)*t;const n=(this._extremumY+1e-15)*t;e.setTo2D(-s,2*s,-n,2*n)}encode(){return{type:"EckertIV",centralMeridian:this.getCentralMeridian()}}get TYPE(){return ProjectionType.ECKERT_IV+ProjectionType.CYLINDRICAL}calculateCachedValues(){const t=new Hash;this._hash=t.appendDouble(this.getCentralMeridian()).appendUInt32(this.TYPE).getHashCode()}hashCode(t){t.appendUInt32(this._hash)}}