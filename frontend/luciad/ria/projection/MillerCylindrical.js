import{Constants}from"../util/Constants.js";import{Hash}from"../util/Hash.js";import{normalizeLon}from"../util/LonLatCoord.js";import{OutOfBoundsError}from"../error/OutOfBoundsError.js";import{ProjectionType}from"./ProjectionType.js";import{Cylindrical}from"./Cylindrical.js";const sharedOutOfBoundsError=new OutOfBoundsError("MillerCylindrical");export class MillerCylindrical extends Cylindrical{constructor(t=0){super();this._hash=0;this.setCentralMeridian(t);this._extremumX=Math.PI;this._extremumY=transformLatitude2Y(Math.PI/2,1);this.calculateCachedValues()}isAllInBounds(){return false}geodetic2cartesianOnSphereSFCT(t,e,r){const n=normalizeLon(t.x-this.getCentralMeridian());r.x=e*n*Constants.DEG2RAD;r.y=transformLatitude2Y(t.y*Constants.DEG2RAD,e)}cartesian2geodeticOnSphereSFCT(t,e,r){if(this.inWorldBoundsOnSphere(t,e)){r.x=this.getCentralMeridian()+t.x/e*Constants.RAD2DEG;r.y=(2.5*Math.atan(Math.exp(.8*t.y/e))-5*Math.PI/8)*Constants.RAD2DEG}else throw sharedOutOfBoundsError}inLonLatBounds(t){return true}boundaryLons(t){return[[normalizeLon(-180+this.getCentralMeridian()+this.EPSILON),normalizeLon(180+this.getCentralMeridian()-this.EPSILON)]]}boundaryLats(t){return[[-90,90]]}inWorldBoundsOnSphere(t,e){const r=t.x/e;const n=t.y/e;return r>=-this._extremumX&&r<=this._extremumX&&n>=-this._extremumY&&n<=this._extremumY}cartesianBoundsOnSphereSFCT(t,e){const r=this._extremumX*t;const n=this._extremumY*t;e.setTo2D(-r,2*r,-n,2*n)}encode(){return{type:"MillerCylindrical",centralMeridian:this.getCentralMeridian()}}get TYPE(){return ProjectionType.MILLER_CYLINDRICAL+ProjectionType.CYLINDRICAL}calculateCachedValues(){const t=new Hash;this._hash=t.appendDouble(this.getCentralMeridian()).appendUInt32(this.TYPE).getHashCode()}hashCode(t){t.appendUInt32(this._hash)}}function transformLatitude2Y(t,e){const r=Math.sin(.8*t);return e/1.6*Math.log((1+r)/(1-r))}