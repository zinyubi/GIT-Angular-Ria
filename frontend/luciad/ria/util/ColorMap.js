import{createPhotonColorFromString,INVISIBLE}from"./Color.js";export class ColorMap{constructor(o,r,t){this._levels=o;this._colors=r;this._colorStrings=t}retrieveColor(o){if(o<this._levels[0])return this._colorStrings[0];const r=(o,r,t)=>(1-t)*o+t*r;for(let t=1;t<this._levels.length;t++)if(o<this._levels[t]){const e=this._colors[t];const s=this._colors[t-1];let l;if(this.isGradient()){const n=(this._levels[t]-o)/(this._levels[t]-this._levels[t-1]);l={r:r(e.r,s.r,n),g:r(e.g,s.g,n),b:r(e.b,s.b,n),a:r(e.a,s.a,n)}}else l=s;return this.toString(l)}return this._colorStrings[this._colorStrings.length-1]}isGradient(){return this._levels.length===this._colors.length}toString(o){return"rgba("+Math.round(255*o.r)+","+Math.round(255*o.g)+","+Math.round(255*o.b)+","+o.a+")"}toPhotonBuffers(o){o.assertReady();const r=this._levels;const t=o.BufferFactory.createFloat32BufferFromLength(r.length);for(let o=0;o<r.length;o++)t.typedArray[o]=r[o];const e=this._colors;let s=0;const l=o.BufferFactory.createFloat32BufferFromLength(4*e.length);for(const o of e){l.typedArray[s++]=o.r;l.typedArray[s++]=o.g;l.typedArray[s++]=o.b;l.typedArray[s++]=o.a}return{levels:t,colors:l,release:function(){this.levels.release();this.colors.release();this.levels=null;this.colors=null}}}}function createGradientColorMap(o){const r=[];const t=[];const e=[];for(const s of o){const o=createPhotonColorFromString(s.color||INVISIBLE);if(null===o)throw new Error(`Could not parse color "${s.color}" from color map.`);r.push(s.level);t.push(o);e.push(s.color||INVISIBLE)}return new ColorMap(r,t,e)}function createPiecewiseConstantColorMap(o){const r=[];const t=[];const e=[];for(let s=0;s<o.length;s+=2){if(s<o.length-1){const r=o[s+1];const l=createPhotonColorFromString(r);if(null===l)throw new Error(`Could not parse color "${r}" from color map.`);t.push(l);e.push(o[s+1])}r.push(o[s])}return new ColorMap(r,t,e)}export{createGradientColorMap,createPiecewiseConstantColorMap};