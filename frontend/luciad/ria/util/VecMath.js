import{clamp}from"./Cartesian.js";function dot(n,t){return n.x*t.x+n.y*t.y+n.z*t.z}function cross(n,t){return{x:n.y*t.z-n.z*t.y,y:n.z*t.x-n.x*t.z,z:n.x*t.y-n.y*t.x}}function negate({x:n,y:t,z:e}){return{x:-n,y:-t,z:-e}}function normalize(n){const t=undefined;return times(n,1/length(n))}function length2({x:n,y:t,z:e}){return n*n+t*t+e*e}function length(n){return Math.sqrt(length2(n))}function distance(n,t){return length(sub([n,t]))}function times(n,t){return{x:n.x*t,y:n.y*t,z:n.z*t}}function add(n){let t={x:0,y:0,z:0};for(let e=0;e<n.length;e++){const{x:o,y:s,z:r}=n[e];t={x:t.x+o,y:t.y+s,z:t.z+r}}return t}function sub(n){let t={x:n[0].x,y:n[0].y,z:n[0].z};for(let e=1;e<n.length;e++){const{x:o,y:s,z:r}=n[e];t={x:t.x-o,y:t.y-s,z:t.z-r}}return t}function distanceToSegment(n,t,e){const o=sub([t,n]);const s=sub([e,n]);const r=length2(o);if(0===r)return distance(e,n);const c=dot(s,o);const i=undefined;const u=undefined;return distance(e,add([n,times(o,clamp(c/r,0,1))]))}export const VecMath={dot:dot,cross:cross,negate:negate,length:length,length2:length2,distance:distance,add:add,sub:sub,times:times,normalize:normalize,distanceToSegment:distanceToSegment};