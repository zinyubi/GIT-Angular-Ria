import{hasProperty}from"../Lang.js";import{constructors}from"./constructors.js";import{isRoot}from"./interfaces.js";import{tokenize}from"./tokenize.js";import*as types from"./types.js";import*as util from"./util.js";const base10Re=/^[1-9][0-9]*$/,base10NegRe=/^-?[1-9][0-9]*$/,base16Re=/^0[x][0-9a-fA-F]+$/,base16NegRe=/^-?0[x][0-9a-fA-F]+$/,base8Re=/^0[0-7]+$/,base8NegRe=/^-?0[0-7]+$/,numberRe=/^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,nameRe=/^[a-zA-Z_][a-zA-Z_0-9]*$/,typeRefRe=/^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,fqTypeRefRe=/^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;export const parse=(e,t,n)=>{if(!isRoot(t)){n=t;t=new constructors.Root}if(!n)n=parse.defaults;const r=tokenize(e,n.alternateCommentMode||false);const s=r.next;const o=r.push;const a=r.peek;const i=r.skip;const c=r.cmnt;let u=true;let f;let l;let p;let m;let h=false;let w=t;const d=n.keepCase?e=>e:util.camelCase;function R(e,t,n){const s=parse.filename;if(!n)parse.filename=null;return Error("illegal "+(t||"token")+" '"+(e??"null")+"' ("+(s?s+", ":"")+"line "+r.line+")")}function b(){const e=[];let t;do{if('"'!==(t=s())&&"'"!==t)throw R(t);e.push(s());i(t);t=a()}while('"'===t||"'"===t);return e.join("")}function y(e){const t=s();if(null===t)return null;switch(t){case"'":case'"':o(t);return b();case"true":case"TRUE":return true;case"false":case"FALSE":return false}try{return g(t,true)}catch(n){if(e&&typeRefRe.test(t))return t;throw R(t,"value")}}function k(e,t){do{const n=a();if(t&&('"'===n||"'"===n))e.push(b());else{const t=A(s());e.push([t,i("to",true)?A(s()):t])}}while(i(",",true));i(";")}function g(e,t){let n=1;if("-"===e.charAt(0)){n=-1;e=e.substring(1)}switch(e){case"inf":case"INF":case"Inf":return n*(1/0);case"nan":case"NAN":case"Nan":case"NaN":return NaN;case"0":return 0}if(base10Re.test(e))return n*parseInt(e,10);if(base16Re.test(e))return n*parseInt(e,16);if(base8Re.test(e))return n*parseInt(e,8);if(numberRe.test(e))return n*parseFloat(e);throw R(e,"number",t)}function A(e,t){if(null===e)return 0;switch(e){case"max":case"MAX":case"Max":return 536870911;case"0":return 0}if(!t&&"-"===e.charAt(0))throw R(e,"id");if(base10NegRe.test(e))return parseInt(e,10);if(base16NegRe.test(e))return parseInt(e,16);if(base8NegRe.test(e))return parseInt(e,8);throw R(e,"id")}function N(){if(void 0!==f)throw R("package");f=s();if(!f||!typeRefRe.test(f))throw R(f,"name");w=w.define(f);i(";")}function v(){const e=a();const t="weak"===e?p||(p=[]):l||(l=[]);if("weak"===e||"public"===e)s();const n=b();i(";");t.push(n)}function x(){i("=");const e=b();if("proto3"!==e&&"proto2"!==e)throw R(e,"syntax");h="proto3"===(m=e);i(";")}function z(e,t){switch(t){case"option":M(e);i(";");return true;case"message":$(e);return true;case"enum":E(e);return true;case"service":L(e);return true;case"extend":K(e);return true}return false}function F(e,t,n){const o=r.line;if(e){e.comment=c();e.filename=parse.filename}if(i("{",true)){let e;while("}"!==(e=s())){if(null===e)throw R(e);t(e)}i(";",true)}else{n?.();i(";");if(e&&"string"!==typeof e.comment)e.comment=c(o)}}function $(e){const t=s();if(null===t||!nameRe.test(t))throw R(t,"type name");const n=new constructors.Type(t);F(n,(e=>{if(z(n,e))return;switch(e){case"map":_(n);break;case"required":case"optional":case"repeated":I(n,e);break;case"oneof":j(n);break;case"extensions":k(n.extensions||(n.extensions=[]));break;case"reserved":k(n.reserved||(n.reserved=[]),true);break;default:if(!h||null===e||!typeRefRe.test(e))throw R(e);o(e);I(n,"optional");break}}));e.add(n)}function I(e,t,n){const r=s();if("group"===r){Z(e,t);return}if(null===r||!typeRefRe.test(r))throw R(r,"type");let o=s();if(null===o||!nameRe.test(o))throw R(o,"name");o=d(o);i("=");const a=new constructors.Field(o,A(s()),r,t,n);F(a,(function e(t){if("option"===t){M(a);i(";")}else throw R(t)}),(()=>T(a)));e.add(a);if(!h&&a.repeated&&(hasProperty(types.packed,r)||hasProperty(types.basic,r)))a.setOption("packed",false,true)}function Z(e,t){let n=s();if(null===n||!nameRe.test(n))throw R(n,"name");const r=util.lcFirst(n);if(n===r)n=util.ucFirst(n);i("=");const o=A(s());const a=new constructors.Type(n);a.group=true;const c=new constructors.Field(r,o,n,t);c.filename=parse.filename;F(a,(function e(t){switch(t){case"option":M(a);i(";");break;case"required":case"optional":case"repeated":I(a,t);break;default:throw R(t)}}));e.add(a).add(c)}function _(e){i("<");const t=s();if(null===t||!hasProperty(types.mapKey,t))throw R(t,"type");i(",");const n=s();if(null===n||!typeRefRe.test(n))throw R(n,"type");i(">");const r=s();if(null===r||!nameRe.test(r))throw R(r,"name");i("=");const o=new constructors.MapField(d(r),A(s()),t,n);F(o,(e=>{if("option"===e){M(o);i(";")}else throw R(e)}),(function e(){T(o)}));e.add(o)}function j(e){const t=s();if(null===t||!nameRe.test(t))throw R(t,"name");const n=new constructors.OneOf(d(t));F(n,(e=>{if("option"===e){M(n);i(";")}else{o(e);I(n,"optional")}}));e.add(n)}function E(e){const t=s();if(null===t||!nameRe.test(t))throw R(t,"name");const n=new constructors.Enum(t);F(n,(e=>{switch(e){case"option":M(n);i(";");break;case"reserved":k(n.reserved||(n.reserved=[]),true);break;default:q(n,e)}}));e.add(n)}function q(e,t){if(null===t||!nameRe.test(t))throw R(t,"name");i("=");const n=A(s(),true);const r={};F(r,(e=>{if("option"===e){M(r);i(";")}else throw R(e)}),(()=>T(r)));e.add(t,n,r.comment??void 0)}function M(e){const t=i("(",true);let n=s();if(null===n||!typeRefRe.test(n))throw R(n,"name");let r=n;let o=r;let c;if(t){i(")");r="("+r+")";o=r;n=a();if(null!==n&&fqTypeRefRe.test(n)){c=n.substr(1);r+=n;s()}}i("=");const u=undefined;C(e,o,O(e,r),c)}function O(e,t){if(i("{",true)){const n={};while(!i("}",true)){const r=s();if(null===r||!nameRe.test(r))throw R(r,"name");let o;const c=r;if("{"===a())o=O(e,t+"."+r);else{i(":");if("{"===a())o=O(e,t+"."+r);else{o=y(true);P(e,t+"."+r,o)}}n[c]=n[c]?[n[c],o]:o;i(",",true)}return n}const n=y(true);P(e,t,n);return n}function P(e,t,n){e.setOption?.(t,n)}function T(e){if(i("[",true)){do{M(e)}while(i(",",true));i("]")}return e}function C(e,t,n,r){e.setParsedOption?.(t,n,r)}function L(e){const t=s();if(null===t||!nameRe.test(t))throw R(t,"service name");const n=new constructors.Service(t);F(n,(e=>{if(z(n,e))return;if("rpc"===e)S(n,e);else throw R(e)}));e.add(n)}function S(e,t){const n=t;if(null===(t=s())||!nameRe.test(t))throw R(t,"name");const r=t;let o,a;i("(");if(i("stream",true))o=true;if(null===(t=s())||!typeRefRe.test(t))throw R(t);const c=t;i(")");i("returns");i("(");if(i("stream",true))a=true;if(null===(t=s())||!typeRefRe.test(t))throw R(t);const u=t;i(")");const f=new constructors.Method(r,n??void 0,c,u,o,a);F(f,(e=>{if("option"===e){M(f);i(";")}else throw R(e)}));e.add(f)}function K(e){const t=s();if(null===t||!typeRefRe.test(t))throw R(t,"reference");const n=t;F(null,(t=>{switch(t){case"required":case"repeated":case"optional":I(e,t,n);break;default:if(!h||null===t||!typeRefRe.test(t))throw R(t);o(t);I(e,"optional",n);break}}))}let U;while(null!==(U=s()))switch(U){case"package":if(!u)throw R(U);N();break;case"import":if(!u)throw R(U);v();break;case"syntax":if(!u)throw R(U);x();break;case"option":M(w);i(";");break;default:if(z(w,U)){u=false;continue}throw R(U)}parse.filename=null;return{root:t,package:f,imports:l,weakImports:p,syntax:m}};parse.filename=null;parse.defaults={keepCase:false};