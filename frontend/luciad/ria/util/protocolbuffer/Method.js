import{isUndefined}from"../Lang.js";import{ReflectionObject}from"./ReflectionObject.js";import{isObject,isString}from"./util/lang.js";export class Method extends ReflectionObject{static className="Method";constructor(e,t,s,r,i,o,n,p){if(isObject(i)){p=o;n=i;i=o=void 0}else if(isObject(o)){p=n;n=o;o=void 0}if(!(void 0===t||isString(t)))throw TypeError("type must be a string");if(!isString(s))throw TypeError("requestType must be a string");if(!isString(r))throw TypeError("responseType must be a string");super(e,n);this.type=t||"rpc";this.requestType=s;this.requestStream=i?true:void 0;this.responseType=r;this.responseStream=o?true:void 0;this.resolvedRequestType=null;this.resolvedResponseType=null;this.comment=p??null}get _PB_METHOD(){return true}static fromJSON(e,t){return new Method(e,t.type,t.requestType,t.responseType,t.requestStream,t.responseStream,t.options,t.comment)}toJSON(e){const t=Boolean(e?.keepComments);const{type:s,requestType:r,requestStream:i,responseType:o,responseStream:n,options:p,comment:u}=this;const m={requestType:r,responseType:o};if(!isUndefined(s)&&"rpc"!==s)m.type=s;if(!isUndefined(i))m.requestStream=i;if(!isUndefined(n))m.responseStream=n;if(!isUndefined(p))m.options=p;if(u&&t)m.comment=u;return m}resolve(){if(this.resolved)return this;this.resolvedRequestType=this.parent?.lookupType(this.requestType)??null;this.resolvedResponseType=this.parent?.lookupType(this.responseType)??null;return super.resolve()}}