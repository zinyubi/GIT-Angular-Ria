import{hasProperty}from"../Lang.js";import{isEnum}from"./interfaces.js";import*as types from"./types.js";import*as util from"./util.js";import{codegen}from"./util/codegen.js";function genTypePartial(e,i,s,t){return i.resolvedType?.group?e("types[%i].encode(%s,w.uint32(%i)).uint32(%i)",s,t,(i.id<<3|3)>>>0,(i.id<<3|4)>>>0):e("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()",s,t,(i.id<<3|2)>>>0)}export function encoder(e){const i=codegen(["m","w"],e.name+"$encode")("if(!w)")("w=Writer.create()");const{fieldsArray:s}=e;const t=s.slice().sort(util.compareFieldsById);for(let e=0;e<t.length;++e){const n=t[e].resolve();const o=s.indexOf(n);const r=isEnum(n.resolvedType)?"int32":n.type;const l=hasProperty(types.basic,r)?types.basic[r]:void 0;const p="m"+util.safeProp(n.name);if(n.map){const e=n;i("if(%s!=null&&m.hasOwnProperty(%j)){",p,e.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){",p)("w.uint32(%i).fork().uint32(%i).%s(ks[i])",(e.id<<3|2)>>>0,8|types.mapKey[e.keyType],e.keyType);if(void 0===l)i("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()",o,p);else i(".uint32(%i).%s(%s[ks[i]]).ldelim()",16|l,r,p);i("}")("}")}else if(n.repeated){i("if(%s!=null&&%s.length){",p,p);if(n.packed&&hasProperty(types.packed,r))i("w.uint32(%i).fork()",(n.id<<3|2)>>>0)("for(var i=0;i<%s.length;++i)",p)("w.%s(%s[i])",r,p)("w.ldelim()");else{i("for(var i=0;i<%s.length;++i)",p);if(void 0===l)genTypePartial(i,n,o,p+"[i]");else i("w.uint32(%i).%s(%s[i])",(n.id<<3|l)>>>0,r,p)}i("}")}else{if(n.optional)i("if(%s!=null&&m.hasOwnProperty(%j))",p,n.name);if(void 0===l)genTypePartial(i,n,o,p);else i("w.uint32(%i).%s(%s)",(n.id<<3|l)>>>0,r,p)}}return i("return w")}