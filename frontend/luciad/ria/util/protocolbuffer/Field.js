import{hasProperty}from"../Lang.js";import{isEnum,isType}from"./interfaces.js";import{ReflectionObject}from"./ReflectionObject.js";import*as types from"./types.js";import*as util from"./util.js";import*as base64 from"./util/base64.js";import{isInteger,isObject,isString}from"./util/lang.js";import{Long}from"./util/Long.js";import*as utf8 from"./util/utf8.js";import{emptyArray,emptyObject,newBuffer}from"./util/util.js";const ruleRe=/^required|optional|repeated$/;export class Field extends ReflectionObject{static className="Field";constructor(e,t,i,s="optional",o,r,l){if(isObject(s)){l=o;r=s;s=o=void 0}else if(isObject(o)){l=r;r=o;o=void 0}super(e,r);if(!isInteger(t)||t<0)throw TypeError("id must be a non-negative integer");if(!isString(i))throw TypeError("type must be a string");if(void 0!==s&&!ruleRe.test(s=s.toString().toLowerCase()))throw TypeError("rule must be a string rule");if(void 0!==o&&!isString(o))throw TypeError("extend must be a string");this.rule=s&&"optional"!==s?s:void 0;this.type=i;this.id=t;this.extend=o||void 0;this.required="required"===s;this.optional=!this.required;this.repeated="repeated"===s;this.map=false;this.message=null;this.partOf=null;this.typeDefault=null;this.defaultValue=null;this.long=hasProperty(types.long,i);this.bytes="bytes"===i;this.resolvedType=null;this.extensionField=null;this.declaringField=null;this._packed=null;this.comment=l??null}get _PB_FIELD(){return true}get packed(){if(null===this._packed)this._packed=false!==this.getOption("packed");return this._packed}static fromJSON(e,t){return new Field(e,t.id,t.type,t.rule,t.extend,t.options,t.comment)}setOption(e,t,i){if("packed"===e)this._packed=null;return super.setOption(e,t,i)}toJSON(e){const t=Boolean(e?.keepComments);const{rule:i,type:s,id:o,extend:r,options:l,comment:p}=this;const n={type:s,id:o,extend:r,options:l};if(i&&"optional"!==i)n.rule=i;if(t&&null!==p)n.comment=p;return n}resolve(){if(this.resolved)return this;this.typeDefault=hasProperty(types.defaults,this.type)?types.defaults[this.type]:void 0;if(void 0===this.typeDefault){this.resolvedType=(this.declaringField?.parent||this.parent)?.lookupTypeOrEnum(this.type)??null;if(isType(this.resolvedType))this.typeDefault=null;else this.typeDefault=this.resolvedType?.values[Object.keys(this.resolvedType.values)[0]]}if(void 0!==this.options?.["default"]){this.typeDefault=this.options["default"];if(isEnum(this.resolvedType)&&"string"===typeof this.typeDefault)this.typeDefault=this.resolvedType.values[this.typeDefault]}if(this.options){if(true===this.options.packed||void 0!==this.options.packed&&this.resolvedType&&!isEnum(this.resolvedType))delete this.options.packed;if(!Object.keys(this.options).length)this.options=void 0}if(this.long){this.typeDefault=Long.fromNumber(this.typeDefault,"u"===this.type.charAt(0));if(Object.freeze)Object.freeze(this.typeDefault)}else if(this.bytes&&"string"===typeof this.typeDefault){let e;if(base64.test(this.typeDefault))base64.decode(this.typeDefault,e=newBuffer(base64.length(this.typeDefault)),0);else utf8.write(this.typeDefault,e=newBuffer(utf8.length(this.typeDefault)),0);this.typeDefault=e}if(this.map)this.defaultValue=emptyObject;else if(this.repeated)this.defaultValue=emptyArray;else this.defaultValue=this.typeDefault;if(isType(this.parent))this.parent.ctor.prototype[this.name]=this.defaultValue;return super.resolve()}}export function d(e,t,i="optional",s){const o="function"===typeof t?util.decorateType(t).name:t&&"object"===typeof t?util.decorateEnum(t).name:t;return(t,r)=>{util.decorateType(t.constructor).add(new Field(r,e,o,i,{default:s}))}}