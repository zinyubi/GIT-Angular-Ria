import{isRoot}from"./interfaces.js";import*as util from"./util.js";import{isObject,isString}from"./util/lang.js";export class ReflectionObject{static className="ReflectionObject";constructor(t,s){if(!isString(t))throw TypeError("name must be a string");if(s&&!isObject(s))throw TypeError("options must be an object");this.options=s;this.parsedOptions=null;this.name=t;this.parent=null;this.resolved=false;this.comment=null;this.filename=null}get _PB_REFLECTION_OBJECT(){return true}get root(){let t=this;while(null!==t.parent)t=t.parent;return t}get fullName(){const t=[this.name];let s=this.parent;while(s){t.unshift(s.name);s=s.parent}return t.join(".")}onAdd(t){if(this.parent&&this.parent!==t)this.parent.remove(this);this.parent=t;this.resolved=false;const s=t.root;if(isRoot(s))s.handleAdd(this)}onRemove(t){const s=t.root;if(isRoot(s))s.handleRemove(this);this.parent=null;this.resolved=false}resolve(){if(this.resolved)return this;if(isRoot(this.root))this.resolved=true;return this}getOption(t){if(this.options)return this.options[t];return}setOption(t,s,e){if(!e||!this.options||void 0===this.options[t])(this.options||(this.options={}))[t]=s;return this}setParsedOption(t,s,e){const i=this.parsedOptions||(this.parsedOptions=[]);if(!e){i.push({[t]:s});return this}const o=i.find((s=>Object.prototype.hasOwnProperty.call(s,t)));if(o){util.setProperty(o[t],e,s);return this}i.push({[t]:util.setProperty({},e,s)});return this}setOptions(t,s){if(t){const e=Object.keys(t);for(let i=0;i<e.length;++i)this.setOption(e[i],t[e[i]],s)}return this}toString(){const{className:t,name:s}=Object.getPrototypeOf(this).constructor;const e=this.fullName;if(e.length)return`${t||s} ${e}`;return t||s}}