import{ProgrammingError}from"../error/ProgrammingError.js";import{PolygonOrientation}from"../shape/PolygonOrientation.js";import{Clipping}from"./Clipping.js";import{Constants}from"./Constants.js";const TOLERANCE=1e-9;export function distance2D_xy(n,t,e,o){return Math.sqrt(Math.pow(e-n,2)+Math.pow(o-t,2))}export function contains2D(n,t,e){return segmentContainsXY2D(n.x,n.y,t.x,t.y,e.x,e.y)}export function distance2D(n,t){return distance2D_xy(n.x,n.y,t.x,t.y)}export function distance2DFlat(n,t){return distance2D_xy(n.x,n.y,t.x,t.y)}export function squaredDistance2D_flat(n,t){return Math.pow(t.x-n.x,2)+Math.pow(t.y-n.y,2)}export function squaredDistance2D(n,t,e,o){return Math.pow(e-n,2)+Math.pow(o-t,2)}export function distance3D(n,t){return distance3D_xyz(n.x,n.y,n.z,t.x,t.y,t.z)}export function distance3D_xyz(n,t,e,o,i,r){return Math.sqrt(squaredDistance3D_xyz(n,t,e,o,i,r))}export function squaredDistance3D(n,t){return squaredDistance3D_xyz(n.x,n.y,n.z,t.x,t.y,t.z)}export function squaredDistance3D_xyz(n,t,e,o,i,r){return Math.pow(o-n,2)+Math.pow(i-t,2)+Math.pow((r||0)-(e||0),2)}export function ringContainsXY2DFlatCoordList(n,t,e){if(n.length<=9)return false;let o,i,r,s,c,a,l,u;for(o=false,i=-3,s=n.length,r=s-3;i<s;r=i){i+=3;c=n[i];a=n[i+1];l=n[r];u=n[r+1];if((a<=e&&e<u||u<=e&&e<a)&&t<(l-c)*(e-a)/(u-a)+c)o=!o}return o}export function segmentContainsXY2D(n,t,e,o,i,r){const s=o-t;const c=r-t;const a=e-n;const l=i-n;if(Math.abs(s)<=TOLERANCE&&Math.abs(c)>TOLERANCE||Math.abs(a)<=TOLERANCE&&Math.abs(l)>TOLERANCE)return false;if(Math.abs(s)<=TOLERANCE&&Math.abs(c)<=TOLERANCE)if(Math.abs(a)<=TOLERANCE&&Math.abs(l)<=TOLERANCE)return true;else return Math.abs(l)<=Math.abs(a)&&l*a>=0;else if(Math.abs(a)<=TOLERANCE&&Math.abs(l)<=TOLERANCE)return Math.abs(c)<=Math.abs(s)&&c*s>=0;const u=c/s;const f=l/a;return Math.abs(f-u)<=TOLERANCE&&u>=0&&u<=1&&f>=0&&f<=1}export function closestPointOnSegment(n,t,e,o){return closestPointOnLine(n,t,e,true,o)}export function closestPointOnLine(n,t,e,o,i){const r=t.x;const s=t.y;const c=e.x;const a=e.y;const l=n.x;const u=n.y;const f=undefined;const p=c-r;const x=undefined;const h=a-s;const C=p*p+h*h;let g;if(0!==C)g=((l-r)*p+(u-s)*h)/C;else g=0;if(o)if(g<0)g=0;else if(g>1)g=1;const d=r+g*p;const m=s+g*h;const y=l-d;const M=u-m;i.x=d;i.y=m;return{distance:Math.sqrt(y*y+M*M),position:i}}export function squaredDistanceToSegment(n,t,e,o,i,r){const s=undefined;const c=e-n;const a=undefined;const l=o-t;const u=c*c+l*l;let f;if(0!==u)f=((i-n)*c+(r-t)*l)/u;else f=0;if(f<0)f=0;else if(f>1)f=1;const p=undefined;const x=undefined;const h=i-(n+f*c);const C=r-(t+f*l);return h*h+C*C}function minSegmentDistanceTo(n,t){const e=n;const o=t;function i(n,t,i,r,s){let c;if(r>1){c=squaredDistanceToSegment(s[r-3],s[r-2],t,i,e,o);if(c<n)return c}return n}return i}export function squaredDistanceToLineFlat(n,t,e){const o=n.length;if(o<3)return Number.POSITIVE_INFINITY;else if(3===o)return squaredDistance2D(n[0],n[1],t,e);else return reduceByPair(n,minSegmentDistanceTo(t,e),1/0)}export function angleInRadians(n,t,e,o){return Math.atan2(o-t,e-n)}export function forwardAzimuth2D_xy(n,t,e,o){const i=angleInRadians(n,t,e,o),r=Math.PI/2-i;return r<0?r+2*Math.PI:r}export function forwardAzimuth2D(n,t){return forwardAzimuth2D_xy(n.x,n.y,t.x,t.y)}export function normalizeAngle(n){while(n>180)n-=360;while(n<=-180)n+=360;return n}export function normalizeAngle0To360(n,t){t=t||0;while(n+t<0)n+=360;while(n+t>=360)n-=360;return n}export function containsAnglePragmatic(n,t,e){return containsAngleWithTolerance(n,t,e,Constants.ABSOLUTE_ANGLE_TOLERANCE,Constants.RELATIVE_ANGLE_TOLERANCE)}function containsAngleWithTolerance(n,t,e,o,i){const r=0===t?o:(t<0?-1:1)*(o+i*Math.abs(t));return containsAngle(n-r,t+2*r,e)}export function containsAngle(n,t,e){if(t>=360||t<=-360)return true;const o=(n=normalizeAngle(n))+t;const i=normalizeAngle(e);if(t>=0)if(o>180&&i<n)return i+360<=o;else return i>=n&&i<=o;else if(o<=-180&&i>=n)return i-360>=o;else return i>=o&&i<=n}export function intersection2DLSSFCT(n,t,e,o,i,r,s,c,a){const l=(o-t)*(s-i)-(e-n)*(c-r);a.move2D(n,t);if(Math.abs(l)<1e-10)a.move2D((e+i)/2,(o+r)/2);else{const u=((n-i)*(c-r)-(t-r)*(s-i))/l;a.move2D(n+u*(e-n),t+u*(o-t))}}export function _intersection2DSFCT(n,t,e,o,i,r,s,c,a){const l=(n-e)*(r-c)-(t-o)*(i-s);if(0===l){a.x=null;a.y=null;a.intersects=false;return}const u=((n*o-t*e)*(i-s)-(n-e)*(i*c-r*s))/l;const f=((n*o-t*e)*(r-c)-(t-o)*(i*c-r*s))/l;a.x=u;a.y=f;a.intersects=true}export function segmentIntersectionSFCT(n,t,e,o,i,r,s,c,a){const l={x:null,y:null,intersects:false};_intersection2DSFCT(n,t,e,o,i,r,s,c,l);if(!l.intersects){a.intersects=false;a.x=null;a.y=null;return false}const u=Math.min(n,e)-TOLERANCE;const f=Math.max(n,e)+TOLERANCE;const p=Math.min(t,o)-TOLERANCE;const x=Math.max(t,o)+TOLERANCE;const h=Math.min(i,s)-TOLERANCE;const C=Math.max(i,s)+TOLERANCE;const g=Math.min(r,c)-TOLERANCE;const d=Math.max(r,c)+TOLERANCE;const m=l.x;const y=l.y;const M=undefined;const E=undefined;if(u<=m&&m<=f&&p<=y&&y<=x&&(h<=m&&m<=C&&g<=y&&y<=d)){a.intersects=true;a.x=m;a.y=y}else{a.intersects=false;a.x=null;a.y=null}return a.intersects}export function rectangleSegmentIntersectionsSFCT(n,t,e,o,i,r,s,c,a){const l={x:null,y:null,intersects:false};let u=false;let f;let p=0;const x=Math.min(i,s);const h=Math.max(i,s);const C=Math.min(r,c);const g=Math.max(r,c);a.length=0;_intersection2DSFCT(n,t,e,t,i,r,s,c,l);if(l.intersects){f=l.x;u=n<=f&&f<=e;f=l.y;u=u&&C<=f&&f<=g;if(u){p+=1;a.push(l.x,l.y)}}_intersection2DSFCT(n,o,e,o,i,r,s,c,l);if(l.intersects){f=l.x;u=n<=f&&f<=e;f=l.y;u=u&&C<=f&&f<=g;if(u){p+=1;a.push(l.x,l.y)}}_intersection2DSFCT(n,o,n,t,i,r,s,c,l);if(l.intersects){f=l.y;u=o<=f&&f<=t;f=l.x;u=u&&x<=f&&f<=h;if(u){p+=1;a.push(l.x,l.y)}}_intersection2DSFCT(e,o,e,t,i,r,s,c,l);if(l.intersects){f=l.y;u=o<=f&&f<=t;f=l.x;u=u&&x<=f&&f<=h;if(u){p+=1;a.push(l.x,l.y)}}a.intersections=p}function sign(n){return n<0?-1:1}export function rotatePointOnOriginCW(n,t,e,o){const i=Math.sin(e);const r=Math.cos(e);o.x=n*r+t*i;o.y=t*r-n*i}export function rotatePointOnOriginCCW(n,t,e,o){const i=Math.sin(e);const r=Math.cos(e);o.x=n*r-t*i;o.y=t*r+n*i}export function rotatePointCCW(n,t,e,o,i,r){const s=undefined;const c=undefined;rotatePointOnOriginCW(n-o,t-i,e,r);r.x+=o;r.y+=i}export function rotatePointCW(n,t,e,o,i,r){const s=undefined;const c=undefined;rotatePointOnOriginCCW(n-o,t-i,e,r);r.x+=o;r.y+=i}export function lineCircleIntersectionSFCT(n,t,e,o,i,r){const s=e-n;const c=o-t;const a=n*o-e*t;const l=Math.pow(a,2);const u=squaredDistance2D(n,t,e,o);const f=undefined;const p=Math.pow(i,2)*u-l;if(p<0){r.length=0;r.intersections=0;return r}const x=Math.sqrt(p);const h=(a*c+sign(c)*s*x)/u;const C=(-a*s+Math.abs(c)*x)/u;r[0]=h;r[1]=C;if(0===p){r.length=2;r.intersections=1;return r}r.length=4;r.intersections=2;const g=(a*c-sign(c)*s*x)/u;const d=(-a*s-Math.abs(c)*x)/u;r[2]=g;r[3]=d}export function lineCircleIntersectionWithCenterPointSFCT(n,t,e,o,i,r,s,c){lineCircleIntersectionSFCT(n-=i,t-=r,e-=i,o-=r,s,c);for(let n=0;n<2*c.intersections;n+=2){c[n]+=i;c[n+1]+=r}}function parallelAxisSegmentCircleIntersectionSFCT(n,t,e,o,i,r){const s=[];function c(n,t,e,o,i,r){if(n===e)return t<=o?t<=r&&r<=o:o<=r&&r<=t;else if(t===o)return n<=e?n<=i&&i<=e:e<=i&&i<=n;else throw new ProgrammingError("Cannot transform Bounds in non rectangular view (should never occur)")}r.length=0;r.intersections=0;lineCircleIntersectionSFCT(n,t,e,o,i,s);const a=s.intersections;let l,u,f;if(1===a){l=s[0];u=s[1];f=c(n,t,e,o,l,u);if(f){r.intersections=1;r.push(l);r.push(u)}}else if(2===a){l=s[0];u=s[1];f=c(n,t,e,o,l,u);if(f){r.intersections+=1;r.push(l);r.push(u)}l=s[2];u=s[3];f=c(n,t,e,o,l,u);if(f){r.intersections+=1;r.push(l);r.push(u)}}}export function rectangleCircleIntersection(n,t,e,o,i){const r=[];function s(n,t){n.intersections+=t.intersections;n.push.apply(n,t)}const c=[];c.intersections=0;parallelAxisSegmentCircleIntersectionSFCT(n,t,n,o,i,r);s(c,r);parallelAxisSegmentCircleIntersectionSFCT(n,t,e,t,i,r);s(c,r);parallelAxisSegmentCircleIntersectionSFCT(e,t,e,o,i,r);s(c,r);parallelAxisSegmentCircleIntersectionSFCT(n,o,e,o,i,r);s(c,r);return c}export function clamp(n,t,e){if(n>e)n=e;if(n<t)n=t;return n}export function toPolar(n,t,e){e.r=Math.sqrt(n*n+t*t);e.a=Math.atan2(t,n)}export function ellipticalDistance2D(n,t,e){if(n===t)return n;else if(0===n)return 90===Math.abs(e%180)?t:0;else if(0===t)return e%180===0?n:0;else{const o=e*Constants.DEG2RAD;const i=Math.cos(o);const r=undefined;const s=n*Math.sin(o);const c=t*i;return n*t/Math.sqrt(s*s+c*c)}}export function orientation2D(n){if(!n||n.length<1)throw new ProgrammingError("Cannot calculate orientation. You should provide a proper array with at least 1 point");let t=n.length-1;const e=n[0];const o=n[t];if(e.x===o.x&&e.y===o.y&&e.z===o.z)t--;let i=0;for(let e=0;e<t;e++)i+=n[e].x*n[e+1].y-n[e].y*n[e+1].x;i+=n[t].x*n[0].y-n[t].y*n[0].x;return i>0?PolygonOrientation.COUNTER_CLOCKWISE:PolygonOrientation.CLOCKWISE}export function orientation2D_flat(n){let t=n.length-3;if(n[0]===n[t]&&n[1]===n[t+1])t-=3;let e=0;for(let o=0;o<t;o+=3)e+=n[o]*n[o+4]-n[o+1]*n[o+3];e+=n[t]*n[1]-n[t+1]*n[0];return e>0?PolygonOrientation.COUNTER_CLOCKWISE:PolygonOrientation.CLOCKWISE}export function pointAtDistanceAndAngle(n,t,e,o,i){i.x=n+o*Math.cos(e);i.y=t+o*Math.sin(e)}export function flipOrientationSFCT_flat(n){const t=n.length;let e,o,i;for(e=0,i=3*Math.floor(t/6);e<i;e+=3){o=n[e];n[e]=n[t-3-e];n[t-3-e]=o;o=n[e+1];n[e+1]=n[t-2-e];n[t-2-e]=o;o=n[e+2];n[e+2]=n[t-1-e];n[t-1-e]=o}}export function interpolate(n,t,e){return n+(t-n)*e}export function isUpsideDown(n){return(Constants.d360InRadians+Constants.d90InRadians+n)%Constants.d360InRadians>=Constants.d180InRadians}export function clipLineWithRectangle(n,t,e,o,i,r,s,c,a){let l=n,u=t,f=e,p=o,x,h,C,g,d,m,y;x=Clipping.computeRegion(l,u,i,c,s,r);h=Clipping.computeRegion(f,p,i,c,s,r);C=false;g=false;while(!g)if(0===(x|h)){C=true;g=true;break}else if(0!==(x&h)){g=true;break}else{d=0===x?h:x;m=0===x?f:l;y=0===x?p:u;if(0!==(d&Clipping.TOP)){m=l+(f-l)*(c-u)/(p-u);y=c}else if(0!==(d&Clipping.BOTTOM)){m=l+(f-l)*(r-u)/(p-u);y=r}else if(0!==(d&Clipping.RIGHT)){y=u+(p-u)*(s-l)/(f-l);m=s}else if(0!==(d&Clipping.LEFT)){y=u+(p-u)*(i-l)/(f-l);m=i}if(d===x){l=m;u=y;x=Clipping.computeRegion(l,u,i,c,s,r)}else{f=m;p=y;h=Clipping.computeRegion(f,p,i,c,s,r)}}a.clippedStartX=l;a.clippedStartY=u;a.clippedEndX=f;a.clippedEndY=p;return C}export function area(n){const t=n.pointCount;let e=0,o=0;for(let i=0;i<t;i++){e+=n.getPoint(i).x;o+=n.getPoint(i).y}e/=t;o/=t;let i=0;let r,s,c,a;c=n.getPoint(0).x-e;a=n.getPoint(0).y-o;for(let l=0;l<t-1;l++){r=c;s=a;c=n.getPoint(l+1).x-e;a=n.getPoint(l+1).y-o;i+=r*a-c*s}r=c;s=a;c=n.getPoint(0).x-e;a=n.getPoint(0).y-o;i+=r*a-c*s;i/=2;return i}function reduceByPair(n,t,e){let o=0;const i=n.length;let r=e;while(o<i){r=t(r,n[o],n[o+1],o,n);o+=3}return r}export function angleDifference(n,t){n=normalizeAngle0To360(n);t=normalizeAngle0To360(t);return Math.min(Math.abs(n-t),Math.abs(n-(360-t)))}export function orientedAngleOnPlane(n,t,e){function o(n,t,e){const o=Math.acos(clamp(n.dot(t),-1,1));return e.dot(n.clone().cross(t))<0?-o:o}function i(n,t){return t.clone().multiplyScalar(n.dot(t)/t.dot(t))}function r(n,t){return n.clone().sub(i(n,t))}e=e.clone().normalize();n=n.clone().normalize();t=t.clone().normalize();const s=r(n,e);const c=r(t,e);if(s.length()<1e-5||c.length()<1e-5)return null;return o(s.normalize(),c.normalize(),e)}