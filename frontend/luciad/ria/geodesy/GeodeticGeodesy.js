import{ReferenceType}from"../reference/ReferenceType.js";import{ProgrammingError}from"../error/ProgrammingError.js";import{createTransformation}from"../transformation/TransformationFactory.js";import{GeodeticReference}from"../reference/GeodeticReference.js";import{createPoint}from"../shape/ShapeFactory.js";import{ShapeType}from"../shape/ShapeType.js";import{LLHPolygon}from"../shape/LLHPolygon.js";export class GeodeticGeodesy{constructor(e){this._reference=e;let t;if(e.referenceType===ReferenceType.GRID||e.referenceType===ReferenceType.GEOCENTRIC||e.referenceType===ReferenceType.TOPOCENTRIC)t=new GeodeticReference({geodeticDatum:e.geodeticDatum});else if(e.referenceType===ReferenceType.GEODETIC)t=e;else throw new ProgrammingError(`Unsupported reference type: ${e.referenceType}`);this._geodeticReference=t;this._ellipsoid=t.geodeticDatum.ellipsoid;this._calcToGeodetic=createTransformation(this.reference,t)}get reference(){return this._reference}get ellipsoid(){return this._ellipsoid}get geodeticReference(){return this._geodeticReference}distance(e,t,o){const r=this.refToCalcRef(e);const c=this.calcRefToGeodetic(r);const i=this.refToCalcRef(t);const s=this.calcRefToGeodetic(i);return this.distanceImpl(this._ellipsoid,c,s,o)}distance3D(e,t,o){const r=this.refToCalcRef(e);const c=this.calcRefToGeodetic(r);const i=this.refToCalcRef(t);const s=this.calcRefToGeodetic(i);return this.distance3DImpl(this._ellipsoid,c,s,o)}forwardAzimuth(e,t,o){const r=this.refToCalcRef(e);const c=this.calcRefToGeodetic(r);const i=this.refToCalcRef(t);const s=this.calcRefToGeodetic(i);return this.forwardAzimuthImpl(this._ellipsoid,c,s,o)}interpolate(e,t,o,r){const c=this.refToCalcRef(e);const i=this.calcRefToGeodetic(c);const s=createPoint(this._geodeticReference,[0,0]);if("number"===typeof t){if(t<0){t=-t;if(o>180)o-=180;else o=180+o}this.interpolateDistanceAzimuthImpl(this._ellipsoid,i,t,o,r,s);s.z=e.z}else{const c=this.refToCalcRef(t);const n=this.calcRefToGeodetic(c);this.interpolateFractionImpl(this._ellipsoid,i,n,o,r,s);s.z=e.z+o*(t.z-e.z)}return this.geodeticToCalcRef(s)}area(e){if(!ShapeType.contains(e.type,ShapeType.POLYGON))throw new ProgrammingError("Only the calculation of the area of a polygon is supported at the moment");const t=e;const o=t.reference;let r;if(!o||o==this.geodeticReference||o.equals(this.geodeticReference))r=t;else if(!o||o==this.reference||o.equals(this.reference)){const e=new Array(t.pointCount);for(let o=0;o<e.length;o++)e[o]=this.calcRefToGeodetic(t.getPoint(o));r=new LLHPolygon(this._geodeticReference,e)}else{const e=createTransformation(o,this.reference);const c=new Array(t.pointCount);for(let o=0;o<c.length;o++){const r=t.getPoint(o);const i=e.transform(r);c[o]=this.calcRefToGeodetic(i)}r=new LLHPolygon(this._geodeticReference,c)}return this.areaImpl(this._ellipsoid,r)}shortestDistanceToLine(e,t,o,r,c){const i=this.refToCalcRef(e);const s=this.calcRefToGeodetic(i);const n=this.refToCalcRef(t);const f=this.calcRefToGeodetic(n);const a=this.refToCalcRef(o);const l=this.calcRefToGeodetic(a);const h=createPoint(this._geodeticReference,[0,0]);const p=this.shortestDistanceToLineImpl(this._ellipsoid,s,f,l,r,h);this.geodeticToCalcRef(h,c);return p}refToCalcRef(e){const t=e.reference;if(!t||t==this.reference||t.equals(this.reference))return e;else{const o=undefined;return createTransformation(t,this.reference).transform(e)}}calcRefToGeodetic(e){const t=createPoint(this._geodeticReference,[0,0]);this._calcToGeodetic.transform(e,t);return t}geodeticToCalcRef(e,t){const o=t??createPoint(this.reference,[0,0]);this._calcToGeodetic.inverseTransformation.transform(e,o);return o}}