import{ProgrammingError}from"../error/ProgrammingError.js";import{PolygonOrientation}from"../shape/PolygonOrientation.js";import{simplePointMove2D}from"../shape/SimplePoint.js";import{XYZPoint}from"../shape/XYZPoint.js";import{VecMath}from"../util/VecMath.js";import{containsAngle}from"../util/Cartesian.js";import{Constants}from"../util/Constants.js";import{normalizeLon}from"../util/LonLatCoord.js";import{forwardAzimuth2D,forwardAzimuth2DLL}from"./AzimuthUtil.js";import{geodesicArea as externalGeodesicArea}from"./GeodesicAreaUtil.js";const d90InRad=Math.PI/2;function sign(t){return t>=0?1:-1}const fTemp4XYPointArray1=[new XYZPoint,new XYZPoint,new XYZPoint,new XYZPoint];const fTemp4XYPointArray2=[new XYZPoint,new XYZPoint,new XYZPoint,new XYZPoint];function geoc2llh({x:t,y:n,z:o},s,e){const i=t*t+n*n;const a=Math.sqrt(i);e.y=Math.atan(o/a)*Constants.RAD2DEG;e.x=Math.atan2(n,t)*Constants.RAD2DEG;e.z=Math.sqrt(i+o*o)-s}function llh2geoc({x:t,y:n},o,s){const e=n*Constants.DEG2RAD;const i=t*Constants.DEG2RAD;const a=s+o;const r=Math.cos(e);return{x:a*r*Math.cos(i),y:a*r*Math.sin(i),z:a*Math.sin(e)}}export function greatCircleDistance(t,n){const o=(n.x-t.x)*Constants.DEG2RAD/2;const s=(n.y-t.y)*Constants.DEG2RAD/2;const e=Math.sin(o);const i=Math.sin(s);const a=Math.cos(t.y*Constants.DEG2RAD);const r=Math.cos(n.y*Constants.DEG2RAD);const c=Math.sqrt(i*i+a*r*e*e);return 2*Constants.RAD2DEG*Math.asin(c)}export function greatCircleDistanceLL(t,n,o,s,e,i){const a=(s-t)*Constants.DEG2RAD/2;const r=(e-n)*Constants.DEG2RAD/2;const c=Math.sin(a);const l=Math.sin(r);const f=Math.sqrt(l*l+o*i*c*c);return 2*Constants.RAD2DEG*Math.asin(f)}export function closestPointOnGeodesic(t,n,o,s,e){if(o.x===t.x&&o.y===t.y){simplePointMove2D(e,t.x,t.y);return 0}if(o.x===n.x&&o.y===n.y){simplePointMove2D(e,n.x,n.y);return 0}const i=llh2geoc(t,0,1);const a=llh2geoc(n,0,1);const r=llh2geoc(o,0,1);const c=VecMath.cross(i,a);const l=VecMath.cross(c,r);const f=undefined;geoc2llh(VecMath.normalize(VecMath.cross(l,c)),1,e);if(t.z===n.z)e.z=t.z;if(s){const o=greatCircleDistance(t,e);const s=greatCircleDistance(n,e);const i=greatCircleDistance(t,n);if(Math.abs(i-o-s)>=1e-10)if(s<=o)simplePointMove2D(e,n.x,n.y);else simplePointMove2D(e,t.x,t.y)}return greatCircleDistance(o,e)}export function orientation2D(t){const n=undefined;return externalGeodesicArea(t,null)>0?PolygonOrientation.COUNTER_CLOCKWISE:PolygonOrientation.CLOCKWISE}export function greatCirclePointSFCT(t,n,o,s){const e=o*Constants.DEG2RAD;const i=n*Constants.DEG2RAD;const a=Math.sin(i);const r=Math.cos(i);const c=Math.cos(t.y*Constants.DEG2RAD);const l=Math.sin(t.y*Constants.DEG2RAD);const f=Math.cos(e)*c*a+r*l;const u=Math.asin(f);const D=Math.sin(e)*a;const h=(r-l*f)/c;const m=Math.atan2(D,h)*Constants.RAD2DEG;s.x=normalizeLon(t.x+m);s.y=u*Constants.RAD2DEG}export function greatCirclePointAtFractionSFCT(t,n,o,s){let e;let i;if(Math.abs(o)<1e-12){i=t.y;e=t.x;simplePointMove2D(s,e,i)}else if(Math.abs(o-1)<1e-12){i=n.y;e=n.x;simplePointMove2D(s,e,i)}else{const e=undefined;const i=undefined;greatCirclePointSFCT(t,o*greatCircleDistance(t,n),forwardAzimuth2D(t,n)*Constants.RAD2DEG,s)}return s}export function rhumblinePointSFCT(t,n,o,s){const e=o*Constants.DEG2RAD;if(0===n){s.x=t.x;s.y=t.y}else{const o=Constants.DEG2RAD*t.x;const i=Constants.DEG2RAD*t.y;const a=n*Constants.DEG2RAD;let r=i+a*Math.cos(e);if(Math.abs(r)>d90InRad)r=d90InRad*sign(r);const c=Math.log(Math.tan(r/2+Math.PI/4)/Math.tan(i/2+Math.PI/4));let l;if(Math.abs(i-r)<1e-6)l=Math.cos(i);else l=(r-i)/c;const f=undefined;const u=(o+a*Math.sin(e)/l+Math.PI)%(2*Math.PI)-Math.PI;s.x=Constants.RAD2DEG*u;s.y=Constants.RAD2DEG*r}}export function contains2D(t,n,o){const s=greatCircleDistance(t,n);const e=forwardAzimuth2D(t,n);const i=greatCircleDistance(t,o);const a=forwardAzimuth2D(t,o);const r=Math.abs(a-e);return(r<1e-8||Math.abs(r-2*Math.PI)<1e-8)&&i<=s||i<1e-10}export function complexPolygonContains2D(t,n){const o=t.bounds;if(null==o||!o.contains2DPoint(n))return false;const s=n.x;const e=n.y;const i=s*Constants.DEG2RAD;const a=e*Constants.DEG2RAD;const r=Math.sin(i);const c=Math.cos(i);const l=Math.sin(a);const f=Math.cos(a);const u=undefined;let D=ringContains2D(t.getPolygon(0),s,r,c,e,l,f);let h;const m=t.polygonCount;let M;if(D&&m>1)for(h=1;h<m;h++){M=ringContains2D(t.getPolygon(h),s,r,c,e,l,f);D=M?!D:D}return D}export function polygonContains2D(t,n,o){const s=n*Constants.DEG2RAD;const e=o*Constants.DEG2RAD;const i=undefined;const a=undefined;const r=undefined;const c=undefined;return ringContains2D(t,n,Math.sin(s),Math.cos(s),o,Math.sin(e),Math.cos(e))}function ringContains2D(t,n,o,s,e,i,a){const r=t.pointCount;let c=0;const l=1e-10;const f=[];let u=t.getSimplePoint(0);for(let o=1;o<=r;o++){const s=t.getSimplePoint(o%r);if(isInsideInterval(n,u.x,s.x,1e-10)){const t=Math.abs(n-u.x);if(Math.abs(u.x-s.x)<l&&t<l)if(e<u.y!=e<s.y)return true;const o=Math.abs(e-u.y);if(Math.abs(u.y)<l&&Math.abs(u.y-s.y)<l&&o<l)return true;if(t<l&&o<l)return true;f.push(u);f.push(s)}c+=u.y;u=s}const D=f.length/2;if(0==D)return false;c/=r;let h=0;let m=0;let M=0;while(M<D&&f[2*M].x===n)M++;if(M>=D)M=0;const C=c<0;for(let t=0;t<D;t++){const t=f[2*M];const r=f[2*M+1];const c=r.x-t.x;if(0!=c&&180!=c&&-180!=c){const c=1e-15;let l=false;if(Math.abs(r.x-n)<c){const n=undefined;if(r.y>=e===C){m=t.x;l=true}}if(Math.abs(t.x-n)<c){const o=undefined;if(t.y>=e===C&&m>n!=r.x>n)h+=increasing(t.x,r.x);l=true}if(!l){const c=t.x;const l=t.y;const f=Math.sin(t.x*Constants.DEG2RAD);const u=Math.cos(t.x*Constants.DEG2RAD);const D=Math.sin(t.y*Constants.DEG2RAD);const m=Math.cos(t.y*Constants.DEG2RAD);const M=r.x;const A=r.y;const y=undefined;const P=undefined;const d=undefined;const p=undefined;h+=meridionalIntersectionCount(c,f,u,l,D,m,M,Math.sin(r.x*Constants.DEG2RAD),Math.cos(r.x*Constants.DEG2RAD),A,Math.sin(r.y*Constants.DEG2RAD),Math.cos(r.y*Constants.DEG2RAD),n,o,s,e,i,a,C)}}M=(M+1)%D}return h%2!==0}function increasing(t,n){return(t+360)%360<(n+360)%360?1:-1}export function meridionalIntersects(t,n,o,s,e,i,a,r,c,l,f,u,D,h,m,M,C,A,y){return 0!=meridionalIntersectionCount(t,n,o,s,e,i,a,r,c,l,f,u,D,h,m,M,C,A,y)}function meridionalIntersectionCount(t,n,o,s,e,i,a,r,c,l,f,u,D,h,m,M,C,A,y){const P=normalizeLon(a-t);D=normalizeLon(D);if(containsAngle(t,P,D))if(0===s&&0===l)return M<=0==y?increasing(t,a):0;else{const s=i*o;const l=i*n;const D=u*c;const M=u*r;const P=undefined;const d=undefined;const p=undefined;const x=A*m;const g=A*h;const E=-x;const L=-(l*D-s*M)*E/((l*f-M*e)*E- -(s*f-D*e)*g);const G=g/E;const R=Math.sqrt(1/(L*L*(1+G*G)+1));const Y=-L*R;const T=-G*Y;if(Y*x>=0&&T*g>=0)return R>=C==y?increasing(t,a):0;else if(Y*x<=0&&T*g<=0)return-R>=C==y?increasing(t,a):0}return 0}export function rhumblineAzimuth2D(t,n){const o=undefined;return rhumbLineDistanceAndAzimuth(t,n)[1]}export function rhumblineDistance(t,n){const o=undefined;return rhumbLineDistanceAndAzimuth(t,n)[0]}export function rhumbLineDistanceAndAzimuth(t,n){const o=t.x*Constants.DEG2RAD;const s=t.y*Constants.DEG2RAD;const e=n.x*Constants.DEG2RAD;const i=n.y*Constants.DEG2RAD;const a=(o-e)%(2*Math.PI);const r=(e-o)%(2*Math.PI);const c=Math.log(Math.tan(i/2+Math.PI/4)/Math.tan(s/2+Math.PI/4));let l;const f=i-s;if(Math.abs(f)<1e-6)l=Math.cos(s);else l=f/c;let u,D;if(a<r){u=Math.sqrt(l*l*a*a+f*f);D=Math.atan2(-a,c)%(2*Math.PI)}else{u=Math.sqrt(l*l*r*r+f*f);D=Math.atan2(r,c)%(2*Math.PI)}return[u*Constants.RAD2DEG,D]}function bufferContour2DOfSegmentSFCT(t,n,o,s){const e=forwardAzimuth2D(t,n)*Constants.RAD2DEG;greatCirclePointSFCT(t,o,e+90,s[0]);greatCirclePointSFCT(t,o,e-90,s[1]);const i=forwardAzimuth2D(n,t)*Constants.RAD2DEG;greatCirclePointSFCT(n,o,i+90,s[2]);greatCirclePointSFCT(n,o,i-90,s[3])}function allOnEquator(t,n,o,s){const e=1e-10;return Math.abs(t)<e&&Math.abs(n)<e&&Math.abs(o)<e&&Math.abs(s)<e}function allOnMeridian(t,n,o,s){const e=1e-10;const i=Math.abs(t-n);const a=Math.abs(o-s);const r=Math.abs(n-o);const c=Math.abs(t-s);return i<e&&a<e&&r<e&&c<e}function isEqual(t,n,o,s){const e=1e-10;return Math.abs(o-t)<e&&Math.abs(s-n)<e}function intersection2DLineSegmentsHelper(t,n,o,s,e,i,a,r,c,l,f,u,D,h,m,M,C,A,y,P,d,p,x,g,E,L,G,R,Y){const T=forwardAzimuth2DLL(t,e,i,a,f,u);const v=greatCircleDistanceLL(t,n,i,a,r,u);const b=forwardAzimuth2DLL(D,C,A,y,x,g);const X=greatCircleDistanceLL(D,h,A,y,P,g);const z=i*s;const S=i*o;const q=e;const I=u*l;const w=u*c;const O=f;const F=A*M;const j=A*m;const Z=C;const V=g*p;const U=g*d;const H=x;let K=S*f-w*e;let N=j*x-U*C;let W=-(z*f-I*e);let $=-(F*x-V*C);let _=-(S*I-z*w);let k=-(j*V-F*U);const B=1/Math.sqrt(K*K+W*W+_*_);const J=1/Math.sqrt(N*N+$*$+k*k);K*=B;W*=B;_*=B;N*=J;$*=J;k*=J;if(K*N<0||W*$<0||_*k<0){N=-N;$=-$;k=-k}const Q=1e-8;if(allOnEquator(n,r,h,P)||allOnMeridian(t,a,D,y)||Math.abs(N-K)<Q&&Math.abs($-W)<Q&&Math.abs(k-_)<Q){if(!E&&!L)return-1;const o=1e-13;const s=forwardAzimuth2DLL(t,e,i,D,C,A);const c=greatCircleDistanceLL(t,n,i,D,h,A);const l=Math.abs(s-T)<1e-8&&c<v+o;const m=forwardAzimuth2DLL(t,e,i,y,x,g);const M=greatCircleDistanceLL(t,n,i,y,P,g);const d=Math.abs(m-T)<1e-8&&M<v+o;if(l&&d){if(null!==G)G.move2D(D,h);if(null!==R)R.move2D(y,P);if(isEqual(D,h,y,P))return 1;return-1}const p=forwardAzimuth2DLL(D,C,A,t,e,i);const Y=c;const z=Math.abs(p-b)<1e-8&&Y<X+o;if(l&&z){if(null!==G)G.move2D(t,n);if(null!==R)R.move2D(D,h);if(isEqual(t,n,D,h))return 1;return-1}if(d&&z){if(null!==G)G.move2D(t,n);if(null!==R)R.move2D(y,P);if(isEqual(t,n,y,P))return 1;return-1}const S=forwardAzimuth2DLL(D,C,A,a,f,u);const q=greatCircleDistanceLL(D,h,A,a,r,u);const I=Math.abs(S-b)<1e-8&&q<X+o;if(I&&z){if(null!==G)G.move2D(t,n);if(null!==R)R.move2D(a,r);if(isEqual(t,n,a,r))return 1;return-1}if(I&&l){if(null!==G)G.move2D(a,r);if(null!==R)R.move2D(D,h);if(isEqual(a,r,D,h))return 1;return-1}if(I&&d){if(null!==G)G.move2D(a,r);if(null!==R)R.move2D(y,P);if(isEqual(a,r,y,P))return 1;return-1}if(z){if(null!==G)G.move2D(t,n);return 1}if(I){if(null!==G)G.move2D(a,r);return 1}if(l){if(null!==G)G.move2D(D,h);return 1}if(d){if(null!==G)G.move2D(y,P);return 1}return 0}const tt=_*$-W*k;const nt=_*N-K*k;const ot=K*$-W*N;const st=1/Math.sqrt(tt*tt+nt*nt+ot*ot);const et=tt*st;const it=-nt*st;const at=-ot*st;const rt=Math.sqrt(et*et+it*it);const ct=Math.atan2(it,et);const lt=Math.atan(at/rt);const ft=ct*Constants.RAD2DEG;const ut=lt*Constants.RAD2DEG;const Dt=Math.cos(lt);let ht=greatCircleDistanceLL(t,n,i,ft,ut,Dt);const mt=greatCircleDistanceLL(a,r,u,ft,ut,Dt);const Mt=greatCircleDistanceLL(D,h,A,ft,ut,Dt);const Ct=undefined;const At=1e-8;const yt=ht+mt<v+At;const Pt=Mt+greatCircleDistanceLL(y,P,g,ft,ut,Dt)<X+At;if(E&&yt&&Pt){if(isEqual(t,n,ft,ut)){if(null!==G)G.move2D(t,n);ht=0}else if(isEqual(a,r,ft,ut)){if(null!==G)G.move2D(a,r);ht=v}else if(isEqual(D,h,ft,ut)){if(null!==G)G.move2D(D,h)}else if(isEqual(y,P,ft,ut)){if(null!==G)G.move2D(y,P)}else if(null!==G)G.move2D(ft,ut);if(null!==Y)Y[0]=ht/v;return 1}const dt=Math.atan2(-it,-et);const pt=Math.atan(-at/rt);const xt=dt*Constants.RAD2DEG;const gt=pt*Constants.RAD2DEG;const Et=Math.cos(pt);let Lt=greatCircleDistanceLL(t,n,i,xt,gt,Et);const Gt=greatCircleDistanceLL(a,r,u,xt,gt,Et);const Rt=greatCircleDistanceLL(D,h,A,xt,gt,Et);const Yt=undefined;const Tt=Lt+Gt<v+At;const vt=Rt+greatCircleDistanceLL(y,P,g,xt,gt,Et)<X+At;if(E&&Tt&&vt){if(isEqual(t,n,xt,gt)){if(null!==G)G.move2D(t,n);Lt=0}else if(isEqual(a,r,xt,gt)){if(null!==G)G.move2D(a,r);Lt=v}else if(isEqual(D,h,xt,gt)){if(null!==G)G.move2D(D,h)}else if(isEqual(y,P,xt,gt)){if(null!==G)G.move2D(y,P)}else if(null!==G)G.move2D(xt,gt);if(null!==Y)Y[0]=Lt/v;return 1}if(!E){if(L){if(yt||Pt){if(null!==G)G.move2D(ft,ut);return 1}if(Tt||vt){if(null!==G)G.move2D(xt,gt);return 1}let t=Math.min(ht,Mt);let n=Math.min(Lt,Rt);t=Math.min(t,greatCircleDistanceLL(a,r,u,ft,ut,Dt));t=Math.min(t,greatCircleDistanceLL(y,P,g,ft,ut,Dt));n=Math.min(n,greatCircleDistanceLL(a,r,u,xt,gt,Et));n=Math.min(n,greatCircleDistanceLL(y,P,g,xt,gt,Et));if(Math.abs(n-t)>1e-8)if(t<n){if(null!==G)G.move2D(ft,ut);return 1}else{if(null!==G)G.move2D(xt,gt);return 1}}if(null!==G)G.move2D(ft,ut);if(null!==R)R.move2D(xt,gt);return 2}return 0}function intersection2DLineSegments(t,n,o,s,e,i,a,r,c){const l=t.x;const f=t.y;const u=n.x;const D=n.y;const h=o.x;const m=o.y;const M=s.x;const C=s.y;const A=cos(f);const y=sin(f);const P=cos(l);const d=sin(l);const p=cos(D);const x=sin(D);const g=cos(u);const E=sin(u);const L=cos(m);const G=sin(m);const R=cos(h);const Y=sin(h);const T=cos(C);const v=sin(C);const b=cos(M);const X=undefined;return intersection2DLineSegmentsHelper(l,f,d,P,y,A,u,D,E,g,x,p,h,m,Y,R,G,L,M,C,sin(M),b,v,T,e,i,a,r,c)}function cos(t){return Math.cos(t*Constants.DEG2RAD)}function sin(t){return Math.sin(t*Constants.DEG2RAD)}export function intersection2DLSSFCT(t,n,o,s,e){const i=intersection2DLineSegments(t,n,o,s,false,true,e,null,null);if(1!=i)throw new ProgrammingError(`Number of intersection points should be 1 instead of ${i}`)}export function bufferContour2DOf2DPolyline(t,n,o){const s=t.pointCount;const e=2*s;bufferContour2DOfSegmentSFCT(t.getPoint(0),t.getPoint(1),n,fTemp4XYPointArray2);o[0].move2D(fTemp4XYPointArray2[1].x,fTemp4XYPointArray2[1].y);o[e-1].move2D(fTemp4XYPointArray2[0].x,fTemp4XYPointArray2[0].y);for(let i=1;i<s-1;i++){fTemp4XYPointArray1[0].move2D(fTemp4XYPointArray2[0].x,fTemp4XYPointArray2[0].y);fTemp4XYPointArray1[1].move2D(fTemp4XYPointArray2[1].x,fTemp4XYPointArray2[1].y);fTemp4XYPointArray1[2].move2D(fTemp4XYPointArray2[2].x,fTemp4XYPointArray2[2].y);fTemp4XYPointArray1[3].move2D(fTemp4XYPointArray2[3].x,fTemp4XYPointArray2[3].y);bufferContour2DOfSegmentSFCT(t.getPoint(i),t.getPoint(i+1),n,fTemp4XYPointArray2);try{intersection2DLSSFCT(fTemp4XYPointArray1[1],fTemp4XYPointArray1[2],fTemp4XYPointArray2[1],fTemp4XYPointArray2[2],o[i])}catch(t){o[i].move2D(fTemp4XYPointArray1[2].x,fTemp4XYPointArray1[2].y)}try{intersection2DLSSFCT(fTemp4XYPointArray1[0],fTemp4XYPointArray1[3],fTemp4XYPointArray2[0],fTemp4XYPointArray2[3],o[e-i-1])}catch(t){o[e-i-1].move2D(fTemp4XYPointArray1[3].x,fTemp4XYPointArray1[3].y)}}o[s-1].move2D(fTemp4XYPointArray2[2].x,fTemp4XYPointArray2[2].y);o[s].move2D(fTemp4XYPointArray2[3].x,fTemp4XYPointArray2[3].y)}function sinY(t){return Math.sin(t.y*Constants.DEG2RAD)}function cosY(t){return Math.cos(t.y*Constants.DEG2RAD)}export function distanceToGeodesic(t,n,o,s){const e=(n.x-t.x)*Constants.DEG2RAD;const i=(o.x-n.x)*Constants.DEG2RAD;const a=(o.x-t.x)*Constants.DEG2RAD;let r=sinY(t)*sinY(n)+cosY(t)*cosY(n)*Math.cos(e);let c=sinY(n)*sinY(o)+cosY(n)*cosY(o)*Math.cos(i);const l=sinY(t)*sinY(o)+cosY(t)*cosY(o)*Math.cos(a);r=r>1?1:r<-1?-1:r;c=c>1?1:c<-1?-1:c;const f=Math.acos(r);const u=Math.acos(c);let D=(l-c*r)/(Math.sin(u)*Math.sin(f));D=D>1?1:D<-1?-1:D;const h=Math.acos(D);let m=Math.sin(u)*Math.sin(h)/Math.sin(s*Constants.DEG2RAD);m=m>1?1:m<-1?-1:m;return Constants.RAD2DEG*Math.asin(m)}export function isInsideInterval(t,n,o,s){t=normalizeLon(t);n=normalizeLon(n);if((o=normalizeLon(o))-n>180){n+=360;if(t<0)t+=360}else if(n-o>180){o+=360;if(t<0)t+=360}let e=n;let i=o;if(n>o){i=n;e=o}return t>e-s&&t<i+s}export function geodesicArea(t,n){return n*n*externalGeodesicArea(t,null)}