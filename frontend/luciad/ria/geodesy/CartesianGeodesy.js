import{ReferenceType}from"../reference/ReferenceType.js";import{ProgrammingError}from"../error/ProgrammingError.js";import{createTransformation}from"../transformation/TransformationFactory.js";import{Constants}from"../util/Constants.js";import{createPoint}from"../shape/ShapeFactory.js";import{ShapeType}from"../shape/ShapeType.js";import{area as CartesianArea,closestPointOnLine,distance2D,distance3D as cartesianDistance3D,forwardAzimuth2D}from"../util/Cartesian.js";export class CartesianGeodesy{constructor(e){this._reference=e;if(e.referenceType===ReferenceType.GRID)this._uom=e.unitOfMeasure;else if(e.referenceType===ReferenceType.GEOCENTRIC)this._uom=e.unitOfMeasure;else if(e.referenceType===ReferenceType.TOPOCENTRIC)this._uom=1;else if(e.referenceType===ReferenceType.CARTESIAN)this._uom=e.unitOfMeasure;else if(e.referenceType===ReferenceType.GEODETIC)this._uom=2*Math.PI*e.geodeticDatum.ellipsoid.auxRadius/360;else throw new ProgrammingError(`Unsupported reference type: ${e.referenceType}`)}get reference(){return this._reference}distance(e,r){const t=transform(e,this._reference);const n=transform(r,this._reference);return distance2D(t,n)*this._uom}distance3D(e,r){const t=transform(e,this._reference);const n=transform(r,this._reference);return cartesianDistance3D(t,n)*this._uom}forwardAzimuth(e,r){const t=transform(e,this._reference);const n=transform(r,this._reference);return Constants.RAD2DEG*forwardAzimuth2D(t,n)}interpolate(e,r,t){const n=transform(e,this._reference);if("number"===typeof r){if(r<0){r=-r;if(t>180)t-=180;else t=180+t}const e=r/this._uom;const s=Math.PI/2-Constants.DEG2RAD*t;return createPoint(this._reference,[n.x+Math.cos(s)*e,n.y+Math.sin(s)*e,n.z||0])}else{const e=transform(r,this._reference);const s=n.x;const o=n.y;const a=n.z||0;const i=e.x-s;const c=e.y-o;const f=(e.z||0)-a;return createPoint(this._reference,[s+t*i,o+t*c,a+t*f])}}shortestDistanceToLine(e,r,t,n,s){const o=transform(e,this._reference);const a=transform(r,this._reference);const i=transform(t,this._reference);const c=closestPointOnLine(o,a,i,n&&!!n.clipToSegment,s);transform(s,this._reference,s);return c.distance}area(e){if(e.reference?.referenceType==ReferenceType.GEOCENTRIC)throw new ProgrammingError("Calculating the 2D area of geocentric shapes is not supported");if(!ShapeType.contains(e.type,ShapeType.POLYGON))throw new ProgrammingError("Only the calculation of the area of a polygon is supported at the moment");return Math.abs(CartesianArea(e))}}function transform(e,r,t){const n=e._reference;if(null==n||r==n||r.equals(n)){t?.move3D(e);return t??e}else{const s=undefined;return createTransformation(n,r).transform(e,t)}}