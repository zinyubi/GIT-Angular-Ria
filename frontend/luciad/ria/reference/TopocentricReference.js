import{ProgrammingError}from"../error/ProgrammingError.js";import{getUnitOfMeasure}from"../uom/UnitOfMeasureRegistry.js";import{Hash}from"../util/Hash.js";import{Axis}from"./Axis.js";import{CoordinateType}from"./CoordinateType.js";import{ReferenceType}from"./ReferenceType.js";import{GeoReference}from"./GeoReference.js";import{GeodeticReference}from"./GeodeticReference.js";const meterUom=getUnitOfMeasure("Meter");export class TopocentricReference extends GeoReference{constructor(e){let r;if(!e.axisInformation)r=[{name:Axis.Name.X,axis:new Axis("X",Axis.Direction.EAST,meterUom,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Axis.RangeMeaning.EXACT)},{name:Axis.Name.Y,axis:new Axis("Y",Axis.Direction.NORTH,meterUom,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Axis.RangeMeaning.EXACT)},{name:Axis.Name.Z,axis:new Axis("Z",Axis.Direction.UP,meterUom,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Axis.RangeMeaning.EXACT)}];else r=e.axisInformation;if("object"!==typeof e.origin)throw new ProgrammingError("No origin specified for Topocentric reference.");if(!(e.origin.reference instanceof GeoReference))throw new ProgrammingError("Origin for Topocentric reference is not georeferenced.");if("object"!==typeof e.originLLH)throw new ProgrammingError("No geodetic origin specified for Topocentric reference.");if(!(e.originLLH.reference instanceof GeodeticReference))throw new ProgrammingError("Geodetic origin for Topocentric reference is not geodetic.");super({...e,geodeticDatum:e.origin.reference.geodeticDatum,name:e.name??"Topocentric reference",coordinateType:CoordinateType.CARTESIAN,referenceType:ReferenceType.TOPOCENTRIC,axisInformation:r});this._origin=e.origin;this._originLLH=e.originLLH;this._hash=0}equals(e){if(e===this)return true;if(e instanceof TopocentricReference)return this.geodeticDatum.equals(e.geodeticDatum)&&this.origin.equals(e.origin);else return false}copy(){return new TopocentricReference({name:this.name,origin:this.origin,originLLH:this.originLLH})}get origin(){return this._origin}get originLLH(){return this._originLLH}get TYPE(){return ReferenceType.TOPOCENTRIC}hashCode(e){if(0===this._hash){const e=new Hash;super.hashCode(e);this.origin.hashCode(e);this._hash=e.getHashCode()}e.appendUInt32(this._hash)}}