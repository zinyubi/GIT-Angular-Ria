import{AutoIncrement}from"../../view/feature/transformation/AutoIncrement.js";import{createOptimizedEventedSupport}from"../../util/EventedSupport.js";import{isValidFeatureId}from"../feature/Feature.js";import{isFunction}from"../../util/Lang.js";import{ProgrammingError}from"../../error/ProgrammingError.js";import{IterableCursor}from"./IterableCursor.js";export class MemoryStoreBase{constructor(){this._eventedSupport=createOptimizedEventedSupport(["StoreChanged"],true);this._keyGenerator=new AutoIncrement}on(e,r,t,i){let o;if(i&&isFunction(i.query)){const e=i.query;o=(t,i,o)=>{if(e(i))r.call(this,t,i,o)}}else o=r;return this._eventedSupport.on(e,o,t)}query(e){return new IterableCursor(this.getIterable(),isFunction(e)?e:void 0)}put(e){if(this.hasFeature(e))return this.internalUpdate(e);return this.internalAdd(e)}add(e){if(this.hasFeature(e))throw new ProgrammingError(`MemoryStore::add : the store already contains a Feature with ID ${e.id}.`);return this.internalAdd(e)}remove(e){const r=this.internalRemove(e);if(r)this._eventedSupport.emitStoreChangedEvent("remove",r,e);return!!r}reload(e){this.clear();e.forEach((e=>this.add(e)));return true}emit(e,...r){this._eventedSupport.emit(e,...r)}ensureValidFeatureId(e){if(isValidFeatureId(e.id))return;let r;do{r=this._keyGenerator.nextKey()}while(this.has(r));e.id=r}hasFeature(e){return!!e&&this.has(e.id)}}