import{Log}from"../../util/Log.js";import{ProgrammingError}from"../../error/ProgrammingError.js";import{createComplexPolygon,createPoint,createPolygon,createPolyline,createShapeList}from"../../shape/ShapeFactory.js";import{ShapeType}from"../../shape/ShapeType.js";import{parse,stringify}from"../../util/JSON.js";import{Feature,isValidFeatureId}from"../feature/Feature.js";import{ArrayCursor}from"../store/ArrayCursor.js";import{Codec}from"./Codec.js";import{GeoJsonUtil}from"./GeoJsonUtil.js";import{isPoint}from"../../shape/Point.js";import{isPolyline}from"../../shape/Polyline.js";import{isPolygon}from"../../shape/Polygon.js";import{isComplexPolygon}from"../../shape/ComplexPolygon.js";import{isArray,isBoolean,isDefined,isObject,isString}from"../../util/Lang.js";import{coordinate_equals}from"../../shape/PointCoordinate.js";import{getIdGenerator}from"../feature/FeatureIDProvider.js";import{isShapeList}from"../../shape/ShapeList.js";const applicationJsonMimeType="application/json";export class GeoJsonCodec extends Codec{constructor(e={}){super();const{swapAxes:o,mode3D:t,generateIDs:n,idProvider:r,reference:i,encodeShapeListAsGeometryCollection:s}=e;this._swapAxes=isArray(o)?o:[];this._includeHeight=true===t;this._generateIDs=isBoolean(n)?n:null;this._idGenerator=getIdGenerator(r);this._userReference=i;this._encodeShapeListAsGeometryCollection=!!s}get swapAxes(){return this._swapAxes}set swapAxes(e){this._swapAxes=e}get generateIDs(){return this._generateIDs}encodePoint({reference:e,x:o,y:t,z:n}){const r=shouldSwapAxes(e,this.swapAxes)?[t,o]:[o,t];if(this._includeHeight)r.push(n);return r}encodePointCoordinates(e,[o,t,n]){const r=shouldSwapAxes(e,this.swapAxes)?[t,o]:[o,t];if(this._includeHeight)r.push(n);return r}encodeLineStringCoordinates(e){const o=[];for(let t=0,n=e.pointCount;t<n;t++)o.push(this.encodePointCoordinates(e.reference,e.getPointCoordinates(t)));return o}encodePolygonCoordinates(e){const o=[];for(let t=0,n=e.pointCount;t<n;t++)o.push(this.encodePointCoordinates(e.reference,e.getPointCoordinates(t)));if(e.pointCount){const t=e.getPointCoordinates(0);const n=e.getPointCoordinates(e.pointCount-1);if(!coordinate_equals(t,n))o.push(this.encodePointCoordinates(e.reference,t))}return o}encodeComplexPolygonCoordinates(e){const o=[];for(let t=0,n=e.polygonCount;t<n;t++)o.push(this.encodePolygonCoordinates(e.getPolygon(t)));return o}encodePointGeometry(e){return{type:"Point",coordinates:this.encodePoint(e)}}encodeLineStringGeometry(e){return{type:"LineString",coordinates:this.encodeLineStringCoordinates(e)}}encodeMultiPointGeometry(e){const o=[];for(let t=0,n=e.shapeCount;t<n;t++){const n=e.getShape(t);o.push(this.encodePoint(n))}return{type:"MultiPoint",coordinates:o}}encodeMultiLineStringGeometry(e){const o=[];for(let t=0,n=e.shapeCount;t<n;t++)o.push(this.encodeLineStringCoordinates(e.getShape(t)));return{type:"MultiLineString",coordinates:o}}encodePolygonAsPolygonGeometry(e){return{type:"Polygon",coordinates:[this.encodePolygonCoordinates(e)]}}encodeComplexPolygonAsPolygonGeometry(e){return{type:"Polygon",coordinates:this.encodeComplexPolygonCoordinates(e)}}encodeMultiPolygonGeometry(e){const o=[];for(let t=0,n=e.shapeCount;t<n;t++){const n=e.getShape(t);if(isPolygon(n))o.push([this.encodePolygonCoordinates(n)]);else o.push(this.encodeComplexPolygonCoordinates(n))}return{type:"MultiPolygon",coordinates:o}}encodeGeometryCollectionGeometry(e){const o=[];for(let t=0,n=e.shapeCount;t<n;t++)o.push(this.encodeShape(e.getShape(t)));return{type:"GeometryCollection",geometries:o}}encodeShape(e){if(!e)return null;if(isPoint(e))return this.encodePointGeometry(e);if(isPolyline(e))return this.encodeLineStringGeometry(e);if(isPolygon(e))return this.encodePolygonAsPolygonGeometry(e);if(isComplexPolygon(e))return this.encodeComplexPolygonAsPolygonGeometry(e);if(isShapeList(e)){if(this._encodeShapeListAsGeometryCollection)return this.encodeGeometryCollectionGeometry(e);if(shapeListContainsOnlyShapes(e,[ShapeType.POINT]))return this.encodeMultiPointGeometry(e);if(shapeListContainsOnlyShapes(e,[ShapeType.POLYLINE]))return this.encodeMultiLineStringGeometry(e);if(shapeListContainsOnlyShapes(e,[ShapeType.POLYGON,ShapeType.COMPLEX_POLYGON]))return this.encodeMultiPolygonGeometry(e);return this.encodeGeometryCollectionGeometry(e)}throw new ProgrammingError("GeoJsonCodec:  trying to encode invalid Feature")}encode(e){if(e?.hasNext()){const o=e.next();let t;if(e.hasNext()){t={type:"FeatureCollection",features:[this.encodeSingleFeature(o)]};while(e.hasNext())t.features.push(this.encodeSingleFeature(e.next()))}else t=this.encodeSingleFeature(o);if(GeoJsonUtil.isDefaultReference(o)&&o.shape?.reference)t.crs=encodeReference(o.shape.reference);return convertToEncodingResult(t)}return{content:"",contentType:applicationJsonMimeType}}encodeSingleFeature(e){return{type:"Feature",properties:e.properties,id:e.id,geometry:this.encodeShape(e.shape)}}decode(e){this.checkDeprecatedOptions(e);const{content:o,reference:t=this._userReference}=e;if(!isString(o)&&!isObject(o))throw new ProgrammingError("GeoJsonCodec: expect to have a valid content");if(""===o)return new ArrayCursor([]);const n=isString(o)?parse(o):o;return this.decodeObject(n,{reference:t})}decodeObject(e,o){this.checkDeprecatedOptions(o);const t=o?.reference||this._userReference;const n=GeoJsonUtil.determineReference(e,t);let r;if(isArray(e.features))r=e.features;else r=!isArray(e)?[e]:e;const i=new ArrayCursor(r);const s=this;let c=false;return{hasNext:function(){return i.hasNext()},next:function(){const e=i.next();const o=s.decodeSingleFeature(e,n);a(o,s._generateIDs,s._idGenerator);if(!isValidFeatureId(o.id))throw new ProgrammingError("GeoJsonCodec: expect features to have an id");return o}};function a(e,o,t){if(true===o)e.id=t(e);else if(!isValidFeatureId(e.id))if(false===o)d("Decoded Feature has no ID. ID will NOT be auto-generated (generateIDs set to false)");else{d("Decoded Feature has no ID. ID will be auto-generated");e.id=t(e)}}function d(e){if(!c){c=true;Log.warn(e)}}}decodeGeometryCollection(e,o){const t=createShapeList(o);for(let n=0,r=e.geometries.length;n<r;n++){const r=this.decodeGeometryObject(e.geometries[n],o);if(r)t.addShape(r)}return t}decodeGeometry(e,o){const t=isString(e)?parse(e):e;return this.decodeGeometryObject(t,o)}decodeGeometryObject(e,o){if(!e)return null;const{type:t}=e;if("GeometryCollection"!==t&&shouldSwapAxes(o,this.swapAxes))GeoJsonUtil.reverseAxes(e);if("Point"===t)return decodePoint(e,o);else if("MultiPoint"===t)return decodeMultiPoint(e,o);else if("LineString"===t)return decodeLineString(e,o);else if("MultiLineString"===t)return decodeMultiLineString(e,o);else if("Polygon"===t)return decodePolygon(e,o);else if("MultiPolygon"===t)return decodeMultiPolygon(e,o);else if("GeometryCollection"===t)return this.decodeGeometryCollection(e,o);else throw new ProgrammingError(`GeoJsonCodecImpl: did not recognize geometry type '${t}'`)}decodeSingleFeature(e,o){const t=e.properties||void 0;const n=isValidFeatureId(e.id)?e.id:void 0;if("Feature"!==e.type)throw new ProgrammingError(`Expected a 'Feature' to decode, ${e.type} is not supported`);const r=e.geometry?this.decodeGeometryObject(e.geometry,o):null;return new Feature(r,t,n)}checkDeprecatedOptions(e){if(e&&isDefined(e.reverseAxes)){Log.warn("The 'reverseAxes' option is deprecated in GeoJsonCodecImpl.decode() and GeoJsonCodecImpl.decodeObject(). "+"Please use instead the 'swapAxes' option in the GeoJsonCodecImpl constructor!");this.swapAxes=["*"]}}}function convertToEncodingResult(e){return{content:stringify(e),contentType:applicationJsonMimeType}}function shapeListContainsOnlyShapes(e,o){let t=true;for(let n=0,r=e.shapeCount;n<r&&t;n++){const r=e.getShape(n);t=o.some((e=>r.type===e))}return t}function decodePolygon(e,o){const t=e.coordinates.length;if(1===t)return decodeRing(e.coordinates[0],o);else{const n=createComplexPolygon(o);for(let r=0;r<t;r++)n.addPolygon(decodeRing(e.coordinates[r],o));return n}}function decodeMultiPolygon(e,o){const t=createShapeList(o);const n=e.coordinates.length;for(let r=0;r<n;r++){let n;if(1===e.coordinates[r].length)n=decodeRing(e.coordinates[r][0],o);else{n=createComplexPolygon(o);const t=e.coordinates[r].length;for(let i=0;i<t;i++)n.addPolygon(decodeRing(e.coordinates[r][i],o))}t.addShape(n)}return t}function decodePoint(e,o){return createPoint(o,e.coordinates)}function decodeMultiPoint(e,o){const t=createShapeList(o);const n=e.coordinates.length;for(let r=0;r<n;r++)t.addShape(createPoint(o,e.coordinates[r]));return t}function decodeLineString(e,o){return createPolyline(o,e.coordinates)}function decodeMultiLineString(e,o){const t=createShapeList(o);const n=e.coordinates.length;for(let r=0;r<n;r++)t.addShape(createPolyline(o,e.coordinates[r]));return t}function decodeRing(e,o){const t=e.length;if(t>2&&coordinate_equals(e[0],e[t-1]))e.pop();return createPolygon(o,e)}function shouldSwapAxes(e,o){return!!e&&(o.indexOf(e.identifier)>=0||o.indexOf("*")>=0)}function encodeReference(e){return{type:"name",properties:{name:e.identifier}}}