import { Feature } from "../feature/Feature.js";
import { Codec, CodecDecodeOptions, EncodeResult } from "./Codec.js";
import { Shape } from "../../shape/Shape.js";
import { Cursor } from "../Cursor.js";
import { CoordinateReference } from "../../reference/CoordinateReference.js";
import { FeatureIDProvider } from "../feature/FeatureIDProvider.js";
/**
 * Constructor options for {@link GeoJsonCodec}.
 */
export interface GeoJsonCodecConstructorOptions {
  /**
   * Setting this property to <code>true</code> will encode
   * {@link Shape} instances as 3D GeoJSON geometry and decode GeoJSON
   * geometries as 3D Shapes. If LuciadRIA {@link Point} instances have no
   * z coordinate, 0 will be included as a third value in a GeoJSON position.
   * If GeoJSON positions have a third value, it will be set as the z-coordinate in the
   * LuciadRIA {@link Point}.
   * @default false
   */
  mode3D?: boolean;
  /**
   * When <code>true</code>, the codec will always generate IDs during the
   * decoding step for all the Features. When the Feature has already an ID,
   * the existing ID will be replaced by a generated one.
   * Feature IDs are provided by the {@link GeoJsonCodecConstructorOptions.idProvider} mechanism,
   * or otherwise they are auto-generated by the internal ID generator.<br/>
   * When <code>false</code>, the codec will never generate IDs. The codec will throw
   * an error whenever a Feature without ID is encountered. <br/>
   * When the flag is not set, or is set to <code>null</code>,
   * the codec will generate IDs only for those Features that are without IDs.
   */
  generateIDs?: boolean | null;
  /**
   * Defines a custom callback function to provide IDs for decoded features that come without IDs.
   * The mechanism takes into account the {@link GeoJsonCodecConstructorOptions.generateIDs} property.
   * This callback is invoked by LuciadRIA with a decoded feature for which the ID should be returned.
   * When the provided ID is invalid, the feature ID will be auto-generated.<br/>
   *
   * Note: Having features in LuciadRIA with stable IDs that do not change on each query request
   * is important for performance. For example, when features do not have intrinsic IDs on each query request,
   * instead of adding/removing only the relevant features, all the existing features are removed, and all the new ones are added.
   *
   * ```typescript
   * // GeoJsonCodec will use IDs from a feature property.
   * const codec = new GeoJsonCodec({ idProvider: (feature: Feature) => feature.properties.id });
   * ```
   * @since 2021.0
   */
  idProvider?: FeatureIDProvider;
  /**
   * Indicates whether the codec should swap the x and y axes for the specified
   * reference identifier(s) when decoding or encoding features in the GeoJSON format.
   * Normally, the axes should always be in x,y[,z] order in GeoJSON, but not all servers
   * follow this rule (depending on the reference system).
   */
  swapAxes?: string[];
  /**
   * Defines the {@link CoordinateReference} for {@link Feature.shape} when decoding GeoJSON data.
   * It's crucial that the reference specified for your {@link FeatureModel} aligns with the reference for this codec.
   * Note that setting this property does not perform any coordinate transformations.
   * Instead, it takes the provided GeoJSON data and decodes it directly into features using the assigned reference.
   * @since 2022.0
   */
  reference?: CoordinateReference;
  /**
   * <p>The property defines how a LuciadRIA {@link ShapeList} instance should be encoded to the GeoJson format.
   * By default, a LuciadRIA {@link ShapeList} instance is encoded to a specific GeoJson geometry,
   * depending on its children:</p>
   * <ul>
   *  <li>if all children are {@link Point} instances -> MultiPoint </li>
   *  <li>if all children are {@link Polyline} instances -> MultiLineString </li>
   *  <li>if all children are {@link ComplexPolygon} instances -> MultiPolygons </li>
   *  <li>otherwise -> GeometryCollection </li>
   * </ul>
   * Set the value to 'true' if you want to encode a LuciadRIA {@link ShapeList} always as a GeometryCollection.
   * @since 2022.0.1
   */
  encodeShapeListAsGeometryCollection?: boolean;
}
/**
 * Options for {@link GeoJsonCodec.decodeObject}
 * @since 2023.1
 */
export interface DecodeObjectOptions {
  /**
   * Defines the spatial reference for the {@link Feature} instances.
   * If specified, this reference overrides the default reference set in the codec.
   */
  reference?: CoordinateReference;
}
/**
 * A GeoJsonCodec is responsible for main tasks:
 * <ul>
 *   <li>
 *     <p>
 *       Encoding {@link Feature} instances into a JavaScript object that adheres to the GeoJSON specification
 *       The codec encodes the shape of the feature to GeoJSON geometries as follows:
 *     </p>
 *     <ul>
 *       <li>{@link Point} {@link Polyline} and {@link Polygon} instances are mapped to GeoJSON Points, LineStrings, and Polygons respectively.</li>
 *       <li>{@link ComplexPolygon} instances are all mapped to GeoJSON Polygons.</li>
 *       <li>A LuciadRIA feature without a shape is encoded into a GeoJSON feature without a geometry</li>
 *       <li>{@link ShapeList} is always mapped to a GeoJSON GeometryCollection when
 *           {@link GeoJsonCodecConstructorOptions.encodeShapeListAsGeometryCollection} is set to 'true'.
 *           <p>Otherwise {@link ShapeList} is mapped based on its contents:</p>
 *           <ul>
 *             <li>{@link Point} and {@link Polyline} instances are mapped to GeoJSON MultiPoint and MultiLineString geometries respectively.</li>
 *             <li>{@link Polygon} and {@link ComplexPolygon} instances are mapped to GeoJSON MultiPolygon.</li>
 *             <li>{@link ShapeList} that contains an arbitrary mix of shapes is mapped to GeoJSON GeometryCollections.</li>
 *           </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li>
 *     <p>
 *       Decoding a GeoJSON JavaScript object into a set of LuciadRIA {@link Feature} instances,
 *       each containing corresponding LuciadRIA geometries and properties.
 *     </p>
 *     <p>
 *       Since there's no direct mapping from a GeoJSON geometry to a LuciadRIA shape,
 *       the codec decodes GeoJSON geometries as follows:
 *     </p>
 *     <ul>
 *       <li>GeoJSON Points, LineStrings, and single ring Polygons are mapped to LuciadRIA
 *           {@link Point}, {@link Polyline}, and {@link Polygon} instances respectively.
 *       </li>
 *       <li>A GeoJSON single multi ring Polygon is mapped to {@link ComplexPolygon}.</li>
 *       <li>MultiPoints, MultiLineStrings, MultiPolygons are all mapped to a {@link ShapeList}
 *           of {@link Point}, {@link Polyline}, and {@link Polygon} instances respectively.</li>
 *       <li>GeometryCollections are mapped to {@link ShapeList} instances.</li>
 *       <li>A <code>null</code> geometry translates into a {@link Feature} with a null shape.</li>
 *     </ul>
 *     <p>
 *       Note: According to the GeoJSON specification, the first and last position of a GeoJSON polygon must be equivalent.
 *       The codec removes this duplicate point when decoding the GeoJSON polygon to a LuciadRIA geometry.
 *     </p>
 *   </li>
 * </ul>
 * <h3>Spatial reference</h3>
 * <p>
 *   The reference used during the shape decoding process is determined in the following order:
 *   <ul>
 *     <li>
 *       The reference supplied to the {@link decode} method.
 *       This can be used if you need to override the reference for a specific decode request.
 *     </li>
 *     <li>
 *       The reference supplied to the constructor. This can be used to set a consistent reference across all decoding.
 *       Note that this can still be overridden on a per-request basis via the {@link decode}
 *     </li>
 *     <li>
 *       The reference specified in the data using the legacy <code>crs</code> field.
 *       This will be used if no reference is provided in either of the first two steps.
 *     </li>
 *     <li>
 *       If no reference is specified in any of the above methods,
 *       the default WGS:84 reference from the GeoJSON specification is used.
 *     </li>
 *   </ul>
 * </p>
 * <h3>Limitations</h3>
 * <p>
 *   GeoJSON does not support any other shapes than <code>Point</code>, <code>LineString</code>, <code>Polygon</code>,
 *   <code>MultiPoint</code>, <code>MultiLineString</code>, <code>MultiPolygon</code>, <code>GeometryCollection</code>.
 *   Therefore, it cannot support all LuciadRIA shapes. For instance, a {@link Circle} cannot be directly
 *   represented as a circle in GeoJSON.
 *   Handling such shapes requires a custom codec, as demonstrated in the CreateEdit sample.
 * </p>
 *
 * @typeParam TFeature Represents the type of {@link Feature} instances that are handled by the codec.
 *            Default type is {@link Feature} without restrictions on shape and properties.
 */
export declare class GeoJsonCodec<TFeature extends Feature = Feature> extends Codec<TFeature> {
  /**
   * Creates a GeoJSON codec. By default, a GeoJSON codec decodes 2D geometry, which means the z coordinates
   * of points (which usually contain height) are ignored. If the z coordinates must be encoded or decoded
   * as well, pass <code>true</code> to the <code>mode3D</code> property in the <code>options</code> object.
   * @param options an object literal that contains configuration settings for the codec.
   */
  constructor(options?: GeoJsonCodecConstructorOptions);
  /**
   * Encodes a LuciadRIA {@link Shape} into a valid GeoJSON geometry.
   * @param shape A {@link Shape} to be encoded into GeoJSON.
   * @return the GeoJSON representation of the shape (as an object, not as a string)
   */
  encodeShape(shape: Shape | null): any | null;
  /**
   * Encodes {@link Feature} instances into GeoJSON.
   * This method delegates to {@link GeoJsonCodec.encodeShape}.
   * @param featureCursor A {@link Feature} to be encoded into GeoJSON.
   * @return An object containing two properties:
   * <ul>
   *   <li><code>content</code>: The encoded content as a <code>string</code>. This is valid GeoJSON.</li>
   *   <li><code>contentType</code>: The MIME type as a <code>string</code>. It equals "<code>application/json</code>".</li>
   * </ul>
   */
  encode(featureCursor: Cursor<TFeature>): EncodeResult;
  /**
   * <p>
   *   Decodes the server response, which is valid GeoJSON, into {@link Feature} instances.
   *   This method delegates to {@link GeoJsonCodec.decodeGeometryObject}.
   * </p>
   * <p>
   *   A {@link Store.query} invocation, passing the <code>options</code> parameter containing the data to decode.
   *   If the {@link CodecDecodeOptions.reference} option is present, the decoded features' shapes are encoded with this reference.
   * </p>
   * @param options the decoding options
   * @return featureCursor of {@link Feature} instances corresponding to the server response.
   */
  decode(options: CodecDecodeOptions): Cursor<TFeature>;
  /**
   * Decodes a valid GeoJSON object into a {@link Cursor}.
   * @param object a GeoJSON object to be decoded
   * @param options an options object literal
   * @return featureCursor A {@link Cursor} corresponding to the decoded GeoJSON object.
   */
  decodeObject(object: any, options?: DecodeObjectOptions): Cursor<TFeature>;
  /**
   * Decodes a GeoJSON geometry string into a {@link Shape} or null.
   * @param geometry The string representation of a GeoJSON geometry.
   * @param reference The spatial reference in which the <code>geometry</code> is defined.
   * @return The corresponding LuciadRIA {@link Shape} or null.
   * @throws {@link ProgrammingError} If the input is not a valid GeoJSON geometry.
   */
  decodeGeometry(geometry: string, reference: CoordinateReference): Shape | null;
  /**
   * Decodes a GeoJSON geometry object into a {@link Shape} or null.
   * @param geometry A GeoJSON geometry object, represented as a JSON object.
   * @param reference The spatial reference in which the <code>geometry</code> is defined.
   * @return The corresponding LuciadRIA {@link Shape} or null.
   * @throws {@link ProgrammingError} If the input is not a valid GeoJSON geometry object.
   */
  decodeGeometryObject(geometry: any, reference: CoordinateReference): Shape | null;
}