import{ProgrammingError}from"../../error/ProgrammingError.js";import{Photon}from"../../gen/photon/photon_painter.js";import{getReference,parseWellKnownText}from"../../reference/ReferenceProvider.js";import{OrientedBox}from"../../shape/OrientedBox.js";import{Constants}from"../../util/Constants.js";import{WithHttpRequestOptions}from"../../util/WithHttpRequestOptions.js";import{URL as RIAUrl}from"../../util/URL.js";import{addHttpRequestOptions}from"../../util/HttpRequestOptions.js";import{request}from"../../util/request.js";import{Log}from"../../util/Log.js";import{isUndefined}from"../../util/Lang.js";import{releaseObject}from"../../util/ObjectReleaseTracker.js";import{createGLTFBufferLoader}from"../../geometry/mesh/GLTFBufferLoader.js";import{EventedSupport}from"../../util/EventedSupport.js";const REF_EPSG_4978=getReference("EPSG:4978");const REF_LUCIAD_XYZ=getReference("LUCIAD:XYZ");const INVALIDATED_EVENT_NAME="Invalidated";class RangeRequestCallback extends Photon.RiaRangeRequestInterface{constructor(e,t,r){super();this._onDataReceived=e=>{};this._requestHeaders=e;this._credentials=t;this._url=r;this._treeHSPCPromise=new Promise(((e,t)=>{this._onDataReceived=e}))}request(e,t){const r={...this._requestHeaders,Range:`bytes=${e}-${t}`};const s=addHttpRequestOptions({},{credentials:this._credentials,requestHeaders:r});request(this._url,s).then((e=>this._onDataReceived(e.arrayBuffer())))}whenDataReceived(){return this._treeHSPCPromise}}export class TileSet3DModelSupport{_eventSupport=new EventedSupport([INVALIDATED_EVENT_NAME],true);constructor(e,t){if(!e.url)throw new ProgrammingError("You must specify a URL.");if(!e.orientedBox)throw new ProgrammingError("Oriented box not specified .");this._httpSupport=new WithHttpRequestOptions(e);this._modelDescriptor=t;this._url=e.url;this._urlParams=getUrlParametersString(e.url);this._requestParameters=RIAUrl.parseQueryString(this._urlParams);this._reference=e.reference;this._orientedBox=e.orientedBox;this._requestParameters=Object.assign(this._requestParameters,e.requestParameters);this._firstBytes=e.firstBytes;this._isPackFile=e.isPackFile}invalidate(){this._eventSupport.emit(INVALIDATED_EVENT_NAME)}on(e,t,r){return this._eventSupport.on(e,t,r)}get credentials(){return this._httpSupport.credentials}set credentials(e){this._httpSupport.credentials=e}get firstBytes(){return this._firstBytes}get isPackFile(){return this._isPackFile}get requestHeaders(){return this._httpSupport.requestHeaders}set requestHeaders(e){this._httpSupport.requestHeaders=e}addHttpRequestOptions(e){return this._httpSupport.addHttpRequestOptions(e)}get url(){return this._url}get urlParams(){return this._urlParams}get bounds(){return this._orientedBox.bounds}get requestParameters(){return this._requestParameters}set requestParameters(e){this._requestParameters=e}get orientedBox(){return this._orientedBox.copy()}get coordinateType(){return this._reference.coordinateType}get reference(){return this._reference}get modelDescriptor(){return this._modelDescriptor}static async open(e,t,r){if(!e)return Promise.reject(new ProgrammingError("URL must be specified."));r=r||{};const s=new URLSearchParams(window.location.search).get("lcd_credentials");const n=s?"true"===s.toLowerCase():false;const o=!isUndefined(r.credentials)?r.credentials:n;const a=!isUndefined(r.requestHeaders)?r.requestHeaders:null;let i=!isUndefined(r.requestParameters)?r.requestParameters:null;let u=e;if(e.includes("?")){const t=RIAUrl.parseQueryString(e.split("?")[1]);i={...i,...t}}e=new window.URL(e,window.location.href).href;if(i){u=e.split("?")[0];e=u+"?"+RIAUrl.buildQueryString(i)}const c={...a};const l=isUrlPackFile(u);let d;const f=40;if(l)c.Range=`bytes=0-${f-1}`;const p=addHttpRequestOptions({},{credentials:o,requestHeaders:c});const h=await request(e,p);await Photon.whenReady();let m=await h.arrayBuffer();if(l){const t=new RangeRequestCallback(a,o,e);const r=Photon.RiaHspcPackFileParser.create(t);const s=Photon.BufferFactory.createUint8BufferFromData(new Uint8Array(m));p.headers={...p.headers,Range:`bytes=0-${r.getHeaderSize(s)-1}`};s.release();const n=await request(e,p);d=await n.arrayBuffer();const i=Photon.BufferFactory.createUint8BufferFromData(new Uint8Array(d));const u=r.open(i);i.release();if(!u)throw new Error("Could not decode "+e+" as an HSPC pack file");r.request("/tree.hspc");m=await t.whenDataReceived();t.release();r.release()}let g;const P=new Uint8Array(m);let _;try{_=Photon.BufferFactory.createUint8BufferFromData(P);g=JSON.parse(Photon.ScenePainterWrapper.getDatasetMetadata(_))}catch(r){Log.error(t+"Could not parse metadata information for "+e);throw r}finally{_?.release()}let y=r.reference??resolveReference(t,g.epsg,g.wkt);const R=createOrientedBoxFromMetadata(g);if(!R)throw new ProgrammingError("Could not decode model: Bounds could not be parsed.");if(!y){if("HSPCTilesModel"==t)y=REF_LUCIAD_XYZ;else y=this.findReferenceFromBound(R.bounds);Log.warn(t+" doesn't contain any reference. "+y.name+" will be used.")}let w={dataType:"",hasNormalData:"false"};if("HSPCTilesModel"===t)w={dataType:"PointCloud",hasNormalData:g.hasNormal?"true":"false"};else if("OGC3DTilesModel"===t){w={dataType:"",hasNormalData:"true"};if(g.rootContentUrl){const r=Photon.Ogc3DTilesDataParser.create();let s=e.split(".json")[0];s=s.substring(0,e.lastIndexOf("/")+1);let n=r.getContentUrl(s,g.rootContentUrl);if(i)n=n+"?"+RIAUrl.buildQueryString(i);const u=addHttpRequestOptions({},{credentials:o,requestHeaders:a});const c=await fetch(n,u);if(c.ok){const i=await c.arrayBuffer();const u=new Uint8Array(i);const l=createGLTFBufferLoader(Photon,s,{credentials:o,requestHeaders:a});let d;try{d=Photon.BufferFactory.createUint8BufferFromData(u);w=JSON.parse(r.getContentInformation(d,l,e))}catch(r){Log.warn(t+"Could not parse content metadata information for "+e+" - Used "+n)}finally{releaseObject(d)}releaseObject(l)}else Log.warn(t+"Could not parse content metadata information for "+e+" - Used "+n);releaseObject(r)}}return{url:e,orientedBox:new OrientedBox(y,R.getCorners()),reference:y,credentials:o,metadata:g,requestHeaders:a,requestParameters:i,firstBytes:d,isPackFile:l,hasPointCloud:"PointCloud"==w.dataType,hasMesh:"Mesh"==w.dataType,hasNormalData:"true"==w.hasNormalData}}static findReferenceFromBound(e){return Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z)>.5*Constants.EARTH_RADIUS?REF_EPSG_4978:REF_LUCIAD_XYZ}}function isUrlPackFile(e){const t=undefined;return new RegExp(/^.*((.pack)|(.pak))\/?$/).test(e)}function getUrlParametersString(e){const t=e.indexOf("?");return-1===t?"":e.substring(t+1)}function createOrientedBoxFromMetadata(e){const t=[];if(!e.frustum||!e.frustum.length)return null;for(let r=0;r<e.frustum.length/3;r++)t.push({x:e.frustum[3*r],y:e.frustum[3*r+1],z:e.frustum[3*r+2]});if(t.length>0)return new OrientedBox(null,t);return null}export function createOrientedBoxFromBounds(e){const t=undefined;const r=[{x:0,y:0,z:0},{x:1,y:0,z:0},{x:0,y:1,z:0},{x:1,y:1,z:0},{x:0,y:0,z:1},{x:1,y:0,z:1},{x:0,y:1,z:1},{x:1,y:1,z:1}].map((t=>({x:e.x+t.x*e.width,y:e.y+t.y*e.height,z:e.z+t.z*e.depth})));return new OrientedBox(e.reference,r)}function resolveReference(e,t,r){let s;if(t)s=getReference(t);else if(r)try{s=parseWellKnownText(r)}catch(t){Log.error(e+" with unknown WKT "+r)}if(s&&!s.equals(getReference("EPSG:4978")))Log.warn(e+" with reference "+(t||r)+" is supported, but it is"+" recommended to process your data into EPSG:4978 (3D geocentric coordinates).");return s}