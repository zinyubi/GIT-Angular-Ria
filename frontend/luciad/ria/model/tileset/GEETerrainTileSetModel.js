import{getReference}from"../../reference/ReferenceProvider.js";import{createBounds,createPoint}from"../../shape/ShapeFactory.js";import{isUndefined}from"../../util/Lang.js";import{LRUCache}from"../../util/LRUCache.js";import{request}from"../../util/request.js";import{isQuadtreeCacheEntryValid}from"../google/GEEQuadTreeCache.js";import{tileToGEEString}from"./GEETileSetUtil.js";import{RasterDataType}from"./RasterDataType.js";import{RasterSamplingMode}from"./RasterSamplingMode.js";import{getTileBounds}from"./TileCoordinateUtil.js";import{UrlTileSetModel}from"./UrlTileSetModel.js";const FLATTEN_TILES_BELOW_LEVEL=8;function key(e,t,i){return`${e}#${t}#${i}`}export class GEETerrainTileSetModel extends UrlTileSetModel{constructor(e){const t=getReference("EPSG:4326");const i=undefined;super({structure:{reference:t,bounds:createBounds(t,[-180,360,-90,180]),levelCount:25,level0Columns:2,level0Rows:1,tileWidth:32,tileHeight:32},baseURL:e.baseURL,elevation:true,samplingMode:RasterSamplingMode.POINT,dataType:RasterDataType.TIN_ELEVATION,credentials:false});this._tileCache=new LRUCache(256);this._pendingTiles=new Map;this._webWorkerPool="fillMeIn";this._quadTreeCache=e.quadTreeCache}getMesh(e,t,i,r){const s=this._tileCache.get(key(e.x,e.y,e.level));if(s){t({mesh:s,tile:e});return Promise.resolve()}if(e.level<FLATTEN_TILES_BELOW_LEVEL){const i=this.createFlatMesh(e);this._tileCache.put(key(e.x,e.y,e.level),i);t({mesh:i,tile:e});return Promise.resolve()}const n=s=>{const n=this.getTileURL(this.baseURL,e,s);if(1!==this.addPendingTile(n,e,t,i))return Promise.resolve();return request(n,{signal:r}).then((e=>e.arrayBuffer())).then((t=>this._webWorkerPool.enqueue({command:"decodeGEETerrain",data:t},[t]).then((t=>{const i=t;const r=getTerrainTileCoordinate(e);const s=r.x<<1;const l=r.y<<1;const o=r.level+1;let a=i.slice(0,4);this.cacheQuads(r,a);a=i.slice(4,8);this.cacheQuads({x:s,y:l,level:o},a);a=i.slice(8,12);this.cacheQuads({x:s+2,y:l,level:o},a);a=i.slice(12,16);this.cacheQuads({x:s+2,y:l+2,level:o},a);a=i.slice(16,20);this.cacheQuads({x:s,y:l+2,level:o},a);return this.resolveTileUrl(n)})))).catch((()=>this.rejectTileUrl(n,"Could not decode terrain tile from the server")))};return this.getTerrainVersion(e,n,i)}getTerrainVersion(e,t,i){const r=this.getTileGeeString(e);const s=this._quadTreeCache.getQuadTreeNode(r);if(isQuadtreeCacheEntryValid(s))return Promise.resolve(s).then((e=>isQuadtreeCacheEntryValid(e)&&e?.hasTerrainData?t(e.terrainVersion):i("No Terrain Data")),i);if(!this._quadTreeCache.isValid(r)){i(`Invalid quadTreeString: ${r}`);return Promise.resolve()}const n=()=>this.getTerrainVersion(e,t,i);return this._quadTreeCache.requestMissingMetadata(r,i).then((()=>this._quadTreeCache.metadataReady(e,r,n,i)))}getTileURL(e,t,i=1){return`${e}/flatfile?f1c-0${this.getTileGeeString(t)}-t.${i}`}createFlatMesh(e){const t=16;const i=t+1;const r=getTileBounds(this,e);const s=r.width;const n=r.height;const l=new Array(3*i**2);const o=new Array(t**2);for(let e=0;e<=t;e++)for(let r=0;r<=t;r++){const a=e*i+(r+1);const c=3*(a-1);l[c]=e*s/t;l[c+1]=r*n/t;l[c+2]=0;if(e!==t&&r!==t){const s=6*(e*t+r);o[s]=a-1;o[s+1]=a+i;o[s+2]=a;o[s+3]=a-1;o[s+4]=a+i-1;o[s+5]=a+i}}return{origin:createPoint(this.reference,[r.x,r.y,0]),minimumElevation:0,maximumElevation:0,averageElevation:0,vertices:l,faces:o,width:s,height:n}}resolveTileUrl(e){const t=this._pendingTiles.get(e);this._pendingTiles.delete(e);t?.forEach((({tile:e,resolve:t,reject:i})=>{const r=this._tileCache.get(key(e.x,e.y,e.level));return isUndefined(r)?i("Tile not available from the server"):t({mesh:r,tile:e})}))}rejectTileUrl(e,t){const i=this._pendingTiles.get(e);this._pendingTiles.delete(e);i?.forEach((({reject:e})=>e(t)))}addPendingTile(e,t,i,r){const s=this._pendingTiles.get(e);if(s)return s.push({tile:t,resolve:i,reject:r});this._pendingTiles.set(e,[{tile:t,resolve:i,reject:r}]);return 1}getTileGeeString(e){const t=1+(1&e.level);const i=this.getTileRowCount(e.level)??0;const r=0!==e.level?i-e.y-1+(i>>1):e.y;const s=e.x>>t;const n=r>>t;const l=e.level-t;return tileToGEEString(s,n,l)}cacheQuads(e,t){const i=e.x;const r=e.y;const s=e.level;this._tileCache.put(key(i,r,s),t[0]);this._tileCache.put(key(i+1,r,s),t[1]);this._tileCache.put(key(i+1,r+1,s),t[2]);this._tileCache.put(key(i,r+1,s),t[3])}}function getTerrainTileCoordinate(e){const t=1&e.level;const i=~1;return{x:e.x>>t&i,y:e.y>>t&i,level:e.level-t}}