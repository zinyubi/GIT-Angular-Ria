import{Constants}from"../util/Constants.js";import{Hash}from"../util/Hash.js";import{normalizeLon}from"../util/LonLatCoord.js";import{OutOfBoundsError}from"../error/OutOfBoundsError.js";import{ProjectionType}from"./ProjectionType.js";import{Cylindrical}from"./Cylindrical.js";const sharedOutOfBoundsError=new OutOfBoundsError("Mollweide");const SQRT2=Math.sqrt(2);const SQRT8=Math.sqrt(8);const THETA_TOLERANCE=1e-10;export class Mollweide extends Cylindrical{constructor(t=0){super();this._hash=0;this.setCentralMeridian(t);this.calculateCachedValues()}isAllInBounds(){return false}geodetic2cartesianOnSphereSFCT(t,n,s){const e=this.calculateTheta(t.y*Constants.DEG2RAD);const o=normalizeLon(t.x-this.getCentralMeridian())*Constants.DEG2RAD;const a=SQRT8/Math.PI;const r=SQRT2;s.x=a*n*o*Math.cos(e);s.y=r*n*Math.sin(e)}calculateTheta(t){const n=Math.PI*Math.sin(t);let s=t;const e=1e-12;let o;const a=30;let r=0;do{const t=undefined;const e=undefined;o=-(s+Math.sin(s)-n)/(1+Math.cos(s));s+=o;r++}while(Math.abs(o)>e&&r<a);return s/2}cartesian2geodeticOnSphereSFCT(t,n,s){const e=t.x/n;const o=t.y/n;const a=SQRT2;if(o<-SQRT2||o>SQRT2)throw sharedOutOfBoundsError;const r=Math.asin(o/SQRT2);const i=Math.cos(r);const h=SQRT8*i;if(Math.abs(e)>h+THETA_TOLERANCE)throw sharedOutOfBoundsError;const c=2*r;const l=Math.asin((c+Math.sin(c))/Math.PI)*Constants.RAD2DEG;let d=this.getCentralMeridian();const u=1e-7;if(Math.abs(l-90)>u&&Math.abs(l+90)>u)d+=Math.PI/SQRT8*e/i*Constants.RAD2DEG;s.x=d;s.y=l}inLonLatBounds(t){return true}boundaryLons(t){return[[normalizeLon(-180+this.getCentralMeridian()+this.EPSILON),normalizeLon(180+this.getCentralMeridian()-this.EPSILON)]]}boundaryLats(t){return[[-90,90]]}inWorldBoundsOnSphere(t,n){const s=Math.abs(t.x/n);if(s>SQRT8)return false;const e=t.y/n;if(Math.abs(e)>SQRT2)return false;const o=Math.asin(e/SQRT2);const a=undefined;return s<=SQRT8*Math.cos(o)+THETA_TOLERANCE}cartesianBoundsOnSphereSFCT(t,n){const s=t*SQRT8;const e=t*SQRT2;n.setTo2D(-s,2*s,-e,2*e)}encode(){return{type:"Mollweide",centralMeridian:this.getCentralMeridian()}}get TYPE(){return ProjectionType.MOLLWEIDE+ProjectionType.CYLINDRICAL}calculateCachedValues(){const t=new Hash;this._hash=t.appendDouble(this.getCentralMeridian()).appendUInt32(this.TYPE).getHashCode()}hashCode(t){t.appendUInt32(this._hash)}}