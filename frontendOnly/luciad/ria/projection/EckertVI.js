import{OutOfBoundsError}from"../error/OutOfBoundsError.js";import{Constants}from"../util/Constants.js";import{Hash}from"../util/Hash.js";import{normalizeLon}from"../util/LonLatCoord.js";import{Cylindrical}from"./Cylindrical.js";import{ProjectionType}from"./ProjectionType.js";const sharedOutOfBoundsError=new OutOfBoundsError("EckertVI");export class EckertVI extends Cylindrical{constructor(t=0){super();this.setCentralMeridian(t);this._X=1/Math.sqrt(2+Math.PI);this._Y=2/Math.sqrt(2+Math.PI);this._extremumX=this._X*Math.PI*2;this._extremumY=this._X*Math.PI;this._hash=0;this.calculateCachedValues()}isAllInBounds(){return false}geodetic2cartesianOnSphereSFCT(t,e,s){const n=normalizeLon(t.x-this.getCentralMeridian())*Constants.DEG2RAD;const r=this.calculateTheta(t.y*Constants.DEG2RAD);s.x=this._X*e*n*(1+Math.cos(r));s.y=this._Y*e*r}calculateTheta(t){const e=(1+Math.PI/2)*Math.sin(t);let s=t;const n=1e-10;let r=Number.MAX_VALUE;const a=30;let o=0;while(Math.abs(r)>n&&o<a){const t=undefined;const n=undefined;r=-(s+Math.sin(s)-e)/(1+Math.cos(s));s+=r;o++}return s}cartesian2geodeticOnSphereSFCT(t,e,s){const n=t.x/e;const r=t.y/e;const a=Math.abs(n);if(a>this._extremumX+1e-15||Math.abs(r)>this._extremumY+1e-15)throw sharedOutOfBoundsError;const o=r/this._Y;const i=Math.cos(o);const h=this._X*(1+i);const c=undefined;if(a>h*Math.PI+1e-15)throw sharedOutOfBoundsError;const u=undefined;const d=(o+Math.sin(o))/(1+Math.PI/2);s.x=this.getCentralMeridian()+n/h*Constants.RAD2DEG;s.y=Math.abs(d)<=1?Math.asin(d)*Constants.RAD2DEG:d>=0?90:-90}inLonLatBounds(t){return true}boundaryLons(t){return[[normalizeLon(-180+this.getCentralMeridian()+this.EPSILON),normalizeLon(180+this.getCentralMeridian()-this.EPSILON)]]}boundaryLats(t){return[[-90,90]]}inWorldBoundsOnSphere(t,e){const s=t.x/e;const n=t.y/e;const r=Math.abs(s);if(r>this._extremumX+1e-15||Math.abs(n)>this._extremumY+1e-15)return false;const a=n/this._Y;const o=Math.cos(a);const i=undefined;const h=undefined;return r<=this._X*(1+o)*Math.PI+1e-15}cartesianBoundsOnSphereSFCT(t,e){const s=(this._extremumX+1e-15)*t;const n=(this._extremumY+1e-15)*t;e.setTo2D(-s,2*s,-n,2*n)}encode(){return{type:"EckertVI",centralMeridian:this.getCentralMeridian()}}calculateCachedValues(){const t=new Hash;this._hash=t.appendDouble(this.getCentralMeridian()).appendUInt32(this.TYPE).getHashCode()}get TYPE(){return ProjectionType.ECKERT_VI+ProjectionType.CYLINDRICAL}hashCode(t){t.appendUInt32(this._hash)}}