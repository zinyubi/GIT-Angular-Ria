import{isShapeList}from"../../../shape/ShapeList.js";import{ShapeType}from"../../../shape/ShapeType.js";import{Log}from"../../../util/Log.js";import{FeaturePainter}from"../../../view/feature/FeaturePainter.js";import{SEElementType}from"../model/SEElementType.js";import{LabelGroupName}from"../../../view/style/HTMLLabelGroup.js";import{getVendorOptionValue,SupportedVendorOptions}from"../model/VendorOption.js";import{addBufferInvalidationListenerForPerpendicularOffset,addBufferInvalidationListenerForStrokeGraphicFill,polygon2BufferContour,polygon2InnerBufferContour,polygon2OuterBufferContour,polyLine2BufferContour}from"./SEGeoBufferUtil.js";import{isDefined}from"../../../util/Lang.js";const INVISIBLE_LINE={color:"rgba(0,0,0,0)",width:1};const ALLOWED_STYLES={map:["normal","mapOnly"],legend:["normal","legendOnly"]};export class SEPainter extends FeaturePainter{constructor(e){super();this._featureTypeStyle=e.featureTypeStyle;this._conflictResolution=e.conflictResolution??true;this._drapeTarget=e.drapeTarget;this._type=e.type??"map"}paintBody(e,t,r,o,a,n){const s=ALLOWED_STYLES[this._type];const i=e=>hasAllowedInclusion(e,s);if(!i(this._featureTypeStyle))return;const l=this._featureTypeStyle.getRulesToPaint(n.level);for(const o of l)if(o.passesFilter(l,n.level,t,r)&&i(o))for(const n of o.bodySymbolizers){if(!i(n))continue;r=n.getShapeForStyling(t,r);const s=t.properties.zOrder??this._featureTypeStyle.getRuleZOrder(o,n);const l=n.getPerpendicularOffset(t,r,a.worldSizeSupport);switch(n.type){case SEElementType.LINE_SYMBOLIZER:{const o=undefined;if(!this.drawStrokeGraphicFill(n,t,r,polyLine2BufferContour,a,e,s)){const o=n.createStrokeStyles(t,r,true);for(let t=0;t<o.length;t++){const a=o[t];e.drawShape(r,{stroke:a,zOrder:s+t,drapeTarget:this._drapeTarget})}}break}case SEElementType.POLYGON_SYMBOLIZER:{const o=n.createFillStyle(t,r,a._isSoftwareMap());const i=a._isSoftwareMap()||!isDefined(o);const p=this.calculateShapeToUse(l,!i,a,r,t,n);if(o)e.drawShape(p,{stroke:INVISIBLE_LINE,fill:o,zOrder:s,drapeTarget:this._drapeTarget});const f=undefined;if(!this.drawStrokeGraphicFill(n,t,r,polygon2BufferContour,a,e,s+1)){const o=n.createStrokeStyles(t,r,i);for(let t=0;t<o.length;t++){const r=o[t];e.drawShape(p,{stroke:r,zOrder:s+t+1,drapeTarget:this._drapeTarget})}}break}case SEElementType.POINT_SYMBOLIZER:if(isShapeList(r))for(let o=0;o<r.shapeCount;o++)this.drawFocusPoint(r.getShape(o).focusPoint,n,t,r,e,s);else this.drawFocusPoint(r.focusPoint,n,t,r,e,s);break;case SEElementType.TEXT_SYMBOLIZER:{if(r.focusPoint){const o=n.createStyledTexts(t,r);for(const t of o)e.drawText(r.focusPoint,t.text,{...t.style,zOrder:s,drapeTarget:this._drapeTarget})}const o=n.createStrokeStyles(t,r,true);for(let t=0;t<o.length;t++){const a=o[t];e.drawShape(r,{stroke:a,zOrder:s+t,drapeTarget:this._drapeTarget})}break}case SEElementType.RASTER_SYMBOLIZER:default:Log.error("Expected a Point/Line/Polygon/Text/Symbolizer for the body, but got "+n.type);break}}}drawFocusPoint(e,t,r,o,a,n){if(e){const s=t.createIconStyles(r,o);for(const t of s)a.drawIcon(e,{...t,zOrder:n,drapeTarget:this._drapeTarget})}}drawStrokeGraphicFill(e,t,r,o,a,n,s){let i=false;const l=e.createStrokeFillStyle(t,r);if(l)try{const p=e.getBufferWidth(t,r,a.worldSizeSupport);const f=o(r,p);addBufferInvalidationListenerForStrokeGraphicFill(t,e,a,this,r,p);n.drawShape(f,{stroke:INVISIBLE_LINE,fill:l,zOrder:s,drapeTarget:this._drapeTarget});i=true}catch(e){const t=e instanceof Error?e.message:""+e;Log.warn(t+" Drawing the polyline stroke without graphic fill.")}return i}calculateShapeToUse(e,t,r,o,a,n){let s=o;if(0!==e&&t)try{if(e>0)s=polygon2OuterBufferContour(o,e);else if(e<0)s=polygon2InnerBufferContour(o,-e);addBufferInvalidationListenerForPerpendicularOffset(a,n,r,this,o,e)}catch(e){const t=e instanceof Error?e.message:"unknown error";Log.warn(t+" Drawing the polygon without offset.");s=o}return s}paintLabel(e,t,r,o,a,n){const s=ALLOWED_STYLES[this._type];const i=e=>hasAllowedInclusion(e,s);if(!i(this._featureTypeStyle))return;const l=this._featureTypeStyle.getRulesToPaint(n.level);for(const o of l)if(o.passesFilter(l,n.level,t,r)&&i(o))for(const a of o.labelSymbolizers){if(!i(a))continue;r=a.getShapeForStyling(t,r);switch(a.type){case SEElementType.TEXT_SYMBOLIZER:{const o=a.getHTMLLabelText(t,r);if(o.length>0){const n=undefined;const s=getVendorOptionValue(a,SupportedVendorOptions.VENDOR_OPTION_CONFLICT_RESOLUTION,this._conflictResolution)?void 0:LabelGroupName.GROUP_NON_DECLUTTERED;const i=a.createLabelPlacementSpecifics(t,r);if(i){const t=Object.assign({},i.style);t.group=s;switch(i.lpType){case SEElementType.POINT_PLACEMENT:if(isShapeList(r))for(let a=0;a<r.shapeCount;a++)e.drawLabel(o,r.getShape(a).focusPoint,t);else e.drawLabel(o,r.focusPoint,t);break;case SEElementType.LINE_PLACEMENT:e.drawLabelOnPath(o,r,t)}}else switch(getDefaultLabelMethodName(r)){case"drawLabelInPath":e.drawLabelInPath(o,r,{group:s});break;case"drawLabelOnPath":e.drawLabelOnPath(o,r,{group:s});break;case"drawLabel":default:e.drawLabel(o,r,{group:s});break}}break}default:Log.error("Expected a TextSymbolizer for the label, but got "+a.type);break}}}getDetailLevelScales(){return this._featureTypeStyle.detailLevelScales}get featureTypeStyle(){return this._featureTypeStyle}}function getDefaultLabelMethodName(e){if(e.type===ShapeType.POLYGON||e.type===ShapeType.COMPLEX_POLYGON||e.type===ShapeType.BOUNDS)return"drawLabelInPath";if(e.type===ShapeType.POLYLINE)return"drawLabelOnPath";if(e.type===ShapeType.SHAPE_LIST&&e.shapeCount>0)return getDefaultLabelMethodName(e.getShape(0));return"drawLabel"}function hasAllowedInclusion(e,t){const r=getVendorOptionValue(e,SupportedVendorOptions.VENDOR_OPTION_INCLUSION);return t.indexOf(r)>-1}