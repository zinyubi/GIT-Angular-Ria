import{append,gap,text}from"../../../view/style/complexstroke/PatternFactory.js";import{PathLabelPosition}from"../../../view/style/PathLabelPosition.js";import{PathLabelRotation}from"../../../view/style/PathLabelRotation.js";import{SEElement}from"./SEElement.js";import{SEElementType}from"./SEElementType.js";const DEFAULT_LINE_POSITIONS=PathLabelPosition.CENTER;export class LinePlacement extends SEElement{static VALID_CHILDREN=["PerpendicularOffset","IsRepeated","InitialGap","Gap","IsAligned","GeneralizeLine"];_perpendicularOffset=null;_initialGap=null;_gap=null;_isRepeated=null;_isAligned=null;_generalizeLine=null;constructor(){super(SEElementType.LINE_PLACEMENT)}get perpendicularOffset(){return this._perpendicularOffset}set perpendicularOffset(e){this._perpendicularOffset=e;this._perpendicularOffset?.createNumberEvaluationFunction()}get initialGap(){return this._initialGap}set initialGap(e){this._initialGap=e;this._initialGap?.createNumberEvaluationFunction()}get gap(){return this._gap}set gap(e){this._gap=e;this._gap?.createNumberEvaluationFunction()}get isRepeated(){return this._isRepeated}set isRepeated(e){this._isRepeated=e}get isAligned(){return this._isAligned}set isAligned(e){this._isAligned=e}get generalizeLine(){return this._generalizeLine}set generalizeLine(e){this._generalizeLine=e}createLabelPlacementSpecifics(e,t){return{lpType:SEElementType.LINE_PLACEMENT,style:{positions:DEFAULT_LINE_POSITIONS,perpendicularOffset:this.perpendicularOffsetToPadding(e,t),rotation:this._isAligned?PathLabelRotation.FIXED_LINE_ANGLE:PathLabelRotation.NO_ROTATION,repeat:this._isRepeated?{minimumGap:this._gap?.evaluateContentAsNumber(e,t),initialGap:this._initialGap?.evaluateContentAsNumber(e,t)}:void 0}}}appendTextSyle(e,t,i){}createCSPatterns(e,t,i,a,n){const s=[];const l=n&&this._perpendicularOffset?this._perpendicularOffset.evaluateContentAsNumber(e,t):0;const p=text({text:[i],rotateUp:true,offset:l,textStyle:a});if(this._initialGap){const i=gap(this._initialGap.evaluateContentAsNumber(e,t),false);if(this._isRepeated)s.push({pattern:i,alignment:"left",location:0});else s.push({pattern:append([i,p]),alignment:"left",location:0})}else if(!this._isRepeated)s.push({pattern:p,alignment:"left",location:0});const r=[];if(this._isRepeated){r.push(p);if(this._gap)r.push(gap(this._gap.evaluateContentAsNumber(e,t),false))}return{regular:r.length>0?append(r):null,decorations:s.length>0?s:null}}perpendicularOffsetToPadding(e,t){if(!this._perpendicularOffset)return 0;return this._perpendicularOffset.evaluateContentAsNumber(e,t)}}