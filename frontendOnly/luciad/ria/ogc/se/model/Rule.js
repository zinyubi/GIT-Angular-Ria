import{ProgrammingError}from"../../../error/ProgrammingError.js";import{getUnitOfMeasure}from"../../../uom/UnitOfMeasureRegistry.js";import{isDefined}from"../../../util/Lang.js";import{Log}from"../../../util/Log.js";import{OGCFilterBuilderVisitor}from"../../filter/OGCFilterBuilderVisitor.js";import{SupportedVendorOptions}from"./VendorOption.js";import{SEElementType}from"./SEElementType.js";import{SENamedElement}from"./SENamedElement.js";import{createEvaluationFunction,PRE_DEFINED_FUNCTION_EVALUATORS}from"../../FunctionEvaluatorUtil.js";export class Rule extends SENamedElement{static VALID_CHILDREN=["Name","Description","LegendGraphic","Filter","ElseFilter","MinScaleDenominator","MaxScaleDenominator","LineSymbolizer","PolygonSymbolizer","PointSymbolizer","TextSymbolizer","RasterSymbolizer","VendorOption"];_symbolizers=[];static VALID_VENDOR_OPTIONS=[SupportedVendorOptions.VENDOR_OPTION_INCLUSION];_hasElseFilter=false;_filter=null;_minScaleDenominator=null;_maxScaleDenominator=null;_filterInstruction=null;_labelSymbolizers=[];_bodySymbolizers=[];_evaluationPerLevel=new Map;constructor(e){super(SEElementType.RULE);this._functionEvaluators=isDefined(e)?Object.assign({},PRE_DEFINED_FUNCTION_EVALUATORS,e):PRE_DEFINED_FUNCTION_EVALUATORS}isReady(){const e=new Array(this._symbolizers.length);for(let t=0;t<this._symbolizers.length;t++)e[t]=this._symbolizers[t].isReady();return Promise.all(e).then((()=>{}))}get validVendorOptions(){return Rule.VALID_VENDOR_OPTIONS}get hasElseFilter(){return this._hasElseFilter}set hasElseFilter(e){this._hasElseFilter=e;if(this._hasElseFilter)this._filter=null}get filter(){return this._filter}set filter(e){this._filter=e;if(isDefined(this._filter)){this._hasElseFilter=false;const e=new OGCFilterBuilderVisitor({functionEvaluators:this._functionEvaluators,expectedFunctionOutput:"boolean"});e.reset();this._filter.accept(e);this._filterInstruction=e.expression}}get minScaleDenominator(){return this._minScaleDenominator}set minScaleDenominator(e){this._minScaleDenominator=e;this.eventedSupport?.emit("ScaleChanged","minScaleDenominator scale");this.eventedSupport?.emit("StyleChanged","maxScaleDenominator style")}get maxScaleDenominator(){return this._maxScaleDenominator}set maxScaleDenominator(e){this._maxScaleDenominator=e;this.eventedSupport?.emit("ScaleChanged","maxScaleDenominator scale");this.eventedSupport?.emit("StyleChanged","maxScaleDenominator style")}get labelSymbolizers(){return this._labelSymbolizers}get bodySymbolizers(){return this._bodySymbolizers}get symbolizers(){return this._symbolizers}get filterInstruction(){return this._filterInstruction}addSymbolizer(e){e.eventedSupport=this.eventedSupport;this._symbolizers.push(e);switch(e.type){case SEElementType.TEXT_SYMBOLIZER:if(e.uom.equals(getUnitOfMeasure("Pixels")))this._labelSymbolizers.push(e);else this._bodySymbolizers.push(e);break;case SEElementType.POINT_SYMBOLIZER:case SEElementType.LINE_SYMBOLIZER:case SEElementType.POLYGON_SYMBOLIZER:case SEElementType.RASTER_SYMBOLIZER:this._bodySymbolizers.push(e);break;default:break}}removeSymbolizer(e){const t=this._symbolizers.indexOf(e);if(t>-1){this._symbolizers.splice(t,1);switch(e.type){case SEElementType.TEXT_SYMBOLIZER:if(e.uom.equals(getUnitOfMeasure("Pixels"))){const t=this._labelSymbolizers.indexOf(e);this._labelSymbolizers.splice(t,1)}else{const t=this._bodySymbolizers.indexOf(e);this._bodySymbolizers.splice(t,1)}break;case SEElementType.POINT_SYMBOLIZER:case SEElementType.LINE_SYMBOLIZER:case SEElementType.POLYGON_SYMBOLIZER:case SEElementType.RASTER_SYMBOLIZER:this._bodySymbolizers.splice(this._bodySymbolizers.indexOf(e),1);break;default:break}this.eventedSupport?.emit("StyleChanged","RemoveSymbolizer")}}calculateApplicableScaleLevels(e){const t=[];let i=0;if(this.maxScaleDenominator)while(i<e.length&&this.maxScaleDenominator<=e[i])i+=1;if(this.minScaleDenominator)while(i<e.length&&this.minScaleDenominator<=e[i])t.push(i++);else while(i<=e.length)t.push(i++);return t}passesFilter(e,t,i,r){let s=this._evaluationPerLevel.get(t);if(!s){const i=this.generateFilterEvaluationBody(e);s=createEvaluationFunction(i);this._evaluationPerLevel.set(t,s)}if(!s)throw new ProgrammingError("We need an evaluation method, it should get created lazily.");else{let e;try{e=s(this._functionEvaluators,i,r)}catch(t){Log.error("Symbology Encoding Painter - rule evaluation (returning false): "+(t instanceof Error?t.message:t));e=false}return e}}generateFilterEvaluationBody(e){const t=this;let i;if(this._filterInstruction)i=this._filterInstruction;else if(this._hasElseFilter){const r=e.filter((function(e){return e!==t}));const s=r.length;if(0===s)i="true";else{const e=[];for(let t=0;t<s;t++)if(!r[t].filterInstruction){e.length=0;e.push("false");break}else{const i=r[t].filterInstruction;e.push("!("+i+")")}i=e.join("&&")}}else i="true";return`return ${i};`}}