import{hasProperty,isBoolean,isDefined,isObject,isString}from"../../util/Lang.js";import{XML}from"../../util/XML.js";import{InvalidXMLError}from"../../error/InvalidXMLError.js";import{ErrorHandler}from"../ErrorHandler.js";import{add,and,bbox,between,div,eq,exists,func,gt,gte,identifiers,isNull,like,literal,lt,lte,mul,neq,not,or,property,sub}from"./FilterFactory.js";const filter=Array.prototype.filter;const map=Array.prototype.map;const NODE_NAMES_IDENTITY_OPS=["ResourceId","FeatureId","GmlObjectId"];const NODE_NAMES_PROPERTY=["ValueReference","PropertyName"];const NODE_NAMES_IS_LIKE_OP=NODE_NAMES_PROPERTY.concat(["Literal"]);const NODE_NAMES_EXPRESSIONS=NODE_NAMES_PROPERTY.concat(["Literal","Function","Add","Sub","Mul","Div"]);const NODE_NAMES_BINARY_COMPARISON_OPS=["PropertyIsEqualTo","PropertyIsNotEqualTo","PropertyIsLessThan","PropertyIsGreaterThan","PropertyIsLessThanOrEqualTo","PropertyIsGreaterThanOrEqualTo"];const NODE_NAMES_COMPARISON_OPS=NODE_NAMES_BINARY_COMPARISON_OPS.concat(["PropertyIsLike","PropertyIsNull","PropertyIsBetween","PropertyExists"]);const NODE_NAMES_LOGIC_OPS=["And","Or","Not"];const NODE_NAMES_SPATIAL_OPS=["BBOX"];const NODE_NAMES_BBOX_OP=NODE_NAMES_PROPERTY.concat(["Envelope"]);const NODE_NAMES_ALL_VALID_OPS=["Function"].concat(NODE_NAMES_SPATIAL_OPS,NODE_NAMES_LOGIC_OPS,NODE_NAMES_COMPARISON_OPS);export class FilterDecoder{constructor(e){if(!isObject(e))e={};this.errorHandler=new ErrorHandler({strict:e.strict?e.strict:false,errorCtor:InvalidXMLError});this.nameSpaces={}}decodeXML(e){const t=XML.xmlToJson(e);return this.decodeElement(t)}decodeJsonNode(e){return this.decodeElement(e)}findNameSpace(e){for(const t in e.$attr_completename)if(e.$attr_completename.hasOwnProperty(t)&&-1!=t.search("xmlns:"))this.nameSpaces[t.substring(6)]=e.$attr_completename[t]}decodeElement(e){let t;this.findNameSpace(e);if("Filter"===e.$name){t=filter.call(e.$chil,XML.isNotTextNode);return t.length>0?this.decodeElement(t[0]):null}else if(isIdFilterNode(e))return this.decodeIDFilter(e);else if(isOGCSpatialOpNode(e))return this.decodeSpatialOp(e);else if(isOGCComparisonOpNode(e))return this.decodeComparisonOp(e);else if(isOGCLogicOpNode(e))return this.decodeLogicOp(e);else if(isOGCExpressionNode(e))return this.decodeOGCExpression(e);this.errorHandler.fatal(`FilterDecoder: XML Node ${e.$name} is invalid or not supported.`)}decodeIDFilter(e){const t=[];const r=[];this.findNameSpace(e);const i=e=>{switch(e.$name){case"FeatureId":if(isDefined(e.$attr.fid))r.push(e.$attr.fid);break;case"GmlObjectId":if(isDefined(e.$attr.id))t.push(e.$attr.id);break;case"ResourceId":if(isDefined(e.$attr.rid))t.push(e.$attr.rid);break;default:}};if(null===e.$parent)i(e);else{this.checkInvalidChildren(e.$parent,NODE_NAMES_IDENTITY_OPS,"Feature ID filter contains invalid elements");const t=undefined;filter.call(e.$parent.$chil,isIdFilterNode).forEach(i)}return identifiers(t,r)}decodeSpatialOp(e){this.findNameSpace(e);if("BBOX"!==e.$name)this.errorHandler.fatal(`FilterDecoder: OGC Filter element ${e.$name} is not supported`);this.checkInvalidChildren(e,NODE_NAMES_BBOX_OP,"BBOX element contains invalid or unsupported elements");const t=this.getPropertyNameOrValueReference(e,true);if(!e.Envelopes)this.errorHandler.fatal("FilterDecoder: BBOX OGC Filter element must have a GML envelope");const r=e.Envelopes[0];this.checkInvalidChildren(r,["lowerCorner","upperCorner"],"GML envelope contains invalid or unsupported elements");this.validateMinSize(r.lowerCorners,"BBOX Filter's lowerCorner",1);const i=parseCornerValues(r.lowerCorners[0].$text);if(2!==i.length)this.errorHandler.fatal(`FilterDecoder: BBOX OGC Filter's lowerCorner is invalid (${r.lowerCorners[0].$text})`);const n=i[0];const s=i[1];this.validateMinSize(r.upperCorners,"BBOX Filter's upperCorner",1);const a=parseCornerValues(r.upperCorners[0].$text);if(2!==a.length)this.errorHandler.fatal(`FilterDecoder: BBOX OGC Filter's UpperCorner is invalid (${r.upperCorners[0].$text})`);const o=a[0];const l=a[1];const d=r.$attr.srsName||void 0;return bbox(n,s,o,l,d,t)}decodeArithmeticExpression(e,t){const r=this.checkInvalidChildren(t,NODE_NAMES_EXPRESSIONS,"Binary Comparison node contains invalid or unsupported elements");const i=this.getValidExistingChildren(t,r);this.validateMinSize(i,t.$name,2);this.findNameSpace(t);return e.apply(null,map.call(i,this.decodeOGCExpression,this))}decodeOGCExpression(e){let t,r,i;this.findNameSpace(e);switch(e.$name){case"Literal":return literal(e.$value,{strict:isString(e.$value)});case"PropertyName":case"ValueReference":{r=`${e.$value}`.trim();const t={};const i=r.split("/");for(const e in i){const r=i[e].split(":")[0];if(hasProperty(this.nameSpaces,r))t[r]=this.nameSpaces[r]}return property(r,t)}case"Function":i=filter.call(e.$chil,XML.isNotTextNode);t=map.call(i,this.decodeOGCExpression,this);t.unshift(e.$attr.name);return func.apply(null,t);case"Add":return this.decodeArithmeticExpression(add,e);case"Sub":return this.decodeArithmeticExpression(sub,e);case"Mul":return this.decodeArithmeticExpression(mul,e);case"Div":return this.decodeArithmeticExpression(div,e);default:this.errorHandler.fatal(`FilterDecoder: OGCExpression ${e.$name} is invalid`)}}decodeComparisonOp(e){this.findNameSpace(e);if(isOGCBinaryComparisonOpNode(e))return this.decodeBinaryComparisonOp(e);switch(e.$name){case"PropertyIsLike":return this.decodePropertyIsLikeOp(e);case"PropertyIsNull":return this.decodePropertyIsNullOp(e);case"PropertyExists":return this.decodePropertyExistsOp(e);case"PropertyIsBetween":return this.decodePropertyIsBetweenOp(e);default:this.errorHandler.fatal(`FilterDecoder: ${e.$name}is not a valid Comparison operator`)}}decodeBinaryComparisonOp(e){const t=this.checkInvalidChildren(e,NODE_NAMES_EXPRESSIONS,"Binary Comparison node contains invalid or unsupported elements");const r=this.getValidExistingChildren(e,t);this.validateMinSize(r,"Binary Comparison node",2);this.validateMaxSize(r,"Binary Comparison node",2);this.findNameSpace(e);const i=getMatchCaseAttribute(e);const n=getMatchActionAttribute(e);const s=this.decodeOGCExpression(r[0]);const a=this.decodeOGCExpression(r[1]);switch(e.$name){case"PropertyIsEqualTo":return eq(s,a,i,n);case"PropertyIsNotEqualTo":return neq(s,a,i,n);case"PropertyIsLessThan":return lt(s,a,i,n);case"PropertyIsGreaterThan":return gt(s,a,i,n);case"PropertyIsLessThanOrEqualTo":return lte(s,a,i,n);case"PropertyIsGreaterThanOrEqualTo":return gte(s,a,i,n);default:this.errorHandler.fatal("FilterDecoder: encountered an invalid binary comparison operator")}}getMandatoryAttribute(e,t,r){if(typeof e.$attr[t]!==r)this.errorHandler.fatal(`FilterDecoder: ${e.$name} operator does not have the mandatory ${t} attribute`);return e.$attr[t]}decodePropertyIsLikeOp(e){this.findNameSpace(e);this.checkInvalidChildren(e,NODE_NAMES_IS_LIKE_OP,"PropertyIsLike operator contains invalid or unsupported elements");const t=this.getPropertyNameOrValueReference(e);const r=e.Literals;this.validateMinSize(r,"PropertyIsLike",1);this.validateMaxSize(r,"PropertyIsLike",1);const i=this.decodeOGCExpression(r[0]);const n=this.getMandatoryAttribute(e,"wildCard","string");const s=this.getMandatoryAttribute(e,"singleChar","string");const a=this.getMandatoryAttribute(e,"escapeChar","string");const o=getMatchCaseAttribute(e);return like(t,i,n,s,a,o)}decodePropertyIsNullOp(e){this.findNameSpace(e);this.checkInvalidChildren(e,NODE_NAMES_PROPERTY,"PropertyIsNull operator contains invalid or unsupported elements");const t=this.getPropertyNameOrValueReference(e);return isNull(t)}decodePropertyExistsOp(e){this.findNameSpace(e);this.checkInvalidChildren(e,NODE_NAMES_PROPERTY,"PropertyExists operator contains invalid or unsupported elements");const t=this.getPropertyNameOrValueReference(e);return exists(t)}decodePropertyIsBetweenOp(e){this.findNameSpace(e);this.checkInvalidChildren(e,NODE_NAMES_EXPRESSIONS.concat(["LowerBoundary","UpperBoundary"]),"PropertyIsBetween operator contains invalid or unsupported elements");let t=filter.call(e.$chil,isOGCExpressionNode);this.validateMinSize(t,"PropertyIsBetween operator",1);this.validateMaxSize(t,"PropertyIsBetween operator",1);const r=this.decodeOGCExpression(t[0]);this.validateMinSize(e.LowerBoundarys,"PropertyIsBetween's LowerBoundary element",1);this.validateMaxSize(e.LowerBoundarys,"PropertyIsBetween's LowerBoundary element",1);const i=e.LowerBoundarys[0];t=filter.call(i.$chil,isOGCExpressionNode);this.validateMaxSize(t,"PropertyIsBetween's LowerBoundary element",1);const n=this.decodeOGCExpression(t[0]);this.validateMinSize(e.UpperBoundarys,"PropertyIsBetween's UpperBoundary element",1);this.validateMaxSize(e.UpperBoundarys,"PropertyIsBetween's UpperBoundary element",1);const s=e.UpperBoundarys[0];t=filter.call(s.$chil,isOGCExpressionNode);this.validateMaxSize(t,"PropertyIsBetween's UpperBoundary element",1);const a=this.decodeOGCExpression(t[0]);return between(r,n,a)}decodeLogicOp(e){this.findNameSpace(e);if("And"===e.$name||"Or"===e.$name)return this.decodeBinaryLogicOp(e);else return this.decodeUnaryLogicOp(e)}decodeBinaryLogicOp(e){const t=this.checkInvalidChildren(e,NODE_NAMES_ALL_VALID_OPS,`${e.$name} operator contains invalid or unsupported elements`),r=this.getValidExistingChildren(e,t);this.validateMinSize(r,e.$name,2);this.findNameSpace(e);const i=map.call(r,(e=>this.decodeElement(e)));switch(e.$name){case"And":return and.apply(null,i);case"Or":return or.apply(null,i);default:this.errorHandler.fatal(`FilterDecoder: encountered an invalid binary logic operator (${e.$name})`)}}decodeUnaryLogicOp(e){const t=this.checkInvalidChildren(e,NODE_NAMES_ALL_VALID_OPS,`${e.$name} operator contains invalid or unsupported elements`);const r=this.getValidExistingChildren(e,t);this.validateMinSize(r,e.$name,1);this.validateMaxSize(r,e.$name,1);this.findNameSpace(e);const i=this.decodeElement(r[0]);if("Not"===e.$name)return not(i);this.errorHandler.fatal(`FilterDecoder: encountered an invalid unary logic operator (${e.$name})`)}validateMinSize(e,t,r){if(!e||e.length<r)this.errorHandler.fatal(`FilterDecoder: ${t} should have at least ${r} child elements`)}validateMaxSize(e,t,r){if(e.length>r)this.errorHandler.warn(`FilterDecoder: ${t} contains multiple expression. Ignoring all but the first ${r} expression(s)`)}checkInvalidChildren(e,t,r){const i=XML.getInvalidChildren(e,t);if(i.length>0)this.errorHandler.warn(`FilterDecoder: ${r}: ${map.call(i,nameMapper).join(", ")}`);return i}getValidExistingChildren(e,t){const r=filter.call(e.$chil,XML.isNotTextNode);return 0===t.length?r:filter.call(r,(e=>!hasItem(t,e)))}getPropertyNameOrValueReference(e,t){const r=e.PropertyNames||e.ValueReferences;if(!r){if(t)return;this.validateMinSize(r,"PropertyName/ValueReference element",1)}this.validateMaxSize(r,"PropertyName/ValueReference element",1);return this.decodeOGCExpression(r[0])}}function isIdFilterNode(e){return hasItem(NODE_NAMES_IDENTITY_OPS,e.$name)}function isOGCSpatialOpNode(e){return hasItem(NODE_NAMES_SPATIAL_OPS,e.$name)}function isOGCExpressionNode(e){return hasItem(NODE_NAMES_EXPRESSIONS,e.$name)}function isOGCBinaryComparisonOpNode(e){return hasItem(NODE_NAMES_BINARY_COMPARISON_OPS,e.$name)}function isOGCComparisonOpNode(e){return hasItem(NODE_NAMES_COMPARISON_OPS,e.$name)}function isOGCLogicOpNode(e){return hasItem(NODE_NAMES_LOGIC_OPS,e.$name)}function hasItem(e,t){const r=e.length;for(let i=0;i<r;i++)if(e[i]===t)return true;return false}function nameMapper(e){return e.$name}function getMatchCaseAttribute(e){let t;if(isDefined(e.$attr.matchCase)){t=XML.parsePrimitive(e.$attr.matchCase);if(!isBoolean(t))t=false}return t}function getMatchActionAttribute(e){let t=null;if(isDefined(e.$attr.matchAction)){t=XML.parsePrimitive(e.$attr.matchAction);if(!isString(t))t=null}return t}function parseCornerValues(e){const t=[];if(isString(e)){const r=e.trim().split(/\s+/);if(2===r.length){const e=parseFloat(r[0]);const i=parseFloat(r[1]);if(!isNaN(e)&&!isNaN(i))t.push(e,i)}}return t}