import{NotImplementedError}from"../../error/NotImplementedError.js";import{Constants}from"../../util/Constants.js";import{LLHPoint}from"../../shape/LLHPoint.js";import{TopologyUtilEllipsoidal}from"../topologyutil/TopologyUtilEllipsoidal.js";import{EBTUtil}from"./EBTUtil.js";import{containsAngle}from"../../util/Cartesian.js";import{isPolyline}from"../../shape/Polyline.js";import{isCircularArc}from"../../shape/CircularArc.js";const DEFAULT_RELATIVE_TOLERANCE=Constants.RELATIVE_DISTANCE_TOLERANCE;const DEFAULT_ABSOLUTE_TOLERANCE=Constants.ABSOLUTE_DISTANCE_TOLERANCE;function isLineSegment(t){return isPolyline(t)&&2===t.pointCount}function intersectsLSWithCircularArc(t,e,i,n,o,s,r,l,c){const a=t.reference.geodeticDatum.ellipsoid;const f=a.geodesicDistance(t,e);let u=Math.max(l,r*f);if(0===u)u=a.a/Constants.EARTH_RADIUS;if(f<=u){const e=a.forwardAzimuth2D(i,t)*Constants.RAD2DEG;return containsAngle(o,s,90-e)}const E=u/f;const A=a.forwardAzimuth2D(t,e)*Constants.RAD2DEG;let T,C,m;let d,L,p;let g=a.forwardAzimuth2D(i,e)*Constants.RAD2DEG;const D=a.geodesicDistance(i,t);let h=a.geodesicDistance(i,e);d=D-n;L=h-n;c.move2D(e);T=0;C=1;m=T;p=d;const S=Math.ceil(Math.abs(Math.log(E)/Math.log(2)))+1;for(let e=0;e<S;e++){const e=C-T;let o,s,r;if(Math.abs(p)<Math.abs(L)){T=C;C=m;m=T;d=L;L=p;p=d}const l=2*1e-16*Math.abs(C)+E/2;r=(m-C)/2;if(Math.abs(r)<=l||0===L)break;if(Math.abs(e)>=l&&Math.abs(d)>Math.abs(L)){let t,i;const n=m-C;if(T===m){t=L/d;o=n*t;s=1-t}else{s=d/p;t=L/p;i=L/d;o=i*(n*s*(s-t)-(C-T)*(t-1));s=(s-1)*(t-1)*(i-1)}if(o>0)s=-s;else o=-o;if(o<.75*n*s-Math.abs(l*s)/2&&o<Math.abs(e*s/2))r=o/s}if(Math.abs(r)<l)if(r>0)r=l;else r=-l;T=C;d=L;C+=r;a.geodesicPositionSFCT(t,C*f,A,c);g=a.forwardAzimuth2D(i,c)*Constants.RAD2DEG;h=a.geodesicDistance(i,c);L=h-n;if(L>0&&p>0||L<0&&p<0){m=T;p=d}}return containsAngle(o,s,g)}function lineArcIntersectionSFCT(t,e,i,n,o,s,r,l,c,a){const f=EBTUtil.circleContains2D(i,n,t);const u=EBTUtil.circleContains2D(i,n,e);if(f&&u)return false;const E=new LLHPoint(t.reference);const A=new LLHPoint(t.reference);if(!f&&!u){EBTUtil.closestPointToEllipse(t,e,i,n,n,0,r,l,E);if(!EBTUtil.circleContains2D(i,n,E))return false;const f=intersectsLSWithCircularArc(t,E,i,n,o,s,r,l,A);if(f){if(a)return true;EBTUtil.addResultSFCT(A,c)}const u=intersectsLSWithCircularArc(e,E,i,n,o,s,r,l,A);if(u){if(a)return true;EBTUtil.addResultSFCT(A,c)}return f||u}else{const f=undefined;if(intersectsLSWithCircularArc(t,e,i,n,o,s,r,l,A)){if(a)return true;EBTUtil.addResultSFCT(A,c);return true}}return false}function lineIntersectionSFCT(t,e,i,n){if(isLineSegment(t)&&isLineSegment(e)){const n=t.getPoint(0).reference;const o=undefined;const s=undefined;return 0!==new TopologyUtilEllipsoidal(1e-10,n.geodeticDatum.ellipsoid).lineSegmentIntersection(t.getPoint(0),t.getPoint(1),e.getPoint(0),e.getPoint(1),i)}if(isLineSegment(t)&&isCircularArc(e)||isLineSegment(e)&&isCircularArc(t)){const o=isLineSegment(t)?t:e;const s=isCircularArc(t)?t:e;return lineArcIntersectionSFCT(o.getPoint(0),o.getPoint(1),s.center,s.radius,s.startAzimuth,s.sweepAngle,DEFAULT_RELATIVE_TOLERANCE,DEFAULT_ABSOLUTE_TOLERANCE,i,n)}throw new NotImplementedError(`Intersection is not supported for ${t.type}, ${e.type}`)}export const EllipsoidalBasicBinaryTopology={lineIntersectionSFCT:lineIntersectionSFCT};