import{XYZBounds}from"../../shape/XYZBounds.js";import{XYZPoint}from"../../shape/XYZPoint.js";import{AdvancedBinaryTopologyUtil}from"./AdvancedBinaryTopologyUtil.js";import{distance2D,squaredDistance2D}from"../../util/Cartesian.js";const dummyPoint=new XYZPoint;export class CartesianAdvancedBinaryTopologyUtil extends AdvancedBinaryTopologyUtil{constructor(t){super();this._tolerance=t;this._tolerance2=t*t}setTolerance(t){this._tolerance2=t*t}computeDistance(t,e){return distance2D(t,e)}computePoint(t,e,n){const o=t.copy();o.move2DToCoordinates(t.x+n*(e.x-t.x),t.y+n*(e.y-t.y));return o}insidePointPolygon(t,e){const n=e.pointCount;const o=t.x;const i=t.y;let r=0;let s=e.getPoint(n-1).x;let c=e.getPoint(n-1).y;let a,u,l,d,y;for(let t=0;t<n;s=a,c=u,t++){a=e.getPoint(t).x;u=e.getPoint(t).y;if(u==c)continue;if(a<s){if(o>=s)continue;l=a}else{if(o>=a)continue;l=s}if(u<c){if(i<u||i>=c)continue;if(o<l){r++;continue}d=o-a;y=i-u}else{if(i<c||i>=u)continue;if(o<l){r++;continue}d=o-s;y=i-c}if(d<=y/(c-u)*(s-a))r++}return 0!=(1&r)}createBoundsTolerance(t,e){const n=e||this._tolerance;return new XYZBounds(t.reference,[t.x-n,2*n,t.y-n,2*n])}intersectsTolerance(t,e){const n=t.x;const o=t.y;const i=e.x;const r=e.y;return!(n+t.width<i-this._tolerance||n>i+e.width+this._tolerance||o+t.height<r-this._tolerance||o>r+e.height+this._tolerance)}extendBounds(t,e){dummyPoint.move2DToCoordinates(t.x,t.y);dummyPoint.translate2D(-e,-e);return new XYZBounds(t.reference,[dummyPoint.x,t.width+2*e,dummyPoint.y,t.height+2*e])}equal2DTolerance(t,e){return squaredDistance2D(t.x,t.y,e.x,e.y)<=this._tolerance2}}