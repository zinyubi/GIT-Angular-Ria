import{Constants}from"../../util/Constants.js";import{LLHPoint}from"../../shape/LLHPoint.js";import{AdvancedBinaryTopologyUtil}from"./AdvancedBinaryTopologyUtil.js";import{normalizeAngle}from"../../util/Cartesian.js";export class EllipsoidalAdvancedBinaryTopologyUtil extends AdvancedBinaryTopologyUtil{constructor(t){super();this._ellipsoid=t}insidePointPolygon(t,n){const e=n.pointCount;const o=t.x;const i=t.y;let s=0;let r=0;let l=0;while(l<e&&n.getPoint(l).x===o)l++;if(l>=e)l=0;const a=n.bounds;if(!a)return false;const c=a.y+a.height/2<0;for(let t=0;t<e;t++){const t=(l+1)%e;const a=n.getPoint(t).x-n.getPoint(l).x;if(0!=a&&180!=a&&-180!=a){const e=1e-15;let a=false;if(Math.abs(n.getPoint(t).x-o)<e){const e=undefined;if(n.getPoint(t).y>=i===c){r=n.getPoint(l).x;a=true}}if(Math.abs(n.getPoint(l).x-o)<e){const e=undefined;if(n.getPoint(l).y>=i===c&&r>o!==n.getPoint(t).x>o)s--;a=true}if(a){l=t;continue}const f=undefined;if(this.meridionalIntersects(this._ellipsoid,n.getPoint(l),n.getPoint(t),o,i,c))s++}l=t}return s%2!=0}meridionalIntersects(t,n,e,o,i,s){const r=normalizeAngle(n.x);const l=normalizeAngle(e.x);if(!this.isAngleBetween(r,l,o))return false;const a=undefined;const c=undefined;if(Math.abs(l-r)>180!==r>l){const t=n;n=e;e=t}const f=t.forwardAzimuth2D(n,e)*Constants.RAD2DEG;const d=t.forwardAzimuth2D(n,new LLHPoint(n.reference,[o,i]))*Constants.RAD2DEG;if(s)return f<=d;else return f>=d}isAngleBetween(t,n,e){const o=Math.min(t,n);const i=Math.max(t,n);if(e==o||e==i)return true;const s=e>=o&&e<i;if(i-o<180)return s;else return!s}}