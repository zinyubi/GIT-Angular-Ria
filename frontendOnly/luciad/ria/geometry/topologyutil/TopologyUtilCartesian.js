import{XYZBounds}from"../../shape/XYZBounds.js";import{XYZPolygon}from"../../shape/XYZPolygon.js";import{XYZPolyline}from"../../shape/XYZPolyline.js";import{XYZPoint}from"../../shape/XYZPoint.js";import{closestPointOnSegment as CartesianClosestPointOnSegment,contains2D,distance2D}from"../../util/Cartesian.js";import{CartesianAdvancedBinaryTopologyUtil}from"./CartesianAdvancedBinaryTopologyUtil.js";import{TopologyUtil}from"./TopologyUtil.js";const EPSILON=1e-10;const dummyPoint=new XYZPoint;export class TopologyUtilCartesian extends TopologyUtil{constructor(t){super(t);this._advancedBinaryTopologyUtil=new CartesianAdvancedBinaryTopologyUtil(t)}get advancedBinaryTopologyUtil(){return this._advancedBinaryTopologyUtil}certainlyNoInteraction4Points(t,n,e,o){const i=Math.max(t.x,n.x);const s=Math.min(t.x,n.x);const r=Math.max(e.x,o.x);const a=Math.min(e.x,o.x);const l=Math.max(t.y,n.y);const c=Math.min(t.y,n.y);const u=Math.max(e.y,o.y);const y=Math.min(e.y,o.y);const h=this.toleranceEqualPoints;if(a>i+h||r<s-h)return true;return y>l+h||u<c-h}certainlyNoInteraction3Points(t,n,e){if(e.x>Math.max(t.x,n.x)+this.toleranceEqualPoints||e.x<Math.min(t.x,n.x)-this.toleranceEqualPoints)return true;return e.y>Math.max(t.y,n.y)+this.toleranceEqualPoints||e.y<Math.min(t.y,n.y)-this.toleranceEqualPoints}isPointOnLineSegment(t,n,e){if(this.pointsEqual(t,n))return this.pointsEqual(e,t);else if(Math.abs(t.x-n.x)<EPSILON){const o=(e.y-t.y)/(n.y-t.y);return Math.abs(e.x-t.x)<this.toleranceEqualPoints&&o>=0&&o<=1}else if(Math.abs(t.y-n.y)<EPSILON){const o=(e.x-t.x)/(n.x-t.x);return Math.abs(e.y-t.y)<this.toleranceEqualPoints&&o>=0&&o<=1}else return this.distancePointLineSegment(t,n,e)<this.toleranceEqualPoints}distancePointPoint(t,n){return distance2D(t,n)}distancePointLineSegment(t,n,e){return CartesianClosestPointOnSegment(e,t,n,dummyPoint).distance}pointsEqual(t,n){return Math.abs(t.x-n.x)<=this.toleranceEqualPoints&&Math.abs(t.y-n.y)<=this.toleranceEqualPoints}lineSegmentIntersection(t,n,e,o,i){let s=0;if(linesParallel(t,n,e,o)){if(s<2&&contains2D(t,n,e))i[s++]=new XYZPoint(e.reference,[e.x,e.y]);if(s<2&&!(1===s&&pointsEqualWithoutTolerance(i[0],o))&&contains2D(t,n,o))i[s++]=new XYZPoint(o.reference,[o.x,o.y]);if(s<2&&!(1===s&&pointsEqualWithoutTolerance(i[0],t))&&contains2D(e,o,t))i[s++]=new XYZPoint(t.reference,[t.x,t.y]);if(s<2&&!(1===s&&pointsEqualWithoutTolerance(i[0],n))&&contains2D(e,o,n))i[s++]=new XYZPoint(n.reference,[n.x,n.y])}else{const r=new XYZPoint(t.reference);if(intersection2DLSSFCT(t,n,e,o,r))i[s++]=r}return s}growBounds(t,n){const e=new XYZPoint(n.reference);e.move2D(n.x-t,n.y-t);n.setToIncludePoint2D(e);e.move2D(n.x+n.width+t,n.y+n.height+t);n.setToIncludePoint2D(e)}getAveragePoint(t,n){return new XYZPoint(t.reference,[(t.x+n.x)/2,(t.y+n.y)/2])}getAngle(t,n){let e=Math.atan2(n.y-t.y,n.x-t.x);if(e<0)e+=2*Math.PI;return e}boundsDontIntersectSegment(t,n,e){const o=t.copy();this.growBounds(this.toleranceEqualPoints,o);if(null===e)return!o.contains2DPoint(n);let i=n.x;let s=n.y;let r=e.x;let a=e.y;let l;if(i>r){l=i;i=r;r=l}if(s>a){l=s;s=a;a=l}const c=o.x;const u=o.y;const y=c+o.width;const h=u+o.height;if(i<c&&r<c)return true;if(i>y&&r>y)return true;if(s<u&&a<u)return true;return s>h&&a>h}getNewEditablePolyline(t,n=[]){return new XYZPolyline(t,n)}getNewEditablePolygon(t,n=[]){return new XYZPolygon(t,n)}getNewEditableBoundsFromPoint(t){return new XYZBounds(t.reference,[t.x,0,t.y,0])}getNewEditableBoundsFromBounds(t){return new XYZBounds(t.reference,[t.x,t.width,t.y,t.height])}getNewEditableBoundsFromCoordinates(t,n,e,o,i){return new XYZBounds(t,[n,o,e,i])}closestPointOnLineSegment=TopologyUtilCartesian.closestPointOnLineSegment;static closestPointOnLineSegment(t,n,e,o){const i=undefined;return CartesianClosestPointOnSegment(e,t,n,o).distance}static pointsEqualWithoutTolerance=pointsEqualWithoutTolerance}function linesParallel(t,n,e,o){const i=(n.y-t.y)*(o.x-e.x)-(n.x-t.x)*(o.y-e.y);return Math.abs(i)<EPSILON}function intersection2DLSSFCT(t,n,e,o,i){const s=t.x,r=t.y,a=n.x,l=n.y,c=e.x,u=e.y,y=o.x,h=o.y,P=(l-r)*(y-c)-(a-s)*(h-u),x=((y-c)*(u-r)-(h-u)*(c-s))/P,m=((a-s)*(u-r)-(l-r)*(c-s))/P;i.move2D(c+m*(y-c),u+m*(h-u));return m>=0&&m<=1&&x>=0&&x<=1}function pointsEqualWithoutTolerance(t,n){return Math.abs(t.x-n.x)<EPSILON&&Math.abs(t.y-n.y)<EPSILON}