import{createPoint,createPolygon}from"../shape/ShapeFactory.js";import{ProgrammingError}from"../error/ProgrammingError.js";import{isPoint}from"../shape/Point.js";import{isPolyline}from"../shape/Polyline.js";import{isPolygon}from"../shape/Polygon.js";import{isComplexPolygon}from"../shape/ComplexPolygon.js";import{isShapeList}from"../shape/ShapeList.js";import{isBounds}from"../shape/Bounds.js";class PointSegmentIterator{constructor(t){this._point=t;this._active=true}hasNext(){return this._active}next(t){t[0]=this._point;t[1]=null;this._active=false}}class PolylineSegmentIterator{constructor(t){this._polyline=t;this._index=0}hasNext(){if(0===this._polyline.pointCount)return false;else if(1===this._polyline.pointCount&&this._index<1)return true;else return this._index<this._polyline.pointCount-1}next(t){t[0]=this._polyline.getPoint(this._index++);try{t[1]=this._polyline.getPoint(this._index)}catch(e){t[1]=null}}}class PolygonSegmentIterator{constructor(t){this._polygon=t;this._index=0}hasNext(){if(0===this._polygon.pointCount)return false;else if(1===this._polygon.pointCount&&this._index<1)return true;else return this._index<this._polygon.pointCount}next(t){t[0]=this._polygon.getPoint(this._index++);try{t[1]=this._polygon.getPoint(this._index%this._polygon.pointCount)}catch(e){t[1]=null}}}class ComplexPolygonSegmentIterator{constructor(t){this._complexPolygon=t;this._polygonIndex=0;if(this._complexPolygon.polygonCount>0)this._polygonSegmentIterator=new PolygonSegmentIterator(this._complexPolygon.getPolygon(0));else this._polygonSegmentIterator=new PolygonSegmentIterator(createPolygon(this._complexPolygon.reference))}hasNext(){if(this._polygonSegmentIterator.hasNext())return true;else if(this._polygonIndex+1<this._complexPolygon.polygonCount){this._polygonSegmentIterator=new PolygonSegmentIterator(this._complexPolygon.getPolygon(++this._polygonIndex));return this.hasNext()}else return false}next(t){this._polygonSegmentIterator.next(t)}}class ShapeListSegmentIterator{constructor(t){this._shapeList=t;this._shapeListIndex=0;if(this._shapeList.shapeCount>0)this._shapeSegmentIterator=buildSegmentIterator(this._shapeList.getShape(0));else this._shapeSegmentIterator=new PolygonSegmentIterator(createPolygon(this._shapeList.reference))}hasNext(){if(this._shapeSegmentIterator.hasNext())return true;else if(this._shapeListIndex+1<this._shapeList.shapeCount){this._shapeSegmentIterator=buildSegmentIterator(this._shapeList.getShape(++this._shapeListIndex));return this.hasNext()}else return false}next(t){this._shapeSegmentIterator.next(t)}}class BoundsSegmentIterator{constructor(t){this._bounds=t;this._index=0;this._tmpPoint1=createPoint(t.reference,[0,0]);this._tmpPoint2=createPoint(t.reference,[0,0])}hasNext(){return this._index<4}next(t){switch(this._index++){case 0:this._tmpPoint1.move2D(this._bounds.x,this._bounds.y);this._tmpPoint2.move2D(this._bounds.x,this._bounds.y+this._bounds.height);break;case 1:this._tmpPoint1.move2D(this._bounds.x,this._bounds.y+this._bounds.height);this._tmpPoint2.move2D(this._bounds.x+this._bounds.width,this._bounds.y+this._bounds.height);break;case 2:this._tmpPoint1.move2D(this._bounds.x+this._bounds.width,this._bounds.y+this._bounds.height);this._tmpPoint2.move2D(this._bounds.x+this._bounds.width,this._bounds.y);break;case 3:this._tmpPoint1.move2D(this._bounds.x+this._bounds.width,this._bounds.y);this._tmpPoint2.move2D(this._bounds.x,this._bounds.y);break}t[0]=this._tmpPoint1;t[1]=this._tmpPoint2}}function buildSegmentIterator(t){if(isPoint(t))return new PointSegmentIterator(t);else if(isPolyline(t))return new PolylineSegmentIterator(t);else if(isPolygon(t))return new PolygonSegmentIterator(t);else if(isComplexPolygon(t))return new ComplexPolygonSegmentIterator(t);else if(isShapeList(t))return new ShapeListSegmentIterator(t);else if(isBounds(t))return new BoundsSegmentIterator(t);throw new ProgrammingError("Intersection calculator: Shape Type Not supported")}function boundsDontIntersectSegment(t,e,n){return n.boundsDontIntersectSegment(t,e[0],e[1])}function intersectionOrder(t,e){const n=t.intersectionPoint;const o=e.intersectionPoint;if(n.x<o.x)return-1;else if(n.x>o.x)return 1;else if(n.y<o.y)return-1;else if(n.y>o.y)return 1;else return 0}export class SegmentIntersectionCalculator{constructor(t){this._topologyUtil=t;this._tempPointArray=[]}consolidateDuplicateIntersections(t){const e=this._topologyUtil;if(t.length<2)return;t.sort(intersectionOrder);let n=0;while(n+1<t.length){const o=t[n].intersectionPoint;if(e.pointsEqual(o,t[n+1].intersectionPoint)){if(e.pointsEqual(o,t[n].intersectionSegments[0].points[1]))t[n].intersectionSegments[0]=t[n+1].intersectionSegments[0];if(e.pointsEqual(o,t[n].intersectionSegments[1].points[1]))t[n].intersectionSegments[1]=t[n+1].intersectionSegments[1];t.splice(n+1,1)}else n+=1}}segmentsIntersect(t,e,n){const o=this._topologyUtil;const i=this._tempPointArray;let s=0;let r;if(null!==t[1]&&null!==e[1]){if(o.certainlyNoInteraction4Points(t[0],t[1],e[0],e[1]))return 0;let n=t[0];let l=t[1];let h=e[0];let a=e[1];if(n.y>l.y||n.y===l.y&&n.x>l.x){r=n;n=l;l=r}if(h.y>a.y||h.y===a.y&&h.x>a.x){r=h;h=a;a=r}if(n.y>h.y||n.y===h.y&&n.x>h.x){r=n;n=h;h=r;r=l;l=a;a=r}s=o.lineSegmentIntersection(n,l,h,a,this._tempPointArray);if(0===s)if(o.pointsEqual(t[0],e[0])){s=1;i[0]=t[0].copy()}else if(null!==t[1]&&!o.certainlyNoInteraction3Points(t[0],t[1],e[0])&&o.isPointOnLineSegment(t[0],t[1],e[0])){s=1;i[0]=e[0].copy()}else if(null!==e[1]&&!o.certainlyNoInteraction3Points(e[0],e[1],t[0])&&o.isPointOnLineSegment(e[0],e[1],t[0])){s=1;i[0]=t[0].copy()}}else if(null!==t[1]){if(o.certainlyNoInteraction3Points(t[0],t[1],e[0]))return 0;if(o.isPointOnLineSegment(t[0],t[1],e[0])){s=1;i[0]=e[0].copy()}}else if(null!==e[1]){if(o.certainlyNoInteraction3Points(e[0],e[1],t[0]))return 0;if(o.isPointOnLineSegment(e[0],e[1],t[0])){s=1;i[0]=t[0].copy()}}else if(o.pointsEqual(t[0],e[0])){s=1;i[0]=t[0].copy()}for(let t=0;t<s;t++)n[t]=i[t];return s}segmentShapeIntersection(t,e,n,o){const i=[null,null];const s=[];const r=buildSegmentIterator(t);while(r.hasNext()){r.next(i);const t=this.segmentsIntersect(i,e,s);for(let e=0;e<t;e++){n.push([i[0],i[1]]);o.push(s[e])}}}calculateIntersectionPoints(t,e){const n=[];const o=[];const i=[];const s=[];const r=buildSegmentIterator(t);const l=t.bounds;const h=e.bounds;if(!l||!h)return s;while(r.hasNext()){r.next(i);if(boundsDontIntersectSegment(h,i,this._topologyUtil))continue;n.length=0;o.length=0;this.segmentShapeIntersection(e,i,n,o);for(let r=0,l=n.length;r<l;r++)s.push({intersectionPoint:o[r],intersectionSegments:[{shape:t,points:[i[0],i[1]]},{shape:e,points:n[r]}]})}this.consolidateDuplicateIntersections(s);return s}}