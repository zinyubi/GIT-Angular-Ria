import{ReferenceType}from"../../../reference/ReferenceType.js";import{GeneralPath}from"../generalpath/GeneralPath.js";import*as GeneralPathUtil from"../generalpath/GeneralPathUtil.js";import{WorldBoundaryBuilder}from"../../../transformation/WorldBoundaryBuilder.js";import{createTransformation}from"../../../transformation/TransformationFactory.js";import{isShape}from"../../../shape/Shape.js";import{ShapeType}from"../../../shape/ShapeType.js";import{buildCache}from"../../../util/Cacher.js";import{Lang}from"../../../util/Lang.js";import{OutOfBoundsError}from"../../../error/OutOfBoundsError.js";import{isComplexPolygon}from"../../../shape/ComplexPolygon.js";const isDefined=Lang.isDefined;const EPSILON=1e-5;function isEmptyGeneralPath(e){for(let t=0,n=e.subPathCount();t<n;t++)if(e.subPathLength(t)>0)return false;return true}class Geodetic2ModelTfxMap{_references=[];_transformation=[];constructor(){}get(e){for(let t=0,n=this._references.length;t<n;t++)if(this._references[t].equals(e))return this._transformation[t];return null}put(e,t){this._references.push(e);this._transformation.push(t)}}let ident=1;class PathBoundaryPosition{constructor(e,t,n){this._ident=ident++;this._subPath=e;this._posInSubPathIndex=t;this._nearestPosOnWBI=n;this._nextNeighbor=null;this._direction=1;this._correspondingBoundaryPosition=null}}function pathBoundaryPositionComparator(e,t){if(e._nearestPosOnWBI<t._nearestPosOnWBI)return-1;else if(e._nearestPosOnWBI>t._nearestPosOnWBI)return 1;else if(e._subPath<t._subPath)return-1;else if(e._subPath>t._subPath)return 1;else if(e._posInSubPathIndex<t._posInSubPathIndex)return-1;else if(e._posInSubPathIndex>t._posInSubPathIndex)return 1;return 0}class PathBoundaryPositionSet{constructor(e){this._set={};this._size=0;for(let t=0,n=e.length;t<n;t++){const n=e[t];if(!isDefined(this._set[n._ident]))this._size++;this._set[n._ident]=n}}remove(e){if(this.contains(e)){delete this._set[e._ident];this._size--}}size(){return this._size}isEmpty(){return 0===this._size}contains(e){return isDefined(this._set[e._ident])}getOne(){for(const e in this._set)if(this._set.hasOwnProperty(e))return this._set[e]}}function sanitizeSkips(e,t,n){const o=e.length;let r=false;for(let t=0;t<e.length;t++)if(e[t]===e[(t+1)%o]){r=true;break}if(!r)return;let s=Number.NEGATIVE_INFINITY;let i=-1;const a=t.length;for(let e=0;e<a;e++){length=t[(e+1)%a]._nearestPosOnWBI-t[e]._nearestPosOnWBI;length=length<0?length+n:length;if(length>s){i=e;s=length}}let h=e[i];for(let t=(i+1)%o;t!==i;t=(t+1)%o){h=!h;e[t]=h}}class _WorldBoundaryUtil{constructor(e){this._boundary=e;this._reference=e.getGeoReference();this._geodetic2Model=new Geodetic2ModelTfxMap}get boundary(){return this._boundary}getWorldBoundary(){return this._boundary}fixPathForFillAndStroke(e,t,n){let o;if(!this._crossesBoundary(e)){o=this._fixPathNotCrossingBoundary(e,t,n);return[o,o]}if(isComplexPolygon(t)&&t.polygonCount>1)o=e;else o=GeneralPathUtil.ensurePathStartsAtBoundary(e);return[this._closeAndMergeSubPathsWithWorldBoundary(o,t,n),o]}_crossesBoundary(e){const t=e.subPathCount();for(let n=0;n<t;n++)if(this._crossesSubPathBoundary(e,n))return true;return false}_crossesSubPathBoundary(e,t){const n=e.subPathLength(t);if(n<2)return false;const o=e.getX(t,n-1)-e.getX(t,0);const r=e.getY(t,n-1)-e.getY(t,0);return o*o+r*r>=EPSILON*EPSILON}_fixPathNotCrossingBoundary(e,t,n){if(ShapeType.contains(ShapeType.CIRCLE,t.type)||ShapeType.contains(ShapeType.BOUNDS,t.type)||ShapeType.contains(ShapeType.ELLIPSE,t.type)||ShapeType.contains(ShapeType.ARC_BAND,t.type)||ShapeType.contains(ShapeType.SECTOR,t.type)||isEmptyGeneralPath(e)){const e=undefined;if(1===this._getContainmentCount(0,0,1,1,t,this._getGeodetic2ModelTransformation(n),n))return this._getWorldBoundaryGeneralPath()}return e}_getContainmentCount(e,t,n,o,r,s,i){const a=this._boundary.getBoundary();const h=Math.abs(e-t);const u=a.length-h;let l=h,d=0,c,f;if(e>t&&o>0)l=u;else if(e<t&&o<0)l=u;for(let t=1;t<=n;t++){f=e+o*Math.floor(t*l/(n+1));if(f<0)f+=a.length;else if(f>=a.length)f-=a.length;c=a[f].modelPoint;try{const e=s.transform(c);if(isShape(r)&&r.bounds)if(r.contains2DPoint(e))d++}catch(e){OutOfBoundsError.isOrThrow(e)}}return d}_getGeodetic2ModelTransformation(e){let t=this._geodetic2Model.get(e);if(null==t){t=createTransformation(this._boundary.getGeoReference(),e);this._geodetic2Model.put(e,t)}return t}_getWorldBoundaryGeneralPath(){const e=new GeneralPath;let t=true;const n=this._boundary.getBoundary();const o=n.length;for(let r=0;r<o;r++){const o=n[r].worldPoint;t=this._addPoint(e,o.x,o.y,t)}e.breakPolygon();return e}_addPoint(e,t,n,o){if(o)e.moveTo(t,n,0);else e.lineTo(t,n,0);return false}_closeAndMergeSubPathsWithWorldBoundary(e,t,n){const o=this._getGeodetic2ModelTransformation(n);const r=this._getSortedBoundaryPoints(e);const s=[];const i=r.length;if(0===i)return e;const a=new GeneralPath;for(let e=0;e<i;e++){const a=r[e]._nearestPosOnWBI;const h=r[(e+1)%i]._nearestPosOnWBI;s[e]=this._skip(a,h,t,o,n)}sanitizeSkips(s,r,this._boundary.getBoundary().length);let h=this._robustSkip(s);for(let e=0;e<i;e++){let t=h?e-1:e+1;if(t<0)t+=i;else if(t>=i)t-=i;r[e]._nextNeighbor=r[t];r[e]._direction=h?-1:1;h=!h}const u=new PathBoundaryPositionSet(r);const l=[];for(let t=0,n=e.subPathCount();t<n;t++)l.push(t);let d=r[0];let c=true;while(d&&u.size()>0){const t=e.subPathLength(d._subPath);let n=-1;let o=-1;if(0===d._posInSubPathIndex){n=1;o=t}for(let t=d._posInSubPathIndex;t!==o;t+=n)c=this._addPosition(a,e.getX(d._subPath,t),e.getY(d._subPath,t),c);const r=d._correspondingBoundaryPosition;u.remove(d);u.remove(r);l.splice(l.indexOf(d._subPath),1);const s=r._nextNeighbor;const i=r._direction;let h=r._nearestPosOnWBI;let f=s._nearestPosOnWBI;const _=this._boundary.getBoundary();if(f<h&&i>0)f+=_.length;else if(f>h&&i<0)h+=_.length;for(let e=h;e!==f;e+=i){const t=_[e%_.length].worldPoint;c=this._addPoint(a,t.x,t.y,c)}if(!u.contains(s)){a.closePolygon();c=true;if(u.isEmpty())break;d=u.getOne()}else d=s}for(let t=0;t<l.length;t++)GeneralPathUtil.addSubPathToSFCT(e,l[t],a);return a}_getSortedBoundaryPoints(e){const t=[];const n=e.subPathCount();for(let o=0;o<n;o++)this._addBoundaryPoints(e,o,t);t.sort(pathBoundaryPositionComparator);return t}_addBoundaryPoints(e,t,n){if(!this._crossesSubPathBoundary(e,t))return;const o=e.subPathLength(t);const r={x:e.getX(t,0),y:e.getY(t,0),z:0};const s={x:e.getX(t,o-1),y:e.getY(t,o-1),z:0};const i=this._getClosestIndex(r);const a=this._getClosestIndex(s);const h=new PathBoundaryPosition(t,0,i);const u=new PathBoundaryPosition(t,o-1,a);h._correspondingBoundaryPosition=u;u._correspondingBoundaryPosition=h;n.push(h);n.push(u)}_getClosestIndex(e){const t=this._boundary.getClosestBoundaryPosition(e);return null==t?0:t.index}_skip(e,t,n,o,r){const s=undefined;return this._getContainmentCount(e,t,1,1,n,o,r)<=0}_robustSkip(e){const t=[0,0];for(let n=0,o=e.length;n<o;n++)if(e[n])t[n%2]++;return t[0]>t[1]}_addPosition(e,t,n,o){if(o)e.moveTo(t,n);else e.lineTo(t,n);return false}}const cache=buildCache();export const WorldBoundaryUtil={getInstance(e){const t=e.name;if(e.referenceType===ReferenceType.CARTESIAN||e.referenceType===ReferenceType.GEOCENTRIC)return{getWorldBoundary:()=>null,fixPathForFillAndStroke:(e,t,n)=>[e,e]};let n;if(""!==t){if(!(n=cache.get(t))){n=WorldBoundaryBuilder.build(e);cache.cache(t,n)}}else n=WorldBoundaryBuilder.build(e);return new _WorldBoundaryUtil(n)}};