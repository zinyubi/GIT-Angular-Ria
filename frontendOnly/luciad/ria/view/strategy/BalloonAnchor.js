import{EventedSupport}from"../../util/EventedSupport.js";import{createPoint}from"../../shape/ShapeFactory.js";import{ChainedTransformation}from"../../transformation/ChainedTransformation.js";import{LocationMode}from"../../transformation/LocationMode.js";import{createTransformation}from"../../transformation/TransformationFactory.js";import{getZStyleForPoint}from"../feature/photon/command/ZStyleUtil.js";import{DrapeTarget}from"../style/DrapeTarget.js";import{ProgrammingError}from"../../error/ProgrammingError.js";function isObjectWithShape(e){return!!e?.shape?.focusPoint}function isFeatureLayer(e){return!!(e&&e.workingSet)}function getFeatureNode(e,t){return isFeatureLayer(e)?e.workingSet.getNode(t):null}export class BalloonAnchor extends EventedSupport{_handles=[];_anchorPoint=null;constructor(e,t,o,r){super(["changed","removed"],false);this._map=e;this._layer=t;this._tmpPoint=createPoint(e.reference,[0,0]);this._handles.push(e.layerTree.on("NodeRemoved",(e=>{if(t===e.node){this._anchorPoint=null;this.emit("removed")}})));if(t)this._handles.push(t.on("VisibilityChanged",(t=>{if(!t)e.hideBalloon()})));const n=o?getFeatureNode(t,o.id):null;if(n&&isFeatureLayer(t)&&o)this._handles.push(t.workingSet.on("WorkingSetChanged",((e,r,n)=>{if("add"===e||"update"===e){if(n===o.id){const e=getFeatureNode(t,n);this.setAnchorPoint(e?.shape?.focusPoint??null);this.emit("changed",r)}}else if("remove"===e){if(n===o.id){this._anchorPoint=null;this.emit("removed")}}else if("clear"===e){this._anchorPoint=null;this.emit("removed")}})));if(r)this.setAnchorPoint(r);else if(n)this.setAnchorPoint(n.shape?.focusPoint);else if(isObjectWithShape(o))this.setAnchorPoint(o.shape.focusPoint);else{const[t,o]=e.viewSize;this.setAnchorPoint(createPoint(null,[t/2,o/2]))}}setAnchorPoint(e){const t=this._map.reference;if(!e)this._anchorPoint=null;else if(!e.reference){const o=new ChainedTransformation(this._map.getViewToMapTransformation(LocationMode.TERRAIN),createTransformation(t,t,{normalizeWrapAround:this._map.wrapAroundWorld}));this._anchorPoint=o.transform(e)}else if(t.equals(e.reference))this._anchorPoint=e;else{const t=getZStyleForPoint(e,void 0,DrapeTarget.NOT_DRAPED,this._map.is3D(),this._map.reference);const o=undefined;const r=t.drapeTarget!==DrapeTarget.NOT_DRAPED||t.aboveGround?this._map.getOnTerrainModelWorldTransformation(e.reference):createTransformation(e.reference,this._map.reference);try{this._anchorPoint=r.transform(e,this._tmpPoint)}catch(e){throw new ProgrammingError("BalloonStrategy::cannot transform anchor point to map coordinates.")}}}getPoint(){return this._anchorPoint}destroy(){this._handles.forEach((e=>e.remove()))}async emitEvent(e){if(e&&this._layer)await this._layer.whenReady();this._map.emit("ShowBalloon")}}