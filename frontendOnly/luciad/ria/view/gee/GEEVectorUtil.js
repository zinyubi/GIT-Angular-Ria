import{isUndefined}from"../../util/Lang.js";const SIZE_OF_POINT=3*8;const SIZE_OF_GEOMETRY_TYPE=4;const SIZE_OF_AMOUNT_POINTS=4;export let PacketType=function(e){e[e["TYPE_STREETPACKET"]=2]="TYPE_STREETPACKET";e[e["TYPE_SITEPACKET"]=3]="TYPE_SITEPACKET";e[e["TYPE_DRAWABLEPACKET"]=4]="TYPE_DRAWABLEPACKET";e[e["TYPE_POLYLINEPACKET"]=5]="TYPE_POLYLINEPACKET";e[e["TYPE_AREAPACKET"]=6]="TYPE_AREAPACKET";e[e["TYPE_STREETPACKET_UTF8"]=7]="TYPE_STREETPACKET_UTF8";e[e["TYPE_SITEPACKET_UTF8"]=8]="TYPE_SITEPACKET_UTF8";e[e["TYPE_LANDMARKPACKET"]=9]="TYPE_LANDMARKPACKET";e[e["TYPE_POLYGONPACKET"]=10]="TYPE_POLYGONPACKET";return e}({});export let GeometryType=function(e){e[e["POINT"]=0]="POINT";e[e["POLYLINE"]=1]="POLYLINE";e[e["POLYGON"]=2]="POLYGON";e[e["AREA"]=3]="AREA";return e}({});export let StyleType=function(e){e[e["TYPE_FILL_ONLY"]=1]="TYPE_FILL_ONLY";e[e["TYPE_OUTLINE_ONLY"]=2]="TYPE_OUTLINE_ONLY";e[e["TYPE_FILL_AND_OUTLINE"]=3]="TYPE_FILL_AND_OUTLINE";e[e["TYPE_ANTIALIASING"]=4]="TYPE_ANTIALIASING";e[e["TYPE_CENTER_LABEL"]=5]="TYPE_CENTER_LABEL";return e}({});export function extractPoints(e,t,E,n){const T=new ArrayBuffer(3*E*8);const r=new Int8Array(T,0);const P=e.slice(t+n,t+n+3*E*8);r.set(new Int8Array(P));return T}export function isPolygonOnEdges(e){return-1!==e.indexOf(1)}export function appendToBuffer(e,t){const E=e.byteLength;const n=new ArrayBuffer(E+t.byteLength);const T=new Int8Array(n,0);T.set(new Int8Array(e));T.set(new Int8Array(t),E);return n}export function getPolylinesFromPolygon(e,t,E){const n=[];let T=new ArrayBuffer(0);for(let E=0;E<t.length;E++)if(!t[E]){if(0===T.byteLength)T=appendToBuffer(T,e.slice(E*SIZE_OF_POINT,(E+1)*SIZE_OF_POINT));let t=(E+1)*SIZE_OF_POINT;if(t>e.byteLength)t=0;T=appendToBuffer(T,e.slice(t,t+SIZE_OF_POINT))}else if(T.byteLength>0){n.push(T);T=new ArrayBuffer(0)}if(T.byteLength>0)n.push(T);function r(e){let t=new ArrayBuffer(0);for(let n=0;n<e.length;n++){const T=undefined;t=appendToBuffer(t,createDataBuffer(e[n],GeometryType.POLYLINE,e[n].byteLength/SIZE_OF_POINT,E))}return t}return{amountOfShapes:n.length,buffer:r(n)}}export function createDataBuffer(e,t,E,n){const T=isUndefined(n)?0:4;const r=SIZE_OF_GEOMETRY_TYPE+SIZE_OF_AMOUNT_POINTS+T;const P=SIZE_OF_GEOMETRY_TYPE+T;const _=new ArrayBuffer(r+e.byteLength);const A=new DataView(_);A.setUint32(0,t,true);if(!E)E=e.byteLength;if(!isUndefined(n))A.setUint32(SIZE_OF_GEOMETRY_TYPE,n,true);A.setUint32(P,E,true);new Uint8Array(_).set(new Uint8Array(e),r);return _}