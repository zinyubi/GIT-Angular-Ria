import{Constants}from"../../util/Constants.js";import{OutOfBoundsError}from"../../error/OutOfBoundsError.js";import{XYZPoint}from"../../shape/XYZPoint.js";import{DrawBaseLabelHtmlContents}from"./DrawBaseLabelHtmlContents.js";import{INVALID_POSITION,LabelPositions}from"./LabelPositions.js";import{AnchorPoints}from"./AnchorPoints.js";import{PathLabelRotation}from"./PathLabelRotation.js";import{drawNullCommand}from"./NullDrawCommand.js";import{INVALID_LAYER_CLIP}from"../LayerStyle.js";const anchorPoints=new AnchorPoints;const tmpOutCoord1=new XYZPoint(null,[0,0,0]);const tmpOutCoord2=new XYZPoint(null,[0,0,0]);const tmpInCoord1=new XYZPoint(null,[0,0,0]);const tmpInCoord2=new XYZPoint(null,[0,0,0]);export class DrawOnPathLabelHtmlContents extends DrawBaseLabelHtmlContents{previousAnchorOrientationPoint=new XYZPoint(null,[0,0,0]);previousAnchorPoint=new XYZPoint(null,[0,0,0]);_labelWidth=10;constructor(t,o,n,i,s,r,e){super(n,o,t,i,s,e.padding,r);if(n.refreshGeometryHash)n.refreshGeometryHash();this._fAngle=0;this._fSinAngle=0;this._fCosAngle=0;this._positions=e.positions;this._fLabelRotation=e.rotation;this._perpendicularOffset=e.perpendicularOffset||0}requestToDrawLabel(t){this.clip=t??INVALID_LAYER_CLIP;this.group.addLabel(this)}placeHtml(t,o,n,i){if(!this.drawCommand||this.drawCommand===drawNullCommand)return false;this.zOrder=i;let s=false;if(this.previousPosition!==INVALID_POSITION)s=this.tryPreviousLabelAnchor(o,n);if(!s)s=this.tryAllLabelAnchorsAndPaint(o,n);if(s){if(this.isValidLocation(this.previousAnchorPoint)){this.toScreen(t);return true}this.previousPosition=INVALID_POSITION}return false}tryAllLabelAnchorsAndPaint(t,o){try{anchorPoints.reset();this.drawCommand?.mapAnchorPointsSFCT(t,anchorPoints,this._labelWidth)}catch(t){OutOfBoundsError.isOrThrow(t);return false}const n=this.labelContext.mapToViewTransformation;for(let t=0;t<anchorPoints.anchorPointsLength;t++){updateAnchor(tmpInCoord1,anchorPoints.anchorPoints,3*t);updateAnchor(tmpInCoord2,anchorPoints.anchorOrientationPoints,3*t);if(!this.drawCommand?.viewPointSFCT(tmpInCoord1,tmpOutCoord1,n)||!this.drawCommand?.viewPointSFCT(tmpInCoord2,tmpOutCoord2,n))continue;this.setAngle(tmpOutCoord1,tmpOutCoord2);const i=this.findLabelPosition(tmpOutCoord1,INVALID_POSITION,o,this._positions);if(i!==INVALID_POSITION){this.previousPosition=i;updateAnchor(this.previousAnchorPoint,tmpInCoord1.coordinates);updateAnchor(this.previousAnchorOrientationPoint,tmpInCoord2.coordinates);return true}}this.previousPosition=INVALID_POSITION;return false}setAngle(t,o){if(this._fLabelRotation===PathLabelRotation.NO_ROTATION||t.x===o.x&&t.y===o.y&&t.z===o.z){this._fAngle=0;this._fCosAngle=1;this._fSinAngle=0}else{let n=Math.atan2(o.y-t.y,o.x-t.x)*Constants.RAD2DEG;n=n>90?n-180:n;n=n<-90?n+180:n;this._fAngle=n;this._fCosAngle=Math.cos(Constants.DEG2RAD*n);this._fSinAngle=Math.sin(Constants.DEG2RAD*n)}}tryPreviousLabelAnchor(t,o){const n=this.labelContext.mapToViewTransformation;try{if(!this.drawCommand?.viewPointSFCT(this.previousAnchorPoint,tmpOutCoord1,n)||!this.drawCommand?.viewPointSFCT(this.previousAnchorOrientationPoint,tmpOutCoord2,n)){this.previousPosition=INVALID_POSITION;return false}this.setAngle(tmpOutCoord1,tmpOutCoord2);const t=this.findLabelPosition(tmpOutCoord1,this.previousPosition,o,this._positions);if(t!==INVALID_POSITION){this.previousPosition=t;if(null!==o)o.addPosition(this);return true}else{this.previousPosition=INVALID_POSITION;return false}}catch(t){OutOfBoundsError.isOrThrow(t);this.previousPosition=INVALID_POSITION;return false}}resetLabelBounds(t,o){const{boundsWidth:n,ascent:i,descent:s}=this.getBoundMetrics();const r=n;const e=r/2;const a=i/2;let h=t.x-e*this._fCosAngle;let l=t.y-e*this._fSinAngle;if(o===LabelPositions.ON_PATH_CENTER_SHIFT){h-=a*this._fSinAngle;l+=a*this._fCosAngle}else if(o===LabelPositions.ON_PATH_BELOW_SHIFT){h-=i*this._fSinAngle;l+=i*this._fCosAngle}this.setLTRBAnchorAngleDeg(h,l-i-this._perpendicularOffset,h+r,l+s-this._perpendicularOffset,h,l,this._fAngle,this._padding)}reuseStateFrom(t){if(!this.drawCommand)return;const o=t.findLabelDrawCommand(this.drawCommand,DrawOnPathLabelHtmlContents);if(o?.drawCommand?.hasSameGeometry(this.drawCommand)){this.previousPosition=o.previousPosition;updateAnchor(this.previousAnchorPoint,o.previousAnchorPoint.coordinates);updateAnchor(this.previousAnchorOrientationPoint,o.previousAnchorOrientationPoint.coordinates)}}computeMetrics(){const{boundsWidth:t}=this.computeMetricsBase();this._labelWidth=t}toScreen(t){this.toScreenBase(t)}}function updateAnchor(t,o,n=0){t.x=o[n];t.y=o[n+1];t.z=o[n+2]}