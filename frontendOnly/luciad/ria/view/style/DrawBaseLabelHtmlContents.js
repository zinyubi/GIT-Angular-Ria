import{isString,isNumber}from"../../util/Lang.js";import{RotatedBox}from"../../util/RotatedBox.js";import{PickInfoImpl}from"../PickInfo.js";import{ConflictType}from"./LabelConflictChecker.js";import{INVALID_POSITION}from"./LabelPositions.js";import{INVALID_LAYER_CLIP}from"../LayerStyle.js";import{ProgrammingError}from"../../error/ProgrammingError.js";import{calculateBounds}from"./HTMLMetrics.js";import{VisibilityType}from"./VisibilityType.js";import{OcclusionMode}from"./OcclusionMode.js";import{Hash}from"../../util/Hash.js";const tmpBounds=[];export class DrawBaseLabelHtmlContents extends RotatedBox{_zOrder=null;constructor(t,e,i,s,n,o,r){super();this._html=e;this._handle=null;this._index=0;this._clip=INVALID_LAYER_CLIP;this.drawCommand=t;this.labelContext=i;this.group=s;this._padding=o;this.priority=n;this.selected=r;this._previousPosition=INVALID_POSITION;this._boundMetrics=null;this._alwaysVisible=this.drawCommand?.getOcclusionHintForLabel()===OcclusionMode.ALWAYS_VISIBLE}get handle(){return this._handle}set handle(t){this._handle=t}get index(){if(0===this._index&&this._feature?.id){const t=new Hash;const e=this._feature.id;isString(e)?t.appendString(e):t.appendUInt32(e);this._index=t.getHashCode()}return this._index}get clip(){return this._clip}set clip(t){this._clip=t}get previousPosition(){return this._previousPosition}set previousPosition(t){this._previousPosition=t}set zOrder(t){if(isNumber(t))this._zOrder=t}get html(){return this._html}setPickInfoContext(t,e){this._layer=t;this._feature=e}isReady(){return!!this.drawCommand?.isReady()}pickTouched(t,e,i,s,n,o,r){if(this.handle?.div&&this._layer&&r(this._layer))return this.pickSoftRotated(t,i,s)||this.pickCssRotated(e,i,s,n,o);return null}pickSoftRotated(t,e,i){return this._layer&&this._feature&&t.intersects(this)?new PickInfoImpl(this._layer,this._feature,this.squaredDistanceToEdge(e,i),this.squaredDistanceToCenter(e,i),0,0,false,false):null}pickCssRotated(t,e,i,s,n){const o=this.handle?.div?.firstElementChild||null;if(this._layer&&this._feature&&o&&!this.getRotation()){const r=o.getBoundingClientRect();const l=r.left;const h=r.top;const a=t.left+e;const d=t.top+i;const c=s/2;const u=n/2;const f=Math.max(edgeDifference(a,l),edgeDifference(l+r.width,a));const m=Math.max(edgeDifference(d,h),edgeDifference(h+r.height,d));if(f<=c&&m<=u){const t=f*f+m*m;return new PickInfoImpl(this._layer,this._feature,t,t,0,0,false,false)}}return null}canBeReused(){return!this.labelContext.isMultipleWorldsVisible}isValidLocation(t,e){if(this._alwaysVisible)return true;const i=this.labelContext.getVisibilityType(t);const s=!!this.drawCommand?.isValidLocation(t,i);if(e&&i===VisibilityType.FOREGROUND)return s&&this.labelContext.distanceToSurfaceVisibility(t);return s}findLabelPosition(t,e,i,s){let n=INVALID_POSITION;if(e!==INVALID_POSITION&&s.indexOf(e)>=0){this.resetLabelBounds(t,e);const s=i.isValidPosition(this,this.clip);if(s===ConflictType.NO_CONFLICT)return e;else if(s===ConflictType.PARTIALLY_OUTSIDE_VIEW)n=e}let o=false;for(let e=0;e<s.length;e++){const r=s[e];this.resetLabelBounds(t,r);const l=i.isValidPosition(this,this.clip);if(l===ConflictType.NO_CONFLICT)return r;else if(l===ConflictType.PARTIALLY_OUTSIDE_VIEW){o=true;n=n===INVALID_POSITION?r:n}}if(o){this.resetLabelBounds(t,n);return n}return INVALID_POSITION}getBoundMetrics(){if(!this._boundMetrics)this.computeMetrics();if(this._boundMetrics)return this._boundMetrics;throw new ProgrammingError("Error while placing label: missing metrics")}setMetrics(t){this._boundMetrics={boundsWidth:t[2]-t[0],boundsHeight:t[3]-t[1],ascent:Math.abs(t[1]),descent:t[3],boundsX:t[0],boundsViewX:0,boundsViewY:0};return this.getBoundMetrics()}reuseMetrics(t){this._boundMetrics={boundsWidth:t.labelWidth,boundsHeight:t.labelHeight,ascent:t.ascent,descent:t.descent,boundsX:0,boundsViewX:0,boundsViewY:0}}findLabelDrawCommand(t,e){return this.drawCommand?.isEquivalent(t)&&this instanceof e?this:null}toScreenBase(t,e=0,i=0,s){const{boundsWidth:n,boundsHeight:o}=this.getBoundMetrics();const r=this.getLeft();const l=this.getTop();const h=this.getAngleInDegrees();if(null===this.handle)this.handle=t.placeHtmlInDom(this,this.html,r,l,h,n,o,e,i,s,this._zOrder);else t.modifyHtmlPositionInDom(this.handle,r,l,h,n,o,e,i,this._zOrder)}computeMetricsBase(t=false){calculateBounds(this.html,"top","left",tmpBounds,t);return this.setMetrics(tmpBounds)}}function edgeDifference(t,e){const i=e-t;return i>=0?i:0}