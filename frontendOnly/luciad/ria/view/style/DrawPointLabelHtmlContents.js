import{isArray,isUndefined}from"../../util/Lang.js";import{Constants}from"../../util/Constants.js";import{XYZPoint}from"../../shape/XYZPoint.js";import{DrawBaseLabelHtmlContents}from"./DrawBaseLabelHtmlContents.js";import{INVALID_POSITION,LabelPositions}from"./LabelPositions.js";import{drawNullCommand}from"./NullDrawCommand.js";import{INVALID_LAYER_CLIP}from"../LayerStyle.js";const anchorPoint=new XYZPoint;const coord=new XYZPoint;export class DrawPointLabelHtmlContents extends DrawBaseLabelHtmlContents{constructor(t,s,o,i,n,e,a){super(o,s,t,i,n,a.padding,e);this._positions=a.positions;this._offset=a.offset;this._rotation=a.rotation||0;this._anchorX=a.anchorX;this._anchorY=a.anchorY;this._pin=a.pin||void 0}requestToDrawLabel(t){this.clip=t??INVALID_LAYER_CLIP;this.group.addLabel(this)}computeMetrics(){this.computeMetricsBase()}toScreen(t){const{boundsViewX:s,boundsViewY:o}=this.getBoundMetrics();this.toScreenBase(t,s,o,this._pin)}placeHtml(t,s,o,i){if(!this.drawCommand||this.drawCommand===drawNullCommand)return false;this.zOrder=i;if(!this.drawCommand.mapAnchorPointSFCT(s,anchorPoint))return false;const n=this.labelContext.mapToViewTransformation;if(!this.drawCommand.viewPointSFCT(anchorPoint,coord,n))return false;if(n.isPaintToBorder&&!n.canDrawCoord(coord))return false;coord.y-=this.labelContext.getTopOffset();const e=this.findLabelPosition(coord,this.previousPosition,o,this._positions);if(s.wrapAroundWorld)this._handle=null;if(e!==INVALID_POSITION&&this._boundMetrics){this._boundMetrics.boundsViewX=coord.x;this._boundMetrics.boundsViewY=coord.y;this.previousPosition=e;if(this.isValidLocation(anchorPoint,true)){this.toScreen(t);return true}}return false}resetLabelBounds(t,s){const{boundsWidth:o,boundsHeight:i,ascent:n,descent:e}=this.getBoundMetrics();const a=o;const r=i;let d,h;let c=0;let l=[0,0];if(isArray(this._offset))l=this._offset;else c=this._offset||0;if(!isUndefined(this._anchorX)||!isUndefined(this._anchorX)){d=-(this._anchorX??0)*a;h=(1-(this._anchorY??0))*r}else switch(s){case LabelPositions.POINT_C_SHIFT:d=-(a>>1);h=n>>1;break;case LabelPositions.POINT_E_SHIFT:d=c;h=n>>1;break;case LabelPositions.POINT_W_SHIFT:d=-a-c;h=n>>1;break;case LabelPositions.POINT_N_SHIFT:d=-(a>>1);h=-c;break;case LabelPositions.POINT_S_SHIFT:d=-(a>>1);h=n+c;break;case LabelPositions.POINT_SE_SHIFT:d=Constants.COS_45*c;h=n+Constants.SIN_45*c;break;case LabelPositions.POINT_NW_SHIFT:d=-a-Constants.COS_45*c;h=-Constants.SIN_45*c;break;case LabelPositions.POINT_SW_SHIFT:d=-a-Constants.COS_45*c;h=n+Constants.SIN_45*c;break;default:d=Constants.COS_45*c;h=-Constants.SIN_45*c}d+=l[0];h+=l[1];const _=t.x+d;const m=t.y+h;this.setLTRBAnchorAngleDeg(_,m-n,_+a,m+e,t.x,t.y,this._rotation,this._padding)}reuseStateFrom(t){if(this.drawCommand){const s=t.findLabelDrawCommand(this.drawCommand,DrawPointLabelHtmlContents);if(s)this.previousPosition=s.previousPosition}}}