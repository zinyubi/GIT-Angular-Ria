import{EventedSupport}from"../../util/EventedSupport.js";function checkLimit(t){if(t<=0)throw new Error(`UndoManager.limit must be strictly positive, but got ${t}`)}export class UndoManager{constructor(t=10){this._undoStack=[];this._redoStack=[];checkLimit(t);this._limit=t;this._eventedSupport=new EventedSupport(["UndoStackChanged","RedoStackChanged","LimitChanged"])}canUndo(){return this._undoStack.length>=1}undo(){if(this._undoStack.length>0){const t=this._undoStack.pop();if(t)try{t.undo()}finally{this._redoStack.push(t);this._eventedSupport.emit("UndoStackChanged");this._eventedSupport.emit("RedoStackChanged")}}}canRedo(){return this._redoStack.length>=1}redo(){if(this._redoStack.length>0){const t=this._redoStack.pop();if(t)try{t.redo()}finally{this._undoStack.push(t);this._eventedSupport.emit("UndoStackChanged");this._eventedSupport.emit("RedoStackChanged")}}}push(t){this._undoStack.push(t);this._redoStack=[];this.enforceLimit();this._eventedSupport.emit("UndoStackChanged")}get limit(){return this._limit}set limit(t){checkLimit(t);if(t!==this._limit){this._limit=t;const e=this._undoStack.length;this.enforceLimit();this._eventedSupport.emit("LimitChanged");if(this._undoStack.length!==e)this._eventedSupport.emit("UndoStackChanged")}}get undoStack(){return Array.from(this._undoStack)}get redoStack(){return Array.from(this._redoStack)}reset(){const t=this._undoStack.length;this._undoStack=[];const e=this._redoStack.length;this._redoStack=[];if(this._undoStack.length!==t)this._eventedSupport.emit("UndoStackChanged");if(this._redoStack.length!==e)this._eventedSupport.emit("RedoStackChanged")}on(t,e){return this._eventedSupport.on(t,e)}enforceLimit(){if(this._limit>=0){let t=this._undoStack.length;while(t>this._limit){this._undoStack.splice(0,1);t--}}}}