import{OutOfBoundsError}from"../../../error/OutOfBoundsError.js";import{isDefined}from"../../../util/Lang.js";import{URL}from"../../../util/URL.js";import{ShapeType}from"../../../shape/ShapeType.js";import{createPoint}from"../../../shape/ShapeFactory.js";import{createTransformation}from"../../../transformation/TransformationFactory.js";import{ModifierType}from"../../input/ModifierType.js";import{distance2D_xy}from"../../../util/Cartesian.js";import{isBezierCurve}from"../../../shape/BezierCurve.js";const tempViewPoint=createPoint(null,[]);const ELLIPSE_SNAP_TARGET_COUNT=5;function getClosestPointFromShapeToMouseCoordinatesSFCT(e,t,n,o,i,a,s,r,c){if(e.type===ShapeType.POINT)buildClosestDistanceAndPointObject(e,e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c);else switch(e.type){case ShapeType.POLYLINE:case ShapeType.POLYGON:{const p=e;for(let l=0;l<p.pointCount;l++){const T=undefined;buildClosestDistanceAndPointObject(p.getPoint(l),e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c)}break}case ShapeType.GEO_BUFFER:{const p=e.baseShape;for(let l=0;l<p.pointCount;l++){const T=undefined;buildClosestDistanceAndPointObject(p.getPoint(l),e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c)}break}case ShapeType.EXTRUDED_SHAPE:getClosestPointFromShapeToMouseCoordinatesSFCT(e.baseShape,t,n,o,i,a,s,r,c);break;case ShapeType.SHAPE_LIST:{const p=e;for(let e=0;e<p.shapeCount;e++)getClosestPointFromShapeToMouseCoordinatesSFCT(p.getShape(e),t,n,o,i,a,s,r,c);break}case ShapeType.ELLIPSE:for(let p=0;p<ELLIPSE_SNAP_TARGET_COUNT;p++){const l=undefined;buildClosestDistanceAndPointObject(getEllipseSnapTarget(e,p),e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c)}break;case ShapeType.ARC:{const p=e;const l=[p.startPoint,p.endPoint,p.center];for(let p=0;p<l.length;p++)buildClosestDistanceAndPointObject(l[p],e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c);break}case ShapeType.ARC_BAND:{const p=e;const l=[p.center,p.maxRadiusStartCorner,p.maxRadiusEndCorner,p.minRadiusStartCorner,p.minRadiusEndCorner];for(let p=0;p<l.length;p++)buildClosestDistanceAndPointObject(l[p],e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c);break}case ShapeType.SECTOR:{const p=e;const l=[p.center,p.radiusStartCorner,p.radiusEndCorner];for(let p=0;p<l.length;p++)buildClosestDistanceAndPointObject(l[p],e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c);break}case ShapeType.BOUNDS:{const p=e;const l=[createPoint(e.reference,[p.x,p.y]),createPoint(e.reference,[p.x+p.width,p.y]),createPoint(e.reference,[p.x,p.y+p.height]),createPoint(e.reference,[p.x+p.width,p.y+p.height]),createPoint(e.reference,[p.x+p.width/2,p.y+p.height/2])];for(let p=0;p<l.length;p++)buildClosestDistanceAndPointObject(l[p],e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c);break}default:getClosestPointFromComplexShapeToMouseCoordinatesSFCT(e,t,n,o,i,a,s,r,c)}}function getClosestPointFromComplexShapeToMouseCoordinatesSFCT(e,t,n,o,i,a,s,r,c){if(ShapeType.contains(ShapeType.CIRCLE,e.type)){buildClosestDistanceAndPointObject(e.center,e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c);if(ShapeType.contains(ShapeType.CIRCLE_BY_3_POINTS,e.type)){const p=e;buildClosestDistanceAndPointObject(p.firstPoint,e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c);buildClosestDistanceAndPointObject(p.secondPoint,e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c);buildClosestDistanceAndPointObject(p.thirdPoint,e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c)}}else if(ShapeType.contains(ShapeType.CIRCULAR_ARC,e.type)){const p=e;buildClosestDistanceAndPointObject(p.startPoint,e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c);buildClosestDistanceAndPointObject(p.endPoint,e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c);if(ShapeType.contains(ShapeType.CIRCULAR_ARC_BY_3_POINTS,e.type))buildClosestDistanceAndPointObject(p.intermediatePoint,e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c)}else if(isBezierCurve(e)){const p=e;const l=[p.getStartPoint(),p.getEndPoint()];for(let p=0;p<l.length;p++)buildClosestDistanceAndPointObject(l[p],e,t,n,o,i,c.distance,a,s.mapToViewTransformation,r,c)}}function buildClosestDistanceAndPointObject(e,t,n,o,i,a,s,r,c,p,l){if(!isDefined(o)||!t.equals(o)||canSnapToItsOwnPoints(t))if(!(e===n)){const t=isCloserThanDistance(e,i,a,s,r,c,p);if(null!==t){l.distance=t;l.point=e}}}function canSnapToItsOwnPoints(e){return ShapeType.contains(ShapeType.POLYLINE,e.type)||ShapeType.contains(ShapeType.POLYGON,e.type)||ShapeType.contains(ShapeType.GEO_BUFFER,e.type)}function isCloserThanDistance(e,t,n,o,i,a,s){try{i.transform(e,s);a.transform(s,tempViewPoint);const r=distance2D_xy(t,n,tempViewPoint.x,tempViewPoint.y);return r<o?r:null}catch(e){OutOfBoundsError.isOrThrow(e);return null}}function getEllipseSnapTarget(e,t){switch(t){case 0:return e.center;case 1:return e.interpolate(0);case 2:return e.interpolate(.25);case 3:return e.interpolate(.5);default:return e.interpolate(.75)}}export function findClosestPoint(e,t,n,o,i=false){const a=e.viewPosition[0];const s=e.viewPosition[1];const r="touch"===e.inputType?20:10;const c=o._pickRect(a,s,r,r,false,true,(()=>true));const p=createPoint(o.reference,[]);const l={distance:2*r,point:null};let T;let d;let f;let S;let u;let m,C;if(null!==c&&c.length>0&&e.modifier!==ModifierType.CTRL)for(m=0;m<c.length;m++){T=c[m];if(T.layer.isSnapTarget){d=T.layer;S=o.getOnTerrainModelWorldTransformation(d.model.reference);for(C=0;C<T.objects.length;C++){f=T.objects[C];if(f.shape)getClosestPointFromShapeToMouseCoordinatesSFCT(f.shape,t,n,a,s,S,o,p,l)}}}let P=l.point;if(null!==P&&isDefined(n)&&null!==n&&!n.reference.equals(P.reference)){u=createTransformation(P.reference,n.reference);const e=createPoint(n.reference,[]);u.transform(P,e);P=e}if(i&&P&&t&&ShapeType.contains(t.type,ShapeType.POINT)&&P.z!==t.z)P=null;return P}function getSnapIconUrl(){return URL.fromData("iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABHNCSVQICAgIfAhkiAAAACZJREFUKJFj/J/F8"+"J+BFECKhv9ZDP+ZSDKdgYFhVMPg0MBIatIAALfyCbUjQhoaAAAAAElFTkSuQmCC")}const SNAP_ICON_SIZE=12;const SNAP_ICON_IMAGE=new Image;SNAP_ICON_IMAGE.src=getSnapIconUrl();let SNAP_STYLE=null;function makeSnapStyle(){SNAP_STYLE={image:SNAP_ICON_IMAGE,width:`${SNAP_ICON_SIZE}px`,height:`${SNAP_ICON_SIZE}px`,draped:false,zOrder:10}}export function paintSnapIcon(e,t){if(t){if(!SNAP_STYLE)makeSnapStyle();e.drawIcon(t,SNAP_STYLE)}}