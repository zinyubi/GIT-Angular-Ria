import{createBounds}from"../../../shape/ShapeFactory.js";import{ObjectReleaseTracker}from"../../../util/ObjectReleaseTracker.js";import{LABEL_CONFLICT_PADDING}from"../../style/LabelConflictChecker.js";import{AbstractDrawGridLabelHtmlContents}from"./AbstractDrawGridLabelHtmlContents.js";const NOT_FOUND=-1;export class PhotonDrawGridLabelCommandFactory{constructor(t,e,i){this._photon=t;this._objectReleaseTracker=new ObjectReleaseTracker;this._photonView=i;this._ignoreInView=e}reset(){}buildGridLabelCommand(t,e,i,s,o,n,r,a,l,c,h,d=false){const _=this._objectReleaseTracker.track(this._photon.GridLineLabelLocationUtil.create(a,r,l,c,h));return new DrawGridLineLabelHtmlContents(t,e,i,s,this._photonView,_,this._ignoreInView,o,n,d)}release(){this._objectReleaseTracker.release()}}class DrawGridLineLabelHtmlContents extends AbstractDrawGridLabelHtmlContents{constructor(t,e,i,s,o,n,r,a,l,c){super(t,e,s,o);this._step=16;this._lastToFirst=i;this._gridLineLabelLocationUtil=n;this._ignoreInView=r;this._positions=a;this._endPointsNotVisible=c;let h=createBounds(null,[0,0,0,0,0,0]);for(let t=0;t<a.getPointCount();t++){const e=a.getPoint(t);if(0==t)h=createBounds(null,[e.x,0,e.y,0,e.z,0]);else h?.includeCoordinate3D(e.x,e.y,e.z)}this._geometryBounds={x:h.x,y:h.y,z:h.z,width:h.width,height:h.height,depth:h.depth};this._indices=l}findLabelLocationSFCT(t,e,i,s,o,n){const r=t.displayScale;const a=this._lastToFirst;const l=this._gridLineLabelLocationUtil.findLabelLocation(s,this._positions,this._indices,this._geometryBounds,e*r,i*r,this._ignoreInView,a,this._step,this._endPointsNotVisible,o);if(1!==this._step){this._step=Math.max(1,this._step/2);t.invalidate()}if(l.edge===NOT_FOUND)return false;n.configure(l.x/r,l.y/r,e,i,l.labelOrientation,0,0,LABEL_CONFLICT_PADDING);return true}}