import{Photon}from"../../../../gen/photon/photon_painter.js";import{Hash}from"../../../../util/Hash.js";import{ProgrammingError}from"../../../../error/ProgrammingError.js";import{ObjectReleaseTracker}from"../../../../util/ObjectReleaseTracker.js";import{createTransformation}from"../../../../transformation/TransformationFactory.js";import{isProjectionTargetClosestSurfaceOptions,ProjectionTarget}from"../../../style/PanoramaStyle.js";import{ShapeUtil}from"../../../../shape/ShapeUtil.js";import{GeocentricReference}from"../../../../reference/GeocentricReference.js";import{getReference}from"../../../../reference/ReferenceProvider.js";import{getTransformation}from"../../../../util/CacheUtil.js";import{createPoint}from"../../../../shape/ShapeFactory.js";import{CubeMapFace}from"../../../../model/tileset/CubeMapFace.js";import{PanoramaType}from"../../../../model/tileset/PanoramaType.js";import{PanoramicImageProjectionType}from"../../../../model/tileset/PanoramicImageProjectionType.js";import{Constants}from"../../../../util/Constants.js";import{isPromise}from"../../../../util/PromiseUtil.js";import{createPaintContextHashPanoramic}from"../../../photon/PaintContextUtil.js";import{DrapeTarget}from"../../../style/DrapeTarget.js";import{ReferenceType}from"../../../../reference/ReferenceType.js";import{Matrix4}from"../../../../geometry/mesh/math/Matrix4.js";import{Vector3 as Vector3Int}from"../../../../geometry/mesh/math/Vector3.js";import{PanoramaImageryType}from"../../../../model/tileset/PanoramaImageryType.js";import{createRectangle}from"../../../../util/IconFactory.js";import{toPhotonOptionalRiaBox}from"../../../photon/PhotonShapeUtils.js";function obfuscateString(e){return e}const DEBUG_PANORAMIC=false;function rot13(e){return e.replace(/[a-zA-Z]/g,(function(e){return String.fromCharCode((e<="Z"?90:122)>=(e=e.charCodeAt(0)+13)?e:e-26)}))}const reqToPhotonFaceId=e=>{if(e.face)return toPhotonFaceId(e.face);else return Photon.FaceIdentifier.SingleImage};const toPhotonFaceId=e=>{switch(e){case CubeMapFace.TOP:return Photon.FaceIdentifier.Top;case CubeMapFace.BOTTOM:return Photon.FaceIdentifier.Bottom;case CubeMapFace.LEFT:return Photon.FaceIdentifier.Left;case CubeMapFace.RIGHT:return Photon.FaceIdentifier.Right;case CubeMapFace.FRONT:return Photon.FaceIdentifier.Front;case CubeMapFace.BACK:return Photon.FaceIdentifier.Back;default:throw new ProgrammingError("Unknown FaceIdentifier for PanoramicCubeFace")}};const toRIAFace=e=>{switch(e){case Photon.FaceIdentifier.Top:return CubeMapFace.TOP;case Photon.FaceIdentifier.Bottom:return CubeMapFace.BOTTOM;case Photon.FaceIdentifier.Left:return CubeMapFace.LEFT;case Photon.FaceIdentifier.Right:return CubeMapFace.RIGHT;case Photon.FaceIdentifier.Front:return CubeMapFace.FRONT;case Photon.FaceIdentifier.Back:return CubeMapFace.BACK;default:throw new ProgrammingError("Unknown PanoramicCubeFace for FaceIdentifier")}};const reqToTileCoordinateString=e=>toTileCoordinateString(reqToPhotonFaceId(e),e.level,e.x,e.y);const coordinateToTileCoordinateString=e=>toTileCoordinateString(e.face,e.level,e.x,e.y);const toTileCoordinateString=(e,t,o,r)=>e+", "+t+", "+o+", "+r;const groupByBaseOpacity=e=>e.reduce(((e,t)=>({...e,[t.baseOpacity]:[...e[t.baseOpacity]||[],t]})),{});const toPhotonOcclusionMode=e=>{if(e===ProjectionTarget.CLOSEST_SURFACE)return Photon.PanoramicOcclusionMode.On;else return Photon.PanoramicOcclusionMode.Off};let LICENSE_CHECK_REQUESTED=false;let LICENSE_CHECKED=false;let LICENSE_VALID=false;export class PhotonPanoramaCommand{constructor(e,t,o,r,a,n,i){this._is3d=e;this._worldReference=t;this._tracker=new ObjectReleaseTracker;this._photonView=o;this._photonGraphics=r;this._layer=n;this._paintContext=createPaintContextHashPanoramic(this._layer.id);this._hash=new Hash;this._photonImageProvider=a;this._invalidator=i;this._projectiveTextureMap=new Map;this._currentDrawItems=new Map;this._callsWhileLicenseChecking=[];if(LICENSE_CHECKED)this._licenseCallback=void 0;else this._licenseCallback=e=>{LICENSE_VALID=e;LICENSE_CHECKED=true;if(LICENSE_VALID)for(const e of this._callsWhileLicenseChecking)if("add"===e.type)this.add(e.feature,e.objectId,e.drawItems);else if("update"===e.type)this.update(e.feature,e.objectId,e.oldDrawItems,e.newDrawItems);else if("remove"===e.type)this.remove(e.feature,e.drawItems);this._callsWhileLicenseChecking=[];this._licenseCallback=void 0}}canHandle(e){return"panorama"===e.type&&this._is3d&&!!this._layer.panoramaModel}getDrawItems(e){return e.map((e=>{const t=e;return{command:this,geometryId:this.getGeometryId(t.location),styleId:this.getStyleId(t.style),style:t.style,metadata:{location:t.location,context:t.context,panoId:this.getPanoramicId(t.feature,t.context)},shape:t.location,renderPassId:t.renderPassId,feature:null,selected:false,objectId:0,zStyle:{drapeTarget:DrapeTarget.NOT_DRAPED,zToZero:false,hasDepth:true,aboveGround:false,viewDisplacement:false}}}))}resolveStyle(e){}release(){this._tracker.release()}updateState(e,t,o){const r=this._currentDrawItems.get(t)||[];if(0===r.length&&0===o.length)return;else if(0!==r.length&&0===o.length){this._currentDrawItems.delete(t);this.remove(e,r)}else if(0===r.length&&0!==o.length){this._currentDrawItems.set(t,o);this.add(e,t,o)}else{this._currentDrawItems.set(t,o);this.update(e,t,r,o)}}usesPhotonShapePainter(){return false}add(e,t,o){if(!LICENSE_CHECK_REQUESTED){ShapeUtil.purpxYvprafr("Cnabenzvp",this._licenseCallback);LICENSE_CHECK_REQUESTED=true}if(LICENSE_CHECK_REQUESTED&&!LICENSE_CHECKED){this._callsWhileLicenseChecking.push({type:"add",feature:e,objectId:t,drawItems:o});return}if(!LICENSE_VALID)return;if(DEBUG_PANORAMIC)console.log(`Adding feature ${e.id} with ${o.length} drawitems`);for(const e of o){const t=e.metadata.context;const o=this.getPanoramicId(e.feature,t);const r=this.initProjectiveTexture(e);if(r){const t=e.style.projection;this._projectiveTextureMap.set(o,{projectiveTexture:r,projectionTarget:t.target,baseOpacity:isProjectionTargetClosestSurfaceOptions(t)?t.baseOpacity:0,videos:new Map});r.requestAllLevel0Tiles();this._invalidator.invalidate()}}}update(e,t,o,r){if(LICENSE_CHECK_REQUESTED&&!LICENSE_CHECKED){this._callsWhileLicenseChecking.push({type:"update",feature:e,objectId:t,oldDrawItems:o,newDrawItems:r});return}if(!LICENSE_VALID)return;if(DEBUG_PANORAMIC)console.log(`Updating feature ${e.id} from ${o.length} drawitems to ${r.length}`);const a=[];for(const e of r){const t=this.getPanoramicId(e.feature,e.metadata.context);const o=this._projectiveTextureMap.get(t);const r=e.style.projection;if(o){this.updateProjectiveTexture(o.projectiveTexture,e);o.projectionTarget=r.target;o.baseOpacity=isProjectionTargetClosestSurfaceOptions(r)?r.baseOpacity:0}else{const o=this.initProjectiveTexture(e);if(o){this._projectiveTextureMap.set(t,{projectiveTexture:o,projectionTarget:r.target,baseOpacity:isProjectionTargetClosestSurfaceOptions(r)?r.baseOpacity:0,videos:new Map});o.requestAllLevel0Tiles()}}a.push(t)}for(const e of o){const t=e.metadata.panoId;if(a.indexOf(t)<0)if(this._projectiveTextureMap.has(t)){const e=this._projectiveTextureMap.get(t);if(e.projectiveTexture){this._tracker.untrack(e.projectiveTexture);this._projectiveTextureMap.delete(t)}}}}createRotationMatrix(e,t){if(this._worldReference instanceof GeocentricReference){const o=undefined;const r=getTransformation(e.reference,getReference("CRS:84")).transform(e);let a=null;let n=null;try{n=Photon.ScenePainterWrapper.getTransformationFromGeoLocation(r,t.yaw,createPoint(null,[0,0,0]),t.pitch,t.roll);const e=n.typedArray;a=[e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]]}finally{if(n)n.release()}if(null===a)throw new Error("Could not create rotation matrix");return a}else if(this._worldReference.referenceType===ReferenceType.CARTESIAN){let e=new Vector3Int(0,0,1);let o=new Vector3Int(1,0,0);const r=(new Matrix4).makeRotationY(-t.roll*Constants.DEG2RAD);e=e.applyMatrix4(r);o=o.applyMatrix4(r);const a=(new Matrix4).makeRotationAxis(o,-t.pitch*Constants.DEG2RAD);e=e.applyMatrix4(a);const n=undefined;const i=(new Matrix4).makeRotationAxis(e,t.yaw*Constants.DEG2RAD).multiply(a.multiply(r)).toArray();return[i[0],i[1],i[2],i[4],i[5],i[6],i[8],i[9],i[10]]}else throw new Error(`Cannot create rotation matrix for worldReference: ${this._worldReference.identifier}`)}updateProjectiveTexture(e,t){const{location:o}=t.metadata;const r=t.style.orientation;const{fovX:a,fovY:n}=r;const i=this.createRotationMatrix(o,r);const s=undefined;const c=createTransformation(o.reference,this._worldReference).transform(o);e.setLocation(c);e.setFovs(a,n);const l=Photon.BufferFactory.createFloat64BufferFromData(new Float64Array(i));e.setRotation(l);l.release();e.setOpacity(t.style.opacity);e.setSkyOpacity(t.style.skyOpacity);e.setLevelSwitchFactor(t.style.levelSwitchFactor)}remove(e,t){if(LICENSE_CHECK_REQUESTED&&!LICENSE_CHECKED){this._callsWhileLicenseChecking.push({type:"remove",drawItems:t,feature:e});return}if(DEBUG_PANORAMIC)console.log(`Removing ${t.length} for feature ${e.id}`);for(const e of t){const t=this.getPanoramicId(e.feature,e.metadata.context);if(this._projectiveTextureMap.has(t)){const e=this._projectiveTextureMap.get(t);if(e.projectiveTexture)this._tracker.untrack(e.projectiveTexture)}this._projectiveTextureMap.delete(t)}}getPanoramaModel(){if(null===this._layer.panoramaModel)throw new Error("GeoCanvas.drawPanorama was called, but no panoramaModel is set on the FeatureLayer. Make sure that a panoramaModel is set on the FeatureLayer.");return this._layer.panoramaModel}requestCubeMapImage(e,t,o){const r=e.feature;const a=e.metadata.context;const n=this.getPanoramaModel();if(!n)return;const i=n.getPanoramaDescriptor(r,a);if(!i||i.type!==PanoramaType.CUBE_MAP)return;const s={feature:r,context:a,face:toRIAFace(t.face),level:t.level,x:t.x,y:t.y};n.getPanoramicImage(s,((t,r)=>{this.handlePanoramicImageSuccess(t,e,r,o)}),((e,t)=>{this.handleImageError(e,o,t)}))}requestSingleImage(e,t,o){const r=e.feature;const a=e.metadata.context;const n=this.getPanoramaModel();if(!n)return;const i=n.getPanoramaDescriptor(r,a);if(!i||i.type!==PanoramaType.SINGLE_IMAGE)return;const s={feature:r,context:e.metadata.context,level:t.level,x:t.x,y:t.y};n.getPanoramicImage(s,((t,r)=>{this.handlePanoramicImageSuccess(t,e,r,o)}),((e,t)=>{this.handleImageError(e,o,t)}))}updateVideoImage(e,t,o,r){const a=this.getPanoramicId(e.feature,e.metadata.context);const n=this._projectiveTextureMap.get(a);if(!n)return;const i=coordinateToTileCoordinateString(t);const s=n.videos.get(i);if(!s)return;const c=this._layer.map?.viewPaintingStrategy;if(s&&c?.isOfPhotonType()){const e=c?.techContext.glContext;if(s.readyState>=HTMLMediaElement.HAVE_CURRENT_DATA&&e)e.texSubImage2D(e.TEXTURE_2D,0,r.x,r.y,e.RGBA,e.UNSIGNED_BYTE,s)}}initProjectiveTexture(e){const t=e.feature;let o=null;try{const r=this.getPanoramaModel();if(!r)return null;const a=e.metadata.context;const n=r.getPanoramaDescriptor(t,a);if(!n)return null;const i=this._tracker.track(new Photon.ProjectiveTextureTileLoader);const s=n.imageryType??PanoramaImageryType.IMAGE;if(s===PanoramaImageryType.IMAGE)i.requestTileUpdate=()=>{};else if(s===PanoramaImageryType.VIDEO)i.requestTileUpdate=(t,o,r)=>{this.updateVideoImage(e,t,o,r)};else throw new ProgrammingError("LuciadRIA doesn't support panorama imagery type "+s);if(n.type===PanoramaType.CUBE_MAP){const t=n.structure;o=Photon.ProjectiveTexture.createCubeMapStructure(t.levelCount,t.getTileWidth(0),t.getTileHeight(0),t.getTileColumnCount(0),t.getTileRowCount(0));i.requestTile=(t,o)=>{this.requestCubeMapImage(e,t,o)}}else if(n.type===PanoramaType.SINGLE_IMAGE){const t=n;const r=n.structure;if(t.projection.type===PanoramicImageProjectionType.EQUIRECTANGULAR)o=Photon.ProjectiveTexture.createEquirectangularStructure(r.levelCount,r.getTileWidth(0),r.getTileHeight(0),r.getTileColumnCount(0),r.getTileRowCount(0),r.imageDataFractionX,r.imageDataFractionY);else if(t.projection.type===PanoramicImageProjectionType.PINHOLE)o=Photon.ProjectiveTexture.createSingleImagePinholeStructure(r.levelCount,r.getTileWidth(0),r.getTileHeight(0),r.getTileColumnCount(0),r.getTileRowCount(0));else throw new ProgrammingError("LuciadRIA doesn't support single image panoramas that have projection type "+t.projection.type);i.requestTile=(t,o)=>{this.requestSingleImage(e,t,o)}}else return null;return this.initProjectiveTextureInner(e,n,o,i)}finally{if(o)o.release()}}getTileCacheSize(e){const t=PhotonPanoramaCommand.getNumberOfTiles(e);let o=t;const{structure:r,type:a}=e;if(r.levelCount>1){const e=r.getTileColumnCount(0)*r.getTileRowCount(0);o=e;const n=r.levelCount-1;const i=100*Constants.DEG2RAD;const s=100/180;let c=16/9;if(this._layer.map)c=this._layer._map.camera.aspectRatio;const l=undefined;const h=2*Math.atan(Math.tan(i/2)*c)/Constants.d360InRadians;if(a===PanoramaType.CUBE_MAP){o=6*e;const t=undefined;const a=undefined;o+=(Math.ceil(4*r.getTileColumnCount(n)*h)+2)*(Math.ceil(2*r.getTileRowCount(n)*s)+2)}else if(a===PanoramaType.SINGLE_IMAGE){o=Math.max(o,r.getTileColumnCount(n));o*=2.5;const t=Math.ceil(r.getTileColumnCount(n)*h)+2;const a=Math.ceil(r.getTileRowCount(n)*s)+2;o=Math.max(o,e+t*a)}o=Math.ceil(1.1*o);o=Math.min(o,t)}const n=Math.ceil(Math.sqrt(o));const i=n;const s=n;const c=this._photonGraphics.getMaxTextureSize();return{width:Math.min(i,Math.floor(c/r.getTileWidth(0))),height:Math.min(s,Math.floor(c/r.getTileHeight(0)))}}static getNumberOfTiles(e){const{structure:t}=e;let o=0;for(let e=0;e<t.levelCount;e++)o+=t.getTileColumnCount(e)*t.getTileRowCount(e);if(e.type===PanoramaType.CUBE_MAP)return 6*o;else return o}initProjectiveTextureInner(e,t,o,r){const{width:a,height:n}=this.getTileCacheSize(t);const i=this._tracker.track(Photon.ProjectiveTexture.create(this._photonView,this._photonGraphics,o,a,n,r,t.imageryType===PanoramaImageryType.VIDEO));this.updateProjectiveTexture(i,e);return i}handlePanoramicImageSuccess=(e,t,o,r)=>{const a=this.getPanoramaModel();if(o instanceof HTMLVideoElement){const t=o;const r=this.getPanoramicId(e.feature,e.context);const a=this._projectiveTextureMap.get(r);const n=reqToTileCoordinateString(e);if(a&&!a.videos.has(n))a.videos.set(n,t);o=createRectangle({width:t.videoWidth,height:t.videoHeight,fill:"black",stroke:"black"})}const n=this._photonImageProvider.getPhotonImage(o,true,false,true,a.credentials,false);const i=t=>{try{const o=this.getPanoramicId(e.feature,e.context);const a=undefined;if(!this._projectiveTextureMap.get(o))return;r.handleImage(reqToPhotonFaceId(e),e.level,e.x,e.y,t);this._invalidator.invalidate()}finally{t.release();r.release()}};const s=e=>{console.error(e||new Error("Error while decoding panoramic image tile"))};if(isPromise(n))n.then(i).catch(s);else try{i(n)}catch(e){s(e instanceof Error?e:new Error(""+e))}};handleImageError=(e,t,o)=>{try{console.error(o||new Error("Unknown panoramic tile request error"));const r=o&&o.message?o.message:"Unknown tile error";t.handleError(reqToPhotonFaceId(e),e.level,e.x,e.y,r)}finally{t.release()}};getGeometryId(e){this._hash.reset();this._hash.appendDouble(e.x);this._hash.appendDouble(e.y);this._hash.appendDouble(e.z);return this._hash.getHashCode()}getStyleId(e){this._hash.reset();this._hash.appendDouble(e.opacity);this._hash.appendDouble(e.skyOpacity);const t=e.orientation;this._hash.appendDouble(t.fovX);this._hash.appendDouble(t.fovY);this._hash.appendDouble(t.yaw);this._hash.appendDouble(t.pitch);this._hash.appendDouble(t.roll);this._hash.appendString(e.projection.target);if(isProjectionTargetClosestSurfaceOptions(e.projection))this._hash.appendDouble(e.projection.baseOpacity);this._hash.appendDouble(e.levelSwitchFactor);return this._hash.getHashCode()}getPanoramicId(e,t){this._hash.reset();this._hash.append(e.id);for(const e in t)if(t.hasOwnProperty(e)){this._hash.appendString(e);const o=t[e];if("string"===typeof o)this._hash.appendString(o);if("number"===typeof o)this._hash.appendDouble(o)}return this._hash.getHashCode()}paint(e,t,o,r,a,n){const i="controller"===this._layer.label;const s=i||this._layer.visibleInTree;const c=undefined;let l=true;const h=undefined;if(this._projectiveTextureMap.size>0&&s&&t===(i?t:false)&&r===Photon.PaintDraping.NonDraping&&o!==Photon.PaintOpacity.All&&a===Photon.PaintOutput.Normal){const e=[...this._projectiveTextureMap.values()];for(const t in ProjectionTarget){const r=e.filter((e=>e.projectionTarget===t));const a=groupByBaseOpacity(r);const i=Object.keys(a);for(const e of i){const r=a[e];for(let a=0;a<r.length;a+=2){const i=r[a]?r[a].projectiveTexture:null;const s=r[a+1]?r[a+1].projectiveTexture:null;const c=o===Photon.PaintOpacity.Transparent;if(DEBUG_PANORAMIC)console.log("Painting projective texture slots:",i,s);l=this._photonView.paintPanoramics(c,toPhotonOcclusionMode(t),e,i,s,null,null,this._paintContext,toPhotonOptionalRiaBox(n,this._layer._map.displayScale))&&l}}}}return l}}