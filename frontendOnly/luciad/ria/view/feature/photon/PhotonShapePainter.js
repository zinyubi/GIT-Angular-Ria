import{OutOfBoundsError}from"../../../error/OutOfBoundsError.js";import{Photon}from"../../../gen/photon/photon_painter.js";import{createBounds}from"../../../shape/ShapeFactory.js";import{ShapeType}from"../../../shape/ShapeType.js";import{isIE}from"../../../util/Browser.js";import{isNumber}from"../../../util/Lang.js";import{Log}from"../../../util/Log.js";import{ObjectReleaseTracker}from"../../../util/ObjectReleaseTracker.js";import{createTransformation}from"../../../transformation/TransformationFactory.js";import*as LayerUtil from"../../LayerUtil.js";import{PickInfoImpl}from"../../PickInfo.js";import{PickRequest}from"../../PickRequest.js";import{PhotonShapePainterUtil}from"./PhotonShapePainterUtil.js";import{PhotonIconCommand}from"./command/PhotonIconCommand.js";import{PhotonLineAndAreaCommand}from"./command/PhotonLineAndAreaCommand.js";import{PhotonTrajectoryCommand}from"./command/PhotonTrajectoryCommand.js";import{PhotonPlotCommand}from"./command/PhotonPlotCommand.js";import{PhotonDrawCommandProxy}from"./PhotonDrawCommandProxy.js";import{CollectingGeoAndLabelCanvas}from"./CollectingGeoAndLabelCanvas.js";import{PhotonImageProvider}from"./PhotonImageProvider.js";import{Photon3DIconCommand}from"./command/Photon3DIconCommand.js";import{PhotonMeshProvider}from"./PhotonMeshProvider.js";import{PhotonPanoramaCommand}from"./command/PhotonPanoramaCommand.js";import{isPromise}from"../../../util/PromiseUtil.js";import{StyleUtil}from"../../style/StyleUtil.js";import{PaintRepresentation}from"../../PaintRepresentation.js";import{isOfShapeType}from"../../../shape/Shape.js";import{DrawNullLabel}from"../../style/DrawNullLabel.js";import{toPhotonViewBounds}from"../../photon/PhotonShapeUtils.js";var AnchorSettings=Photon.AnchorSettings;var OptionalRiaBox=Photon.OptionalRiaBox;const PICKINFO_RECORD_SIZE=8;const REGULAR_RENDER_PASS_ID=0;const DENSITY_RENDER_PASS_ID=1;const SELECTED_RENDER_PASS_ID=2;const WhenPromiseScheduler={when:function(e,t){return Promise.resolve(e).then(t)},schedule:()=>{},start:()=>{},isBusy:()=>false,release:()=>{}};function asPickInfoBuffer(e){return{objectId:t=>e[t*PICKINFO_RECORD_SIZE],geometryId:t=>e[t*PICKINFO_RECORD_SIZE+1],styleId:t=>e[t*PICKINFO_RECORD_SIZE+2],distanceToEdge:t=>e[t*PICKINFO_RECORD_SIZE+3],distanceToCenter:t=>e[t*PICKINFO_RECORD_SIZE+4],depth:t=>e[t*PICKINFO_RECORD_SIZE+5],zOrder:t=>e[t*PICKINFO_RECORD_SIZE+6],draped:t=>1===e[t*PICKINFO_RECORD_SIZE+7]}}const DIFFWANTEDITEM_RECORD_SIZE=2;function asDiffWantedItemBuffer(e){return{set:(t,n,r)=>{e[t*DIFFWANTEDITEM_RECORD_SIZE]=n;e[t*DIFFWANTEDITEM_RECORD_SIZE+1]=r}}}const DIFFITEM_RECORD_SIZE=6;const DIFF_ACTION_NOOP=0;const DIFF_ACTION_REMOVE=1;const DIFF_ACTION_STYLE=2;const DIFF_ACTION_REPLACE=3;const DIFF_ACTION_GEOMETRY=4;const DIFF_ACTION_ADD=5;function asDiffItemBuffer(e){return{oldGeometryId:t=>e[t*DIFFITEM_RECORD_SIZE],oldStyleId:t=>e[t*DIFFITEM_RECORD_SIZE+1],newGeometryId:t=>e[t*DIFFITEM_RECORD_SIZE+2],newStyleId:t=>e[t*DIFFITEM_RECORD_SIZE+3],action:t=>e[t*DIFFITEM_RECORD_SIZE+4],wantedItemIdx:t=>e[t*DIFFITEM_RECORD_SIZE+5]}}class ShareBuffer{_share=new Map;constructor(){this._share.set("diffwanted",{buffer:null,counter:0});this._share.set("diffitems",{buffer:null,counter:0});this._share.set("pickinfos",{buffer:null,counter:0})}getOrMake(e,t){const n=this._share.get(e);if(n.buffer){n.counter++;return n.buffer}n.buffer=Photon.BufferFactory.createUint32BufferFromLength(t);const r=n.buffer.release;n.buffer.release=()=>{const t=this._share.get(e);if(0===--t.counter){r.call(t.buffer);t.buffer=null}};n.counter=1;return n.buffer}}const SHARED_BUFFERS=new ShareBuffer;const getDiffWantedBuffer=()=>SHARED_BUFFERS.getOrMake("diffwanted",1e4*DIFFWANTEDITEM_RECORD_SIZE);const getDiffItemsBuffer=()=>SHARED_BUFFERS.getOrMake("diffitems",1e4*DIFFITEM_RECORD_SIZE);const getPickInfosBuffer=()=>SHARED_BUFFERS.getOrMake("pickinfos",3e4*PICKINFO_RECORD_SIZE);function inlineAsync(e,t,n){if(isPromise(e))return t.when(e,n);else return n(e)}export class PhotonShapePainter extends ObjectReleaseTracker{constructor(e,t,n,r,o,s,i,a,h,l={}){super();this._layer=e;this._photonView=t;this._photonGraphics=r;this._label=LayerUtil.getLabel(e,"");this._shapePainter=l.shapePainter||this.track(Photon.ShapePainter.create(t,r,LayerUtil.formatLabelForPhoton(this._label)));if(isNumber(l.maxGLLineWidth,true))this._shapePainter.setMaxGLLineWidth(0|l.maxGLLineWidth);this._shapePainter.setRegularRenderPass(REGULAR_RENDER_PASS_ID);this._shapePainter.setRegularRenderPass(SELECTED_RENDER_PASS_ID);this._objectIdCounter=1;this._objectIdMap=new Map;this._featureMap=new Map;this._editedFeatureID=null;this._worldReference=n;this._featurePainter=null;this._density=false;this._photonGeoCanvas=new CollectingGeoAndLabelCanvas({worldReference:n});this._geoCanvas=this._photonGeoCanvas;this._stateObject={selected:false,hovered:false,level:0};this._imageProvider=l.imageProvider||this.track(new PhotonImageProvider(o,StyleUtil.getFallbackIconUrl));this._meshProvider=l.meshProvider||this.track(new PhotonMeshProvider(this._shapePainter,this._imageProvider,a,r,i));const c=e._map.is3D();this._is3d=c;const d=this._shapePainter.getMaxGLLineWidth();const f=true===l?.canUseEarcut;const u=true===l?.noDiscretization;this._commands=[this.track(new PhotonIconCommand(c,n,this._shapePainter,this._imageProvider,e._map.worldSizeSupport)),this.track(new PhotonPlotCommand(c,n,this._shapePainter,i,this._imageProvider)),this.track(new PhotonLineAndAreaCommand(c,n,this._shapePainter,this._label,d,s,this._imageProvider,e._map.worldSizeSupport,h,f,u)),this.track(new Photon3DIconCommand(c,n,this._shapePainter,this._meshProvider)),this.track(new PhotonTrajectoryCommand(c,n,this._shapePainter,this._label,d,i)),this.track(new PhotonPanoramaCommand(c,n,t,r,this._imageProvider,e,i))];this._noShapePainterCommands=this._commands.filter((e=>!e.usesPhotonShapePainter()));this._diffWantedItemsBuffer=this.track(getDiffWantedBuffer());this._diffItemsBuffer=this.track(getDiffItemsBuffer());this._pickInfosBuffer=this.track(getPickInfosBuffer());this._labelWithoutBodyCanvas={drawLabel:(e,t)=>this._photonGeoCanvas.handleLabelWithoutBody(t,true),drawLabelInPath:(e,t)=>this._photonGeoCanvas.handleLabelWithoutBody(t,false),drawLabelOnPath:(e,t)=>this._photonGeoCanvas.handleLabelWithoutBody(t,false)}}release(){super.release();this._shapePainter=null;this._imageProvider=null;this._meshProvider=null}getLabel(){return this._label}isSelected(e){return this._layer.isSelected(e)}isEdited(e){return this._editedFeatureID===e.id}setEdited(e,t){if(t)this._editedFeatureID=e.id;else this._editedFeatureID=null}setPainter(e){this._featurePainter=e;this._density=!!this._featurePainter.density}setDetailLevel(e){if(e!==this._stateObject.level){this._stateObject.level=e;this._featurePainter?.invalidateAll()}}getObjectId(e){return this._objectIdMap.get(e.id)}registerFeature(e){let t=this._objectIdMap.get(e.id);if(!t){t=this._objectIdCounter++;this._objectIdMap.set(e.id,t)}this._featureMap.set(t,e);return t}unregisterFeature(e){const t=this._objectIdMap.get(e.id);this._featureMap.delete(t);this._objectIdMap.delete(e.id);return t}getFeature(e){const t=this._objectIdMap.get(e);return this._featureMap.get(t)}forEachElement(e){this._featureMap.forEach(e)}buildLabelDrawCommands(e,t,n){const r=this._layer;const o=r._map;const s=this.isSelected(e);const i=!r.filter||r.filter(e);const a=this._editedFeatureID!==e.id;const h=r.fetchProvidedShape(e);if(!(i&&h&&a&&r.canDrawLabels()&&this._featurePainter))return DrawNullLabel;const l=[];const c={drawLabel:(e,t,n)=>void l.push({type:"drawLabel",html:e,shape:t,labelStyle:n}),drawLabelInPath:(e,t,n)=>void l.push({type:"drawLabelInPath",html:e,shape:t,labelStyle:n}),drawLabelOnPath:(e,t,n)=>void l.push({type:"drawLabelOnPath",html:e,shape:t,labelStyle:n})};this._stateObject.selected=s;this._stateObject.hovered=r.isHovered(e);this._featurePainter.paintLabel(c,e,h,r,o,this._stateObject);if(0===l.length)return DrawNullLabel;this._featurePainter.paintBody(this._geoCanvas,e,h,r,o,this._stateObject);l.forEach((({type:e,shape:t})=>this._labelWithoutBodyCanvas[e]("",t,{})));const d=this._photonGeoCanvas.build();const f=undefined;const u=this.getFeatureDrawItemHandler(e,-1,s).bind(this)(d);const m=new PhotonDrawCommandProxy(this,e,h,u);t.resetLabelContext(n,m,this._stateObject.hovered);l.forEach((({type:e,html:n,shape:r,labelStyle:o})=>t[e](n,r,o)));return t.getDrawCommand()}getCurrentDrawItems(e,t,n){const r=this.isSelected(e);const o=!this._layer.filter||this._layer.filter(e);const s=this._editedFeatureID!==e.id;if(o&&s&&this._featurePainter){const t=this._layer.fetchProvidedShape(e);if(t){this._stateObject.selected=r;this._stateObject.hovered=this._layer.isHovered(e);const n=this._layer;const o=n._map;this._featurePainter.paintBody(this._geoCanvas,e,t,n,o,this._stateObject);if(n.canDrawLabels())this._featurePainter.paintLabel(this._labelWithoutBodyCanvas,e,t,n,o,this._stateObject)}}const i=this._photonGeoCanvas.build();const a=this.getFeatureDrawItemHandler(e,t,r).bind(this);return inlineAsync(resolveStylePromises(i),n,a)}getFeatureDrawItemHandler(e,t,n){return r=>{const o=!n&&this._density;const s=n?SELECTED_RENDER_PASS_ID:o?DENSITY_RENDER_PASS_ID:REGULAR_RENDER_PASS_ID;for(let i=0;i<r.length;i++){const a=r[i];a.feature=e;a.objectId=t;a.renderPassId=s;a.selected=n;a.density=o;a.command=this._commands.find((e=>e.canHandle(r[i])))}r=PhotonShapePainterUtil.unrollGeoCanvasCommands(r,this._is3d);const i=[];for(let a=0;a<this._commands.length;a++){const h=this._commands[a];const l=_filterByCommand(r,h);if(0===l.length)continue;const c=h.getDrawItems(l);for(let r=0;r<c.length;r++){const a=c[r];if(!hasDrawItem(i,a)){a.feature=e;a.objectId=t;a.renderPassId=s;a.selected=n;a.density=o;a.command=h;i.push(a)}}}return i}}getSubshapeDrawItems(e,t){const n=[];for(let r=0;r<e.length;r++)if(isSubShapeOf(e[r].shape,t))n.push(e[r]);return n}createDrawCommand(e){return new PhotonDrawCommandProxy(this,e,e.shape,this.getCurrentDrawItems(e,-1,WhenPromiseScheduler))}fastPick(e,t){const n=this.getDisplayScale();const r=toPhotonViewBounds(e,n);const o=this._shapePainter.pickObjects(r,this._pickInfosBuffer);const s=this._pickInfosBuffer.typedArray;for(let e=0;e<o;e++){const n=s[e];const r=this._featureMap.get(n);if(r)t(r);else Log.error("No feature found for "+n+"!")}return o}painterChanged(){this._density=!!this._featurePainter?.density;const e=this.track(Photon.BufferFactory.createFloat32BufferFromLength(0));if(this._density){let t={levels:e,colors:e,release:()=>{}};const n=this._featurePainter?.density?.colorMap;if(n)t=n.toPhotonBuffers(Photon);try{this._shapePainter.setDensityRenderPass(DENSITY_RENDER_PASS_ID,t.levels,t.colors)}finally{t.release()}}}add(e,t){const n=this.registerFeature(e);const r=this.getCurrentDrawItems(e,n,t);return t.when(r,(r=>t.when(resolveStyles(r),(t=>{t=this.updateNoShapePainterCommands(e,n,t);for(let e=0;e<t.length;e++){const n=t[e];n.command.add(n)}releaseStyles(t)}))))}updateNoShapePainterCommands(e,t,n){for(let r=0;r<this._noShapePainterCommands.length;r++){const o=this._noShapePainterCommands[r];if(n.find((e=>e.command===o))){const r=n.filter((e=>e.command===o));n=n.filter((e=>e.command!==o));o.updateState(e,t,r)}else o.updateState(e,t,[])}return n}update(e,t){const n=this.registerFeature(e);const r=this.getCurrentDrawItems(e,n,t);const o=this;return t.when(r,(r=>{r=this.updateNoShapePainterCommands(e,n,r);const s=asDiffWantedItemBuffer(o._diffWantedItemsBuffer.typedArray);const i=asDiffItemBuffer(o._diffItemsBuffer.typedArray);let a=0;for(let e=0;e<r.length;e++)s.set(a++,r[e].geometryId,r[e].styleId);const h=o._shapePainter.calculateDiff(n,a,o._diffWantedItemsBuffer,o._diffItemsBuffer);const l=[];const c=[];const d=[];for(let e=0;e<h;e++){const t=i.action(e);const o=t!==DIFF_ACTION_REMOVE?r[i.wantedItemIdx(e)]:{objectId:n,geometryId:0,styleId:0};o.oldGeometryId=i.oldGeometryId(e);o.oldStyleId=i.oldStyleId(e);o.action=t;l.push(o);if(t===DIFF_ACTION_ADD||t===DIFF_ACTION_STYLE||t===DIFF_ACTION_REPLACE)c.push(o);if(o.zStyle&&o.zStyle.viewDisplacement&&(t===DIFF_ACTION_NOOP||t===DIFF_ACTION_GEOMETRY))d.push(o)}if(0!==c.length&&0!==d.length)for(let e=0;e<d.length;e++)c.push(d[e]);r=l;function f(e){for(let t=0;t<e.length;t++){const r=e[t];const s=r.action;const i=r.command;if(s===DIFF_ACTION_NOOP);else if(s===DIFF_ACTION_REMOVE)o._shapePainter.removeGeometry(r.objectId,r.oldGeometryId,r.oldStyleId);else if(s===DIFF_ACTION_ADD)i.add(r);else if(s===DIFF_ACTION_STYLE)i.updateStyle(r,r.oldStyleId);else if(s===DIFF_ACTION_GEOMETRY)i.updateGeometry(r,r.oldGeometryId);else if(s===DIFF_ACTION_REPLACE){o._shapePainter.removeGeometry(n,r.oldGeometryId,r.oldStyleId);i.add(r)}else throw new Error("Unknown action "+s)}releaseStyles(e)}if(c.length>0)return t.when(resolveStyles(c),(function(){f(r)}));else f(l)}))}remove(e,t){const n=this.unregisterFeature(e);this._shapePainter.removeObject(n);this.updateNoShapePainterCommands(e,n,[])}clean(){this._imageProvider.clean();this._meshProvider.clean();this._shapePainter.garbageCollect()}getBounds(){const e=this._shapePainter.getGeometryBoundsRia();if(!e.valid)return null;const t=[e.x,e.width,e.y,e.height,e.z,e.depth];for(let e=0;e<t.length;e++)if(isNaN(t[e])||t[e]===-1/0||t[e]===1/0)return null;return createBounds(this._worldReference,t)}paint(e,t,n,r,o){this._meshProvider.refreshVideoTexture();let s=true;for(let i=0;i<this._noShapePainterCommands.length;i++){const a=undefined;s=this._noShapePainterCommands[i].paint(this._photonGraphics,e,t,n,r,o)&&s}this._shapePainter.paint(this._photonGraphics,e,t,n,r,o);return s}updateViewDependentAttributes(e){return this._shapePainter.updateViewDependentAttributes(e)}getDisplayScale(){if(this._layer&&this._layer._map)return this._layer._map.displayScale;return 1}pick(e){const t=this.getDisplayScale();const n=toPhotonViewBounds(e.viewBounds,t);const r=this._shapePainter.pick(n,this._pickInfosBuffer,true);const o=1e6;const s=[];const i=asPickInfoBuffer(this._pickInfosBuffer.typedArray);for(let e=0;e<r;e++){const n=i.objectId(e);const r=this._featureMap.get(n);if(r)s.push(new PickInfoImpl(this._layer,r,i.distanceToEdge(e)/t,i.distanceToCenter(e)/t,i.depth(e)/o,i.zOrder(e),this.isSelected(r),i.draped(e)));else Log.error("No feature found for "+n+"!")}return s}interacts(e,t,n,r){return this.interactsDrawItems(e,this.getSubshapeDrawItems(this.getCurrentDrawItems(e,-1,WhenPromiseScheduler),t),n,r)}interactsDrawItems(e,t,n,r){const o=PickRequest.fromWorldBounds(n,false,true,this._layer.getMapToViewTransformation(PaintRepresentation.BODY));return this.interactsDrawItemsInner(e,t,r,o)}interactsDrawItemsView(e,t,n,r,o,s){const i=PickRequest.fromViewPoint(n,r,o,o,false,true,this._layer.getMapToViewTransformation(PaintRepresentation.BODY));return this.interactsDrawItemsInner(e,t,s,i)}findInteractingShapes(e,t,n,r,o){const s=PickRequest.fromViewPoint(t,n,r,r,false,true,this._layer.getMapToViewTransformation(PaintRepresentation.BODY));const i=[];for(let t=0;t<e.length;t++){const n=e[t];if(!o||n.metadata.isLine)i.push(n.geometryId)}if(i.length<=0)return[];const a=this.getDisplayScale();const h=toPhotonViewBounds(s.viewBounds,a);let l=0;try{l=this._shapePainter.pick(h,this._pickInfosBuffer,true)}catch(e){OutOfBoundsError.isOrThrow(e)}const c=[];const d=asPickInfoBuffer(this._pickInfosBuffer.typedArray);for(let t=0;t<l;t++){const n=d.geometryId(t);if(i.indexOf(n)>=0){const t=e.find((e=>e.geometryId===n));if(t)c.push(t.shape)}}return c}interactsDrawItemsInner(e,t,n,r){const o=[];for(let e=0;e<t.length;e++){const r=t[e];if(!n||r.metadata.isLine)o.push(r.geometryId)}if(o.length<=0)return false;const s=this.getDisplayScale();let i=0;try{const e=toPhotonViewBounds(r.viewBounds,s);i=this._shapePainter.pick(e,this._pickInfosBuffer,true)}catch(e){OutOfBoundsError.isOrThrow(e)}const a=asPickInfoBuffer(this._pickInfosBuffer.typedArray);for(let e=0;e<i;e++){const t=a.geometryId(e);if(o.indexOf(t)>=0)return true}return false}getShapeAnchor(e,t,n,r){const o=this.getObjectId(e);if(!o)return null;const s=getGeometryIdForBiggestShape(t,n);if(!s)return null;return this._shapePainter.getShapeAnchor(o,s,{mode:n,minPathLength:r})}getShapeOnPathAnchorsSFCT(e,t,n,r){const o=this.getObjectId(e);if(!o)return;const s=getGeometryIdForBiggestShape(t,Photon.AnchorMode.OnPath);if(!s)return;const i={mode:Photon.AnchorMode.OnPath,minPathLength:r};this.doGetShapeAnchorsSFCT(o,s,i,n,ON_PATH_POSITION_FRACTIONS);for(let e=0;e<t.length;e++){const r=t[e].geometryId;if(r!==s){this.doGetShapeAnchorsSFCT(o,r,i,n,ON_PATH_POSITION_CENTRAL);if(n.anchorPointsLength>=MAX_ANCHORS)return}}}doGetShapeAnchorsSFCT(e,t,n,r,o){for(let s=0;s<o.length;s++){n.distanceAt=o[s];const i=this._shapePainter.getShapeAnchor(e,t,n);if(isValidAnchor(i,n.mode)&&!r.exists(i.x,i.y,i.z))addToAnchors(r,i)}}getRepeatingAnchorListSFCT(e,t,n,r,o){const s=o.mapWorldBounds;const i=getClipWorldBounds(s,5);const a=o.w2v;const h=o.labelWidth;if(!n)return;const l=this.getObjectId(e);if(!l)return;const c=this._shapePainter;const d=n.initialGap??0;const f=n.minimumGap??0;const u=Photon.AnchorMode.OnPath;for(let e=0;e<t.length;e++){const n=t[e].geometryId;const h=shouldClipPath(t[e].shape.bounds,i,a);r.updateRepeatingAnchorContext(h,h?s:i);m(n,h);if(r.anchorPointsLength>=o.maxCount)break}function m(e,t){const n={distanceAt:d+h/2,distanceType:Photon.DistanceType.Pixel,mode:u,minPathLength:0,clipType:t?Photon.ClipType.ClipToView:Photon.ClipType.NoClip};let s=c.getShapeAnchor(l,e,n);let i=false;if(isValidAnchor(s,u)){addToAnchors(r,s);i=true}while(i){n.distanceAt+=f+h;s=c.getShapeAnchor(l,e,n);if(isValidAnchor(s,u)){addToAnchors(r,s);if(r.anchorPointsLength>=o.maxCount)i=false}else i=false}}}labelAnchorToView(e,t){const n=this.getObjectId(e);if(!n)return null;const r=this._shapePainter.labelAnchorToView(n,t);if(!r.valid)return null;const o=this.getDisplayScale();r.x/=o;r.y/=o;return r}isPointVisible(e,t){if(isIE())return this._photonView.isPointVisible(e,Photon.VisibilityMode.Terrain);const n=t?Photon.VisibilityMode[t]:Photon.VisibilityMode.Terrain;return this._photonView.isPointVisible(e,n)}}function _filterByCommand(e,t){return e.filter((e=>e.command===t))}function hasDrawItem(e,t){for(let n=0;n<e.length;n++)if(t.geometryId===e[n].geometryId&&t.styleId===e[n].styleId)return true;return false}function resolveStylePromises(e){const t=[];let n=false;for(let r=0;r<e.length;r++){const o=e[r];if(isPromise(o.style)){n=true;t.push(o.style.then((function(e){o.style=e;return o})))}else t.push(o)}return n?Promise.all(t):t}function releaseStyles(e){for(let t=0;t<e.length;t++)if(e[t].style&&e[t].style.release)e[t].style.release()}function resolveStyles(e){for(let t=0;t<e.length;t++)e[t].command.resolveStyle(e[t]);return resolveStylePromises(e)}function isSubShapeOf(e,t){if(e===t)return true;if(equalShapes(e,t))return true;if(isOfShapeType(t,ShapeType.SHAPE_LIST))for(let n=0;n<t.shapeCount;n++)if(isSubShapeOf(e,t.getShape(n)))return true;return false}function equalShapes(e,t){return e&&t&&e.type===t.type&&e.equals(t)}const ON_PATH_POSITION_FRACTIONS=[.5,.25,.75];const ON_PATH_POSITION_CENTRAL=[.5];const MAX_ANCHORS=10;function shouldClipPath(e,t,n){try{const r=undefined;const o=createTransformation(e.reference,n.inputReference).transformBounds(e);return!t.contains2DBounds(o)}catch(e){return true}}function getClipWorldBounds(e,t){try{return e.copy().enlarge2D(t)}catch(e){}return null}function addToAnchors(e,t){e.add3D(t.x,t.y,t.z,t.x+t.dx,t.y+t.dy,t.z+t.dz)}function isValidAnchor(e,t){const n=!isNaN(e.x)&&!isNaN(e.y)&&!isNaN(e.z);if(n&&t===Photon.AnchorMode.OnPath&&0===e.dx&&0===e.dy&&0===e.dz)return false;return n}function getGeometryIdForBiggestShape(e,t){let n=null;let r=-1;for(let o=0;o<e.length;o++){const s=e[o];if(canDrawLabelModeForItem(s,t)){const e=s.shape.bounds;const t=e.width*e.height;if(t>r){n=s.geometryId;r=t}}}return n}function canDrawLabelModeForItem(e,t){const n=e.metadata;if(t===Photon.AnchorMode.OnPath)return n.isLine;else if(t===Photon.AnchorMode.InPath)return!!(n&&(n.isOutlineForClosedShape||n.isFill));else return true}