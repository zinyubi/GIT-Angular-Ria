import{isDefined,isNumber,isString}from"../util/Lang.js";import{parse,stringify}from"../util/JSON.js";import{Constants}from"../util/Constants.js";import{OutOfBoundsError}from"../error/OutOfBoundsError.js";import{createEllipsoidalGeodesy}from"../geodesy/GeodesyFactory.js";import{createPoint}from"../shape/ShapeFactory.js";import{createTransformation}from"../transformation/TransformationFactory.js";import{getReference}from"../reference/ReferenceProvider.js";import{CameraFactory}from"./CameraFactory.js";import{distance3D}from"../util/Cartesian.js";import{OrthographicCamera}from"./camera/OrthographicCamera.js";import{is3DWorldReference}from"./MapUtil.js";import{ReferenceType}from"../reference/ReferenceType.js";const LLH_REF=getReference("CRS:84");const REFERENCE_2D_FOR_3D_MAPSTATE=getReference("EPSG:32663");const GEOCENTRIC_REFERENCE=getReference("EPSG:4978");function is3D(e){return is3DWorldReference(e)}function isCartesian(e){return e.referenceType===ReferenceType.CARTESIAN}function createMatchedCamera(e,r,t,n,o,i,a,c){const s=createTransformation(LLH_REF,o);let f;try{f=s.transform(t)}catch(e){throw new Error("Could not match camera state. "+"The reference point of the camera to match is out of projection bounds.")}let l=c.createCameraForReference(o,i,a);if(!l)throw new Error("Could not match camera state."+"Can not create a camera for the target reference.");let m;if(is3D(o)){let e=l;const t=1e3;let o=e.asLookAt(t);o.ref=f;o.distance=t;o.yaw=n;o.pitch=-89;o.roll=0;e=e.lookAt(o);m=getReferenceDistance(e,f);if(-1!==m){const i=t*(r/m);o=e.asLookAt(i);o.ref=f;o.distance=t*(r/m);o.yaw=n;o.pitch=-89;e=e.lookAt(o)}else throw new Error("Could not match camera state. Could not determine reference distance (center of the view"+"does not touch the globe?).");l=e}else{let t=l;let o=t.asLook2D();o.worldOrigin=f;o.viewOrigin=createPoint(null,[t.width/2,t.height/2]);o.scaleX=.1;o.scaleY=.1;t=t.look2D(o);m=getReferenceDistance(t,f);if(-1!==m){o.scaleX=o.scaleX*(m/r);o.scaleY=o.scaleY*(m/r)}else throw new Error("Could not match camera state. Failed to determine target scale.");t=t.look2D(o);const i=undefined;const a=getReferencePointAndViewAngleToNorth(e,t).viewAngleToNorth-n;o=t.asLook2D();o.rotation-=a;t=t.look2D(o);l=t}return l}export function createOrthographicCamera(e,r){const t=e.getScaleAt(r);const n=e.width/t;const o=e.height/t;return new OrthographicCamera(e.eye,e.forward,e.up,-e.far,e.far,e.width,e.height,n,o,e.worldReference)}function getReferenceDistance(e,r){const t=e.toView(r).z;const n=e.height/2;const o=createPoint(null,[e.width/2,n,t]);const i=createTransformation(e.worldReference,LLH_REF);let a=e.toWorldPoint(o);const c=i.transform(a);let s=.8*n;const f=createPoint(null,[o.x,o.y+s,t]);let l;try{a=e.toWorldPoint(f);l=i.transform(a)}catch(r){try{s=5;const r=createPoint(null,[o.x,o.y+s,t]);a=e.toWorldPoint(r);l=i.transform(a)}catch(e){throw new Error("Can not find reference distance of camera."+"Can not transform view points near center of view to geodetic reference.")}}const m=undefined;return createEllipsoidalGeodesy(LLH_REF).distance(c,l)/s}function getReferencePointAndViewAngleToNorth(e,r){const t=createTransformation(r.worldReference,LLH_REF);try{if(is3D(r.worldReference)){const n=createPoint(null,[r.width/2,r.height/2]);const o=e.viewToMapTransformation.transform(n);const i=distance3D(o,r.eye);const a=r.asLookAt(i);return{referencePoint:t.transform(o),referencePointWorld:o,viewAngleToNorth:a.yaw}}const n=createPoint(null,[r.width/2,r.height/2]);const o=r.toWorldPoint(n);o.z=0;const i=t.transform(o);const a=createEllipsoidalGeodesy(LLH_REF);const c=1e3;const s=0;const f=a.interpolate(i,c,s);const l=t.inverseTransformation.transform(f);const m=r.toViewPoint(l);const d=undefined;return{referencePoint:i,referencePointWorld:o,viewAngleToNorth:-(Math.atan2(m.y-n.y,m.x-n.x)+Math.PI/2)*Constants.RAD2DEG}}catch(e){OutOfBoundsError.isOrThrow(e);const r=createPoint(LLH_REF,[0,0]);return{referencePoint:r,referencePointWorld:t.inverseTransformation.transform(r),viewAngleToNorth:0}}}function isLegacy2DMapStateInternal(e){return"2d"===e.type}function isLegacy3DMapStateInternal(e){return"3d"===e.type}function isAnotherLegacyMapState(e){const r=e;const t=!!r.transformation2D&&isLegacyTransformation2D(r.transformation2D);const n=!!r.transformation3D&&isLegacyTransformation3D(r.transformation3D);return t||n}function isLegacyMapState(e){return isLegacy2DMapStateInternal(e)||isLegacy3DMapStateInternal(e)||isAnotherLegacyMapState(e)}function isLegacyTransformation3D(e){return isDefined(e.distance)}function isLegacyTransformation2D(e){return isNumber(e.scale)}function convertLegacy2DTransToNew(e){if(!e)return null;const{viewOrigin:r,worldOrigin:t,rotation:n}=e;let o;if(isNumber(e.scale))o=[e.scale,e.scale];else o=e.scale;return{viewOrigin:[r[0],r[1]],worldOrigin:[t[0],t[1]],scale:o,rotation:n}}function convertLegacy3DTransToNew(e,r,t,n){if(!e)return null;const o=isString(t)?getReference(t):t;let i=n.createPerspectiveCamera(o,r[0],r[1]);const a=i.asLookAt(e.distance);a.ref.x=e.referencePoint.x;a.ref.y=e.referencePoint.y;a.ref.z=e.referencePoint.z;a.distance=e.distance;a.yaw=e.yaw;a.pitch=e.pitch;a.roll=e.roll;i=i.lookAt(a);const c=i.asLookFrom();return{eyePointX:c.eye.x,eyePointY:c.eye.y,eyePointZ:c.eye.z,yaw:c.yaw,pitch:c.pitch,roll:c.roll}}function convertLegacyToNew(e,r,t){let n=null;let o=null;let i=[0,0];const a=e.reference;if(isLegacy2DMapStateInternal(e)){n=convertLegacy2DTransToNew(e.transformation);i=[n?2*n.viewOrigin[0]:r.getViewWidth(),n?2*n.viewOrigin[1]:r.getViewHeight()]}else if(isAnotherLegacyMapState(e)){i=e.viewSize;n=convertLegacy2DTransToNew(e.transformation2D);o=convertLegacy3DTransToNew(e.transformation3D,i,a,t)}else if(isLegacy3DMapStateInternal(e)){if(!r.is3D())throw new Error("Cannot restore legacy 3D states on a 2D map. If you want to restore 3D state on a 2D map, "+"update your state object using Map.saveState() with the current RIA version.");i=[r.viewSize[0],r.viewSize[1]];o=isLegacyTransformation3D(e.transformation)?convertLegacy3DTransToNew(e.transformation,i,a,t):e.transformation}return{reference:a,transformation2D:n,transformation3D:o,viewSize:i}}export function deserializeMapState(e,r,t){const n=parse(isString(e)?e:stringify(e));const o=isString(n.reference)?getReference(n.reference):r.reference;const i=isLegacyMapState(n)?convertLegacyToNew(n,r,t):n;const a=is3D(o);const c=i.viewSize[0];const s=i.viewSize[1];if(a&&is3D(r.reference))return deserializeCamera3D(i.transformation3D,o,c,s,t);return deserializeCamera2D(i.transformation2D,a?REFERENCE_2D_FOR_3D_MAPSTATE:o,c,s,t)}export function deserializeCamera3D(e,r,t,n,o){if(!e)return null;r=isString(r)?getReference(r):r;const i=isNumber(e.worldWidth);let a=i?o.create2DCamera(r,t,n):o.createPerspectiveCamera(r,t,n);const c=a.asLookFrom();c.eye.x=e.eyePointX;c.eye.y=e.eyePointY;c.eye.z=e.eyePointZ;c.yaw=e.yaw;c.pitch=e.pitch;c.roll=e.roll;a=a.lookFrom(c);if(isCartesian(r)&&isNumber(e.near))a=a.copyAndSet({near:e.near,far:e.far});if(i)a=a.copyAndSet({worldWidth:e.worldWidth,worldHeight:e.worldHeight});return a}export function deserializeCamera2D(e,r,t,n,o){if(!e)return null;r=isString(r)?getReference(r):r;let i=o.createCameraForReference(r,t,n);const a=e.scale;const c=i.asLook2D();c.worldOrigin=createPoint(r,e.worldOrigin);c.viewOrigin=createPoint(null,e.viewOrigin);c.scaleX=a[0];c.scaleY=a[1];c.rotation=e.rotation;i=i.look2D(c);return i}export function findMatchingCameraPosition(e,r,t,n,o,i){const a=is3D(t=isString(t)?getReference(t):t)||r.width===n&&r.height===o;if(r.worldReference.equals(t)&&a)return r.copyAndSet({width:n,height:o});const c=getReferencePointAndViewAngleToNorth(e,r);const s=undefined;return createMatchedCamera(e,getReferenceDistance(r,c.referencePointWorld),c.referencePoint,c.viewAngleToNorth,t,n||r.width,o||r.height,i)}export function serializeMapState(e){const r=is3D(e.reference);if(!r||e.isGeospatial()){const t=new CameraFactory(e);const n=r?REFERENCE_2D_FOR_3D_MAPSTATE:e.reference;const o=findMatchingCameraPosition(e,e.camera,n,e.viewSize[0],e.viewSize[1],t);const i=getReference("EPSG:4978");const a=r?findMatchingCameraPosition(e,e.camera,i,e.viewSize[0],e.viewSize[1],t):null;return{reference:e.reference.identifier,viewSize:[e.viewSize[0],e.viewSize[1]],transformation2D:serializeCamera(o),transformation3D:serializeCamera(a)}}else{const t=serializeCamera(e.camera);return{reference:e.reference.identifier,viewSize:[e.viewSize[0],e.viewSize[1]],transformation2D:r?null:t,transformation3D:r?t:null}}}export function serializeCamera(e){if(!e)return null;if(is3D(e.worldReference)){const r=e.asLookFrom();const t={eyePointX:r.eye.x,eyePointY:r.eye.y,eyePointZ:r.eye.z,yaw:r.yaw,pitch:r.pitch,roll:r.roll};if(isCartesian(e.worldReference)){t.near=e.near;t.far=e.far}if(e instanceof OrthographicCamera){t.worldWidth=e.worldWidth;t.worldHeight=e.worldHeight}return t}const r=e.asLook2D();return{worldOrigin:[r.worldOrigin.x,r.worldOrigin.y],viewOrigin:[r.viewOrigin.x,r.viewOrigin.y],scale:[r.scaleX,r.scaleY],rotation:r.rotation}}