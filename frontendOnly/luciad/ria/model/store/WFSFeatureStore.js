import{ProgrammingError}from"../../error/ProgrammingError.js";import{and,bbox}from"../../ogc/filter/FilterFactory.js";import{getReference,isValidReferenceIdentifier,parseWellKnownText}from"../../reference/ReferenceProvider.js";import{isBounds}from"../../shape/Bounds.js";import{EventedSupport}from"../../util/EventedSupport.js";import{isArray,isDefined,isFunction,isString,isUndefined}from"../../util/Lang.js";import{Log}from"../../util/Log.js";import{WithHttpRequestOptions}from"../../util/WithHttpRequestOptions.js";import{processServiceUrl}from"../capabilities/common/CapabilitiesParserUtil.js";import{WFSCapabilities}from"../capabilities/WFSCapabilities.js";import{getAutoDetectedCodec,getOutputFormat,mergeRequestMethods,performRequestAndConvertToCursorPromise}from"./StoreUtil.js";import{WFSCodec}from"./WFSCodec.js";import{WFSGetFeatureRequestParameterBuilder}from"./WFSGetFeatureRequestParameterBuilder.js";import{createTransformation}from"../../transformation/TransformationFactory.js";import{FilterElementType}from"../../ogc/filter/FilterElementType.js";import{ReferenceType}from"../../reference/ReferenceType.js";export let SortOrder=function(e){e[e["Ascending"]=0]="Ascending";e[e["Descending"]=1]="Descending";return e}({});export class WFSFeatureStore{constructor(e){this._eventSupport=new EventedSupport;const{serviceURL:r,typeName:t,reference:s,srsName:i,swapAxes:o,geometryName:n,versions:a,methods:u,outputFormat:c,bounds:p,codec:f,postServiceURL:m}=e||{};if(!r&&!m)throw new ProgrammingError("WFSFeatureStore: options.serviceURL is a required parameter");if(e.typeNames)Log.deprecated("options.typeNames","options.typeName");if(!t)throw new ProgrammingError("WFSFeatureStore: the typeName property must be specified "+"and the value must be a string or a QName.");if(isArray(t))throw new ProgrammingError("WFSFeatureStore: the typeName property only supports one "+"typeName. Replace the array by a string or a QName.");if(!s)throw new ProgrammingError("WFSFeatureStore: options.reference is a required parameter");if(f&&!isFunction(f.decode))throw new ProgrammingError("WFSFeatureStore: the codec must support the decode method");this._swapAxes=isArray(o)?o:[];this._geometryName=isString(n)?n:void 0;this._requestBuilder=new WFSGetFeatureRequestParameterBuilder(r,m);if(isArray(a))this._requestBuilder.supportedVersions=a;if(isArray(u))this._requestBuilder.supportedMethods=u;this._typeName=[t];this._outputFormat=c;this._codec=new WFSCodec(f||getAutoDetectedCodec(this._outputFormat));this._reference=s;this._srsName=i&&s.identifier!==i?i:void 0;this._bboxTransformationToCrs84=(s.wkt||!s.identifier)&&s.referenceType!=ReferenceType.CARTESIAN?createTransformation(s,getReference("CRS:84")):null;if(isDefined(e.withCredentials)){Log.deprecated("options.withCredentials","options.credentials");if(isUndefined(e.credentials))e.credentials=e.withCredentials}if(p&&isBounds(p))this._bounds=p;this._httpSupport=new WithHttpRequestOptions(e)}get credentials(){return this._httpSupport.credentials}set credentials(e){this._httpSupport.credentials=e}get requestHeaders(){return this._httpSupport.requestHeaders}set requestHeaders(e){this._httpSupport.requestHeaders=e}get requestParameters(){return this._httpSupport.requestParameters}set requestParameters(e){this._httpSupport.requestParameters=e}get bounds(){return this._bounds}static createFromCapabilities(e,r,t={}){const s=e.featureTypes.filter((e=>e.name===r))[0];if(!isDefined(s))throw new ProgrammingError(`there is no feature type "${r}" in capabilities`);const{reference:i,srsName:o}=getReferenceForWFS(s,t.reference);const n=e.operations.filter((e=>"GetFeature"===e.name))[0].supportedRequests;let a="";let u="";const c=[];n.forEach((e=>{const r=processServiceUrl(e.url);if("GET"===e.method)a=r;else if("POST"===e.method)u=r;c.push(e.method)}));if(isString(t.serviceURL)){a=t.serviceURL;u=t.serviceURL}else if(t.serviceURL){if(isString(t.serviceURL.GET))a=t.serviceURL.GET;if(isString(t.serviceURL.POST))u=t.serviceURL.POST}const p=t.versions||[e.version];const f=t.outputFormat||getOutputFormat(p,s.outputFormats);const m={typeName:s.qName||s.name,serviceURL:a,postServiceURL:u,reference:i,srsName:o,codec:t.codec,outputFormat:f,versions:p,methods:mergeRequestMethods(c,t.methods),credentials:t.credentials,requestHeaders:t.requestHeaders,swapAxes:t.swapAxes,geometryName:t.geometryName,requestParameters:t.requestParameters,bounds:getModelBoundsFromCapabilities(s,i)};return new WFSFeatureStore(m)}static async createFromURL(e,r,t){const s=await WFSCapabilities.fromURL(e,t);return WFSFeatureStore.createFromCapabilities(s,r,t)}query(e,r){let t;if(isArray((e=e||{}).filters)){t=e.filters.slice(0,1);Log.deprecated("filters","filter")}else t=e.filter?[e.filter]:[];if(isDefined(e.reverseAxes))Log.warn("WFSFeatureStore: the reverseAxes property is no longer supported by the query "+"method. This option can be specified on the GeoJsonCodec which you can pass in "+"the constructor. Consult the V2013.0 release notes for more information.");if(isDefined(e.outputFormat))Log.warn("WFSFeatureStore: the outputFormat is passed in the constructor and shouldn't be "+"passed as option to the query method. Consult the V2013.0 release notes for "+"more information.");const s=this._requestBuilder.build(this._typeName,t,this._outputFormat,this._srsName,e.maxFeatures,e.propertyNames,e.sortBy);const i=this.addHttpRequestOptions({signal:r?.abortSignal,...s.requestOptions});const o=this._httpSupport.getUrlWithRequestParameters(s.url);return performRequestAndConvertToCursorPromise(o,i,this._codec,this._reference)}spatialQuery(e,r,t){const s={...r};if(e)s.filter=this.createSpatialFilter(e,r?.filter);return this.query(s,t)}createSpatialFilter(e,r){if(r&&r.TYPE===FilterElementType.Id){Log.warn("WFSFeatureStore: Identifier expression cannot be combined with BBOX filter. Omitting the BBOX filter."+"Please use LoadEverything strategy on a layer associated with this store.");return r}const t=this._bboxTransformationToCrs84?.transformBounds(e)??e;const s=bbox(t,this._geometryName);s.swapAxes=this._swapAxes;if(this._srsName&&!this._bboxTransformationToCrs84)s.srsName=this._srsName;return r?and(s,r):s}getReference(){return this._reference}checkFeatureModelReference(e){if(!this._reference.equals(e))Log.warn("The reference of the FeatureModel does not match the reference of the WFSFeatureStore.");if(this._reference.identifier!==e.identifier)Log.warn("The identifier of the reference the FeatureModel does not match the identifier of the reference of the WFSFeatureStore.")}on(e,r,t){return this._eventSupport.on(e,r,t)}addHttpRequestOptions(e){return this._httpSupport.addHttpRequestOptions(e)}}function getReferenceForWFS(e,r){const t=getDataReference(e.defaultReference);if(t&&!r)return{reference:t,srsName:e.defaultReference};if(r){if(t&&t.equals(r))return{reference:t,srsName:e.defaultReference};const s=getOtherReferenceFromCapabilities(e.otherReferences,r);if(s)return s;console.warn(`WFSFeature: User reference '${r.identifier}' is not supported by WFS service`);return{reference:r}}const s=getOtherReferenceFromCapabilities(e.otherReferences);if(s)return s;throw new ProgrammingError("WFSFeature: No reference from WFS capabilities is supported")}function getOtherReferenceFromCapabilities(e,r){for(let t=0;t<e.length;t++){const s=e[t];const i=getDataReference(s);if(i){if(!r)return{reference:i,srsName:s};if(r.equals(i))return{reference:r,srsName:s}}}}function getDataReference(e){if(isValidReferenceIdentifier(e))return getReference(e);try{return parseWellKnownText(e)}catch(r){console.warn(`WFSFeatureStore: reference unsupported: ${e}`)}}function getModelBoundsFromCapabilities(e,r){const t=e.getWGS84Bounds()[0];if(t?.reference)return createTransformation(t.reference,r).transformBounds(t)}