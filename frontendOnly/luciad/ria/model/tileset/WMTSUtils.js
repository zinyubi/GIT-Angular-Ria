import{shouldSwapAxes}from"../../reference/AxisInformationUtil.js";import{createBounds}from"../../shape/ShapeFactory.js";import{XYZBounds}from"../../shape/XYZPointBounds.js";import{ProgrammingError}from"../../error/ProgrammingError.js";import{Lang}from"../../util/Lang.js";import{WMSVersion}from"../../ogc/WMSVersion.js";import{DEFAULT_WMTS_REQUEST_ENCODING,isBaseUrlKvpEncoded,isBaseUrlRestEncoded,WMTSRequestEncoding}from"./WMTSRequestEncoding.js";function isGridReference(e){return"undefined"!==typeof e.unitOfMeasure}function isWMTSOptions(e){return void 0!==e.structure}export function compareTileMatricesByScaleDenominator(e,t){return t.scaleDenominator-e.scaleDenominator}const PIXEL_RENDERING_SIZE=28e-5;function getWmtsQuadTreeCompatibleLevelOffset(e){const t=1e-8;const r=e[e.length-1];for(let i=e.length-2;i>=0;i--){const n=e[i];const o=1<<e.length-i-1;const s=n.scaleDenominator*t;if(Math.abs(n.scaleDenominator-r.scaleDenominator*o)>s)return i+1;if(n.topLeftCorner!==r.topLeftCorner)return i+1;if(n.tileWidth!==r.tileWidth||n.tileHeight!==r.tileHeight)return i+1;if(n.matrixWidth!==r.matrixWidth/o||n.matrixHeight!==r.matrixHeight/o)return i+1}return 0}function getWmtsTopLeftCoordinateAlignedCompatibleLevelOffset(e){const t=e[e.length-1];for(let r=e.length-2;r>=0;r--){const i=undefined;if(e[r].topLeftCorner!==t.topLeftCorner)return r+1}return 0}export function getWmtsCompatibleLevelOffset(e,t,r){if(t)return getWmtsQuadTreeCompatibleLevelOffset(e);if(r)return getWmtsTopLeftCoordinateAlignedCompatibleLevelOffset(e);return 0}function deriveQuadTreeStructure(e,t,r){const i=t.map((e=>e.identifier)).slice(r);const n=t[r];let o=e.getBounds();if(!o){const t=n.topLeftCorner.split(/\s+/).map((function(e){return parseFloat(e)}));const r=e.getReference();let i;if(isGridReference(r))i=r.unitOfMeasure;else i=r.geodeticDatum.ellipsoid.a*Math.PI/180;const s=n.scaleDenominator*PIXEL_RENDERING_SIZE/i*n.tileHeight*n.matrixHeight;const l=n.scaleDenominator*PIXEL_RENDERING_SIZE/i*n.tileWidth*n.matrixWidth;let a;let c;if(shouldSwapAxes(r,[])){a=t[1];c=t[0]-s}else{a=t[0];c=t[1]-s}o=createBounds(r,[a,l,c,s])}return{level0Columns:n.matrixWidth,level0Rows:n.matrixHeight,reference:e.getReference(),tileWidth:n.tileWidth,tileHeight:n.tileHeight,levelCount:i.length,bounds:o}}function deriveTileMatrixStructure(e,t,r){const i=undefined;if(getWmtsQuadTreeCompatibleLevelOffset(t)===r)return deriveQuadTreeStructure(e,t,r);const n=t.map((e=>e.identifier)).slice(r);const o=new Array(n.length);let s=e.getBounds();const l=!s;const a=e.getReference();let c;if(isGridReference(a))c=a.unitOfMeasure;else c=a.geodeticDatum.ellipsoid.a*Math.PI/180;for(let e=0;e<n.length;e++){const i=t[r+e];const n=i.topLeftCorner.split(/\s+/).map((function(e){return parseFloat(e)}));const u=i.scaleDenominator*PIXEL_RENDERING_SIZE/c*i.tileHeight*i.matrixHeight;const d=i.scaleDenominator*PIXEL_RENDERING_SIZE/c*i.tileWidth*i.matrixWidth;let f;let m;if(shouldSwapAxes(a,[])){f=n[1];m=n[0]-u}else{f=n[0];m=n[1]-u}const g=new XYZBounds(a,[f,d,m,u]);o[e]={bounds:g,tileColumnCount:i.matrixWidth,tileRowCount:i.matrixHeight,tileWidth:i.tileWidth,tileHeight:i.tileHeight};if(l)if(!s)s=g.copy();else s.setTo2DUnion(g)}if(!s)throw new Error(`Cannot derive the model bounds of the TileMatrixSet.`);return{reference:a,bounds:s,tileMatrix:o}}export function deriveWmtsStructure(e,t,r,i){return i?deriveQuadTreeStructure(e,t,r):deriveTileMatrixStructure(e,t,r)}function convertDeprecatedOptions(e,t,r){const i="WMTSTileSetModel::cannot construct WMTS model without valid mandatory parameters";if(void 0===e.bounds)throw new ProgrammingError(i);const n=e.reference?e.reference:e.bounds.reference;if(null==n)throw new ProgrammingError(i);const o={bounds:e.bounds,reference:n,levelCount:e.levelCount,level0Columns:e.level0Columns,level0Rows:e.level0Rows,tileWidth:e.tileWidth,tileHeight:e.tileHeight};e.baseURL=createKVPEncodedWmtsGetTileUrl(e.url,e.layer,t,r,e.tileMatrixSet);const s={baseURL:e.baseURL,url:e.url,layer:e.layer,style:e.style,format:e.format,tileMatrixSet:e.tileMatrixSet,tileMatrices:e.tileMatrices,dimensions:e.dimensions,structure:o};return{...e,...e,...s}}export function createKVPEncodedWmtsGetTileUrl(e,t,r,i,n){const o=e.includes("?")?"&":"?";return`${e}${o}SERVICE=WMTS&VERSION=${WMSVersion.V100}&REQUEST=GetTile&LAYER=${t}&STYLE=${r}&FORMAT=${i}&TILEMATRIXSET=${n}`}export function validateWMTSOptions(e){const t="WMTSTileSetModel::cannot construct WMTS model without valid mandatory parameters";if(!e)throw new ProgrammingError(t);const r=e.format||"image/jpeg";const i=Lang.isDefined(e.style)?e.style:"default";e.format=r;e.style=i;if(!isWMTSOptions(e))e=convertDeprecatedOptions(e,e.style,e.format);e.requestEncoding=e.requestEncoding??DEFAULT_WMTS_REQUEST_ENCODING;if(e.requestEncoding===WMTSRequestEncoding.KVP){if(isBaseUrlRestEncoded(e.baseURL))throw new ProgrammingError("Provided base URL is not compatible with KVP encoding");else if(!isBaseUrlKvpEncoded(e.baseURL)){if(!e.url)throw new ProgrammingError('Missing required parameter "url", Please provide a valid url');e.baseURL=createKVPEncodedWmtsGetTileUrl(e.url,e.layer,i,r,e.tileMatrixSet)}}else if(e.requestEncoding===WMTSRequestEncoding.REST)if(isBaseUrlRestEncoded(e.baseURL))e.baseURL=e.baseURL.replace(/{Style}/g,i).replace(/{TileMatrixSet}/g,e.tileMatrixSet);else throw new ProgrammingError("Provided base URL is not compatible with REST encoding");if(!Lang.isDefined(e.structure))throw new ProgrammingError(t);if(!Array.isArray(e.tileMatrices))throw new ProgrammingError(t);return e}export function createRESTEncodedWmtsGetTileUrl(e,t,r,i){const n=getTileTemplateUrl(e,r,"tile");if(!n)throw new ProgrammingError(`WMTS layer: [${e.identifier}] with format: [${r}] does not contain a tile template URL for resource type: 'tile' and request encoding: 'REST'`);return n.replace(/{Style}/g,t).replace(/{TileMatrixSet}/g,i)}export function getSupportedEncodingAndOutputFormatForGetTileRequest(e,t,r,i){const n=e?.getHttpGetRequestEncodings("GetTile",r.identifier,i);if(n?.length>0){const e=!!n?.includes(t);const o=e?t:n[0];if(!i)if(o===WMTSRequestEncoding.REST)i=r.resourceUrls?.filter((e=>"TILE"===e.resourceType.toUpperCase()))?.[0].format;else i=r.formats[0];return{supportedEncoding:o,wmtsFormat:i,isPreferredEncoding:e}}return{supportedEncoding:null,wmtsFormat:i,isPreferredEncoding:false}}export function getDimensionsFromLayer(e){const t={};e.dimensions.forEach((e=>t[e.identifier]=e.default));return Object.keys(t).length>0?t:void 0}function getTileTemplateUrl(e,t,r){const i=e.resourceUrls.filter((e=>e.format===t&&e.resourceType.toLowerCase()===r.toLowerCase()));return i.length>0?i[0].template:null}