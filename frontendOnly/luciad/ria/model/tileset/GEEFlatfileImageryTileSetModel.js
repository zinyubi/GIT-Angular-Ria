import{EmptyTileError}from"../../error/EmptyTileError.js";import{getReference}from"../../reference/ReferenceProvider.js";import{createBounds}from"../../shape/ShapeFactory.js";import{addHttpRequestOptions}from"../../util/HttpRequestOptions.js";import{isString}from"../../util/Lang.js";import{mimeType}from"../../util/mimeType.js";import{request}from"../../util/request.js";import{decodeImagery}from"../../view/gee/GEEImageryDecoder.js";import{GEEQuadTreeCache,isQuadtreeCacheEntryPending,isQuadtreeCacheEntryValid}from"../google/GEEQuadTreeCache.js";import{tileToGEEString}from"./GEETileSetUtil.js";import{RasterDataType}from"./RasterDataType.js";import{UrlTileSetModel}from"./UrlTileSetModel.js";import{TileRefinementStrategy}from"./RasterTileSetModel.js";export class GEEFlatfileImageryTileSetModel extends UrlTileSetModel{constructor(e){const t=getReference("EPSG:4326");const r=undefined;super({structure:{reference:t,bounds:createBounds(t,[-180,360,-90,180]),levelCount:25,level0Columns:2,level0Rows:1,tileWidth:256,tileHeight:256},baseURL:e.baseURL,dataType:RasterDataType.IMAGE,credentials:false});this._quadTreeCache=e.quadTreeCache??new GEEQuadTreeCache({baseUrl:e.baseURL});this._channelId=e.channelId;this._prefix=this._channelId?"f1c":"f1";this._postfix=this._channelId?"d."+this._channelId:"i";this.tileRefinementStrategy=TileRefinementStrategy.KEEP_REFINING_UNAVAILABLE_TILES}getTileURL(e,t,r=1){const i=isString(t)?t:this.getQuadTreeString(t);const a=this._quadTreeCache.getQuadTreeNode(i);if(!isQuadtreeCacheEntryPending(a)&&isQuadtreeCacheEntryValid(a)&&!a.hasImageryData)return null;return`${e}/flatfile?${this._prefix}-0${i}-${this._postfix}.${r}`}getImage(e,t,r,i){const a=r.bind(null,e);const s=this.getQuadTreeString(e);const n=this._quadTreeCache.getQuadTreeNode(s);if(isQuadtreeCacheEntryValid(n))return Promise.resolve(n).then((r=>{if(!isQuadtreeCacheEntryValid(r))return a("No imagery at this level.");const i=r.imageryVersion;if(!i)return r.hasTree&&!r.hasChildren?a("No imagery at this level."):a(new EmptyTileError("GEE: empty non-leaf tile."));return this.requestImageInternal(e,i,s,t,a)}),a);if(!this._quadTreeCache.isValid(s)){a("Quad Tree String invalid.");return Promise.resolve()}const o=()=>this.getImage(e,t,r,null);return this._quadTreeCache.requestMissingMetadata(s,a).then((()=>this._quadTreeCache.metadataReady(e,s,o,a)),a)}requestImageInternal(e,t,r,i,a){const s=this.getTileURL(this.baseURL,r,t);if(!s){a?.("Tile URL undefined.");return Promise.resolve()}const n=t=>{const r=decodeImagery(t);if(!r)return a("Could not decode imagery data");const s=new Image;const n=new Blob([r.data],{type:mimeType.jpeg});const o=URL.createObjectURL(n);s.onload=()=>i(e,s);s.onerror=a;s.src=o};const o=addHttpRequestOptions({},{credentials:false});return request(s,o).then((e=>e.arrayBuffer())).then(n).catch(a)}getQuadTreeString(e){const t=this.getTileRowCount(e.level)??0;const r=0!==e.level?t-e.y-1+(t>>1):e.y;return tileToGEEString(e.x,r,e.level)}}