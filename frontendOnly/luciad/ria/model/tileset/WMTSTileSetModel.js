import{ProgrammingError}from"../../error/ProgrammingError.js";import{isValidReferenceIdentifier}from"../../reference/ReferenceProvider.js";import{isDefined}from"../../util/Lang.js";import{Log}from"../../util/Log.js";import{processServiceUrl}from"../capabilities/common/CapabilitiesParserUtil.js";import{WMTSCapabilities}from"../capabilities/WMTSCapabilities.js";import{buildDimensionsQueryString,validateDimensions}from"../OGCUtil.js";import{UrlTileSetModel}from"./UrlTileSetModel.js";import{compareTileMatricesByScaleDenominator,createKVPEncodedWmtsGetTileUrl,createRESTEncodedWmtsGetTileUrl,deriveWmtsStructure,getDimensionsFromLayer,getSupportedEncodingAndOutputFormatForGetTileRequest,getWmtsCompatibleLevelOffset,validateWMTSOptions}from"./WMTSUtils.js";import{TileRefinementStrategy}from"./RasterTileSetModel.js";import{DEFAULT_WMTS_REQUEST_ENCODING,filterCapabilitiesOperationByEncoding,WMTSRequestEncoding}from"./WMTSRequestEncoding.js";class WMTSTileSetModel extends UrlTileSetModel{constructor(e){super(e=validateWMTSOptions(e));this.modelDescriptor={source:e.url,name:e.layer,description:"OGC WMTS Model",type:super.dataType};this._dimensions=null;this.tileMatrixSet=e.tileMatrixSet;this.tileMatrices=e.tileMatrices;this.dimensions=e.dimensions||null;this.tileRefinementStrategy=TileRefinementStrategy.KEEP_REFINING_UNAVAILABLE_TILES;this._requestEncoding=e.requestEncoding}static createFromCapabilities(e,t,i){const r=i||{};const s=isDefined(r.preferredRequestEncoding)?r.preferredRequestEncoding:DEFAULT_WMTS_REQUEST_ENCODING;const n=e.layers.filter((e=>e.identifier===t.layer))[0];const o=isDefined(r.useQuadTreeOnly)&&r.useQuadTreeOnly;if(!isDefined(n))throw new ProgrammingError(`there is no layer "${t.layer}" in capabilities`);const{supportedEncoding:l,wmtsFormat:a,isPreferredEncoding:d}=getSupportedEncodingAndOutputFormatForGetTileRequest(e,s,n,r.format);if(!a)throw new ProgrammingError("WMTSTileSetModel::cannot create WMTSTileSetModel, the service does not support any output MimeType for GetTile requests for the layer:  "+n.identifier+".");if(!l)throw new ProgrammingError(`WMTSTileSetModel::cannot create WMTSTileSetModel, the service neither supports KVP nor REST request encodings for GetTile requests for the layer:  ${n.identifier} .`);if(l&&!d)Log.debug(`The preferred encoding "${s}" is not supported. Setting request encoding to "${l}"`);let c;let m;let f;if(r.tileMatrixSet&&isDefined(r.tileMatrixSet)){c=n.tileMatrixSets.filter((e=>e.identifier===r.tileMatrixSet))[0];if(isDefined(c)){m=c.tileMatrices.slice().sort(compareTileMatricesByScaleDenominator);f=getWmtsCompatibleLevelOffset(m,o,false)}}else{let e,t,i;let s,l;for(let a=0;a<n.tileMatrixSets.length;a++){if(!isValidReferenceIdentifier(n.tileMatrixSets[a].referenceName)){Log.warn("Reference "+n.tileMatrixSets[a].referenceName+" in GetCapabilities response is not known by the ReferenceProvider. Consider adding it.");continue}const d=n.tileMatrixSets[a].tileMatrices.slice().sort(compareTileMatricesByScaleDenominator);if(!r.reference||!isDefined(r.reference)||r.reference.equals(n.tileMatrixSets[a].getReference())){const r=getWmtsCompatibleLevelOffset(d,o,true);if(o&&n.tileMatrixSets[a].tileMatrices[r].matrixWidth<=8&&n.tileMatrixSets[a].tileMatrices[r].matrixHeight<=8||!o&&0===r){t=r;i=d;e=n.tileMatrixSets[a];break}if(!o&&!isDefined(s)){l=d;s=n.tileMatrixSets[a]}}}if(isDefined(e)&&isDefined(t)&&isDefined(i)){c=e;m=i;f=t}else if(isDefined(s)){c=s;m=l;f=0}}if(!c||!isDefined(c)||!isDefined(f)||!isDefined(m))if(r.reference&&isDefined(r.reference))throw new ProgrammingError(`Could not find a WMTS tile matrix set that matches the specified reference [${r.reference.name}]`);else if(isDefined(r.tileMatrixSet))throw new ProgrammingError(`Could not find a WMTS tile matrix set that matches the specified identifier [${r.tileMatrixSet}]`);else throw new ProgrammingError("Could not find a supported WMTS tile matrix in the capabilities");const u=n.styles.filter((e=>e.isDefault))[0]||n.styles[0];const p=u&&u.identifier;let T="";if("KVP"===l){const t=filterCapabilitiesOperationByEncoding(e.requests.GetTile,l);if(isDefined(t))T=processServiceUrl(t.url)}const g=m.map((e=>e.identifier)).slice(f);const S=deriveWmtsStructure(c,m,f,o);const M=r.url||T;const h=n.identifier;const E=t.style||p;const R=c.identifier;const D=r.dimensions||getDimensionsFromLayer(n);const W="KVP"===l?createKVPEncodedWmtsGetTileUrl(M,h,E,a,R):createRESTEncodedWmtsGetTileUrl(n,E,a,R);return new WMTSTileSetModel({url:M,baseURL:W,layer:n.identifier,tileMatrixSet:R,format:a,tileMatrices:g,structure:S,style:E,credentials:r.credentials,requestHeaders:r.requestHeaders,dimensions:D,requestParameters:r.requestParameters,dataType:r.dataType,samplingMode:r.samplingMode,requestEncoding:l})}static createFromURL(e,t,i){return WMTSCapabilities.fromURL(e,i).then((e=>WMTSTileSetModel.createFromCapabilities(e,t,i)))}getTileBounds(e){return super.getTileBounds(e)}getTileURL(e,t){const i=this.tileMatrices[t.level];if(!isDefined(i))return null;const r=this.getTileRowCount(t.level);if(null==r)return null;const s=r-1-t.y;const n=t.x;const o=this.createPartialGetTileRequestUrl(e,i,s,n);return super.getTileURL(o,t)}get requestParameters(){return super.requestParameters}set requestParameters(e){super.requestParameters=e}get dimensions(){return this._dimensions}set dimensions(e){this._dimensions=validateDimensions(e);this.invalidate()}get isSparseTileSet(){return super.isSparseTileSet}get requestEncoding(){return this._requestEncoding}createPartialGetTileRequestUrl(e,t,i,r){if(this._requestEncoding===WMTSRequestEncoding.KVP){let s=`${e}&TILEMATRIX=${t}&TILEROW=${i}&TILECOL=${r}`;if(this._dimensions)s+=buildDimensionsQueryString(this._dimensions);return s}else{const s=e.replace(/{TileMatrix}/g,t.toString()).replace(/{TileRow}/g,i.toString()).replace(/{TileCol}/g,r.toString());return this.replaceDimensionPathVariablesInUrlTemplate(s)}}replaceDimensionPathVariablesInUrlTemplate(e){let t=e;if(this._dimensions&&Object.keys(this._dimensions).length>0){const e=this._dimensions;for(const i in e){const r=encodeURIComponent(i);let s=new RegExp("(.*)(/)("+r+")(/)({Value}|Value)(/)(.*)","g");t=t.replace(s,"$1$2$3$4"+encodeURIComponent(e[i])+"$6$7");s=new RegExp("(.*)(/)({"+r+"})(/)(.*)","g");t=t.replace(s,"$1$2"+encodeURIComponent(e[i])+"$4$5")}}const i=undefined;if(new RegExp("{Value}|Value|{.+}","g").test(t))throw new ProgrammingError(`The url template: [${t}] contains at least one dimension path variable for which corresponding dimension value was not specified.`);return t}}WMTSTileSetModel.constructor=WMTSTileSetModel;export{WMTSTileSetModel};