import{createBounds as createShapeBounds}from"../../../shape/ShapeFactory.js";import{getReference,isValidReferenceIdentifier}from"../../../reference/ReferenceProvider.js";import{isUndefined,isDefined}from"../../../util/Lang.js";import{createTransformation}from"../../../transformation/TransformationFactory.js";import{shouldSwapAxes}from"../../../reference/AxisInformationUtil.js";export function freeze(e){for(const n in e)if(isUndefined(e[n]))e[n]=null;return Object.freeze(e)}export function parseCornerValues(e){const n=[];if(e){const r=e.trim().split(/\s+/);if(2===r.length){const e=parseFloat(r[0]);const t=parseFloat(r[1]);if(!isNaN(e)&&!isNaN(t))n.push(e,t)}}return n}export function getBounds(e,n,r=false){const t=findBounds(e,n);if(isDefined(t))return createBounds(t,r);return _transformFirstKnownBounds(e,n,r)}function _transformFirstKnownBounds(e,n,r){for(let t=0;t<e.length;t++){const i=e[t];if(!isDefined(i.reference)||!isValidReferenceIdentifier(i.reference))continue;const s=getReference(i.reference);const o=undefined;return createTransformation(s,n).transformBounds(createBounds(i,r))}return null}function createBounds(e,n){const r=getReference(e.reference);let t;if(n&&shouldSwapAxes(r,[]))t=[e.y,e.height,e.x,e.width];else t=[e.x,e.width,e.y,e.height];return createShapeBounds(r,t)}export function findBounds(e,n){for(let r=0;r<e.length;r++){const t=e[r];if(!isDefined(t.reference)||!isValidReferenceIdentifier(t.reference))continue;if(equalsWithAxisOrder(getReference(t.reference),n))return t}return null}export function processServiceUrl(e){return"?"===e[e.length-1]?e.substring(0,e.length-1):e}function equalsWithAxisOrder(e,n){const r=e.axisInformation;const t=n.axisInformation;return e.equals(n)&&r.length>=2&&t.length>=2&&r[0].name===t[0].name&&r[0].axis.equals(t[0].axis)&&r[1].name===t[1].name&&r[1].axis.equals(t[1].axis)}