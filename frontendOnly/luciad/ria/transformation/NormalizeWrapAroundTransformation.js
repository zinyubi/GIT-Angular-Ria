import{Transformation}from"./Transformation.js";export class NormalizeWrapAroundTransformation extends Transformation{constructor(t){super(t.inputReference,t.outputReference);this._delegate=t;const i=t.inputReference.bounds;this._projectionWidth=i.width;this._halfProjectionWidth=i.width/2;this._projectionMin=i.x;this._projectionMax=i.x+i.width}_forward(t,i){while(t.x>this._projectionMax)t.x=(t.x+this._halfProjectionWidth)%this._projectionWidth-this._halfProjectionWidth;while(t.x<this._projectionMin)t.x=(t.x-this._halfProjectionWidth)%this._projectionWidth+this._halfProjectionWidth;return this._delegate._forward(t,i)}_forwardBoundsCoords(t,i){while(t.x>this._projectionMax)t.x=(t.x+this._halfProjectionWidth)%this._projectionWidth-this._halfProjectionWidth;while(t.x<this._projectionMin)t.x=(t.x-this._halfProjectionWidth)%this._projectionWidth+this._halfProjectionWidth;this._delegate._forwardBoundsCoords(t,i)}_inverse(t,i){return this._delegate._inverse(t,i)}_inverseBoundsCoords(t,i){return this._delegate._inverseBoundsCoords(t,i)}}