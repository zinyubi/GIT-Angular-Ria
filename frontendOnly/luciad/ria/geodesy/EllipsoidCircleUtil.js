import{Constants}from"../util/Constants.js";import{LLHPoint}from"../shape/LLHPoint.js";import{containsAngle,normalizeAngle}from"../util/Cartesian.js";import{RealFunctionUtil}from"./RealFunctionUtil.js";const tempPoint1=new LLHPoint;const tempPoint2=new LLHPoint;function find(t,e,o,n,i,s){let c,a,m,r,P,l;const p=n.geodesicDistance(t,e);const f=n.geodesicDistance(t,o);const D=n.geodesicDistance(e,o);const d=n.forwardAzimuth2D(t,e)*Constants.RAD2DEG;const u=n.forwardAzimuth2D(t,o)*Constants.RAD2DEG;const g=normalizeAngle(u-d);let C=Math.min(p,Math.min(f,D))/2;n.geodesicPositionAtFractionSFCT(e,o,.5,tempPoint1);const h=n.geodesicDistance(t,tempPoint1);let A=Number.MAX_VALUE;let x=Number.MAX_VALUE;if(h<=D){const p=Math.abs(g)>=90;const f=1e-4;let D=0;let d=n.auxRadius*Math.PI;let u=0;if("number"!==typeof s){C=s=0;u++;l=intersectionCircleCircle(e,C,o,C,n,tempPoint1,tempPoint2);if(0===l)D=C;else if(1===l){c=n.geodesicDistance(t,tempPoint1);A=tempPoint1.x;x=tempPoint1.y;if(c>=C)D=C;else d=C}else if(2===l){a=n.geodesicDistance(t,tempPoint1);m=n.geodesicDistance(t,tempPoint2);c=p?Math.max(a,m):Math.min(a,m);r=Math.abs(a-C);P=Math.abs(m-C);if(r<P){A=tempPoint1.x;x=tempPoint1.y}else{A=tempPoint2.x;x=tempPoint2.y}if(p)if(c<=C||a>=C&&m>=C)D=C;else d=C;else if(c>=C)D=C;else d=C}let g=Math.max(f,Math.min(1,.001*C));const h=D===C;let T=C;while(T>=D&&T<=d&&d-D>f){T=h?C+g:C-g;if(u>=7)break;const i=Math.ceil(Math.log((d-D)/f)/Math.log(2));const s=undefined;if(Math.ceil(Math.log(g/f)/Math.log(2))+1>=i)break;u++;l=intersectionCircleCircle(e,T,o,T,n,tempPoint1,tempPoint2);let M=true;let F;if(0===l){D=T;n.geodesicPositionAtFractionSFCT(e,o,.5,tempPoint1);F=n.geodesicDistance(t,tempPoint1)}else if(1===l){c=n.geodesicDistance(t,tempPoint1);A=tempPoint1.x;x=tempPoint1.y;if(c>=C)D=T;else d=T;F=c}else if(2===l){a=n.geodesicDistance(t,tempPoint1);m=n.geodesicDistance(t,tempPoint2);c=p?Math.max(a,m):Math.min(a,m);r=Math.abs(a-C);P=Math.abs(m-C);if(r<P){A=tempPoint1.x;x=tempPoint1.y}else{A=tempPoint2.x;x=tempPoint2.y}if(p)if(c<=T||a>=C&&m>=C)D=T;else d=T;else if(c>=T)D=T;else d=T;F=c}else{M=false;F=0}if(M)if(h&&d===T||!h&&D===T){if(h)d=T;else D=T;break}else{const t=2*Math.abs(T-F)/3;g=Math.max(2*g,t-T+C)}else g*=10}C=T;i.move2D(A,x)}D=0;while(d-D>f){u++;C=(D+d)/2;l=intersectionCircleCircle(e,C,o,C,n,tempPoint1,tempPoint2);if(0===l)D=C;else if(1===l){c=n.geodesicDistance(t,tempPoint1);A=tempPoint1.x;x=tempPoint1.y;if(c>=C)D=C;else d=C}else if(2===l){a=n.geodesicDistance(t,tempPoint1);m=n.geodesicDistance(t,tempPoint2);c=p?Math.max(a,m):Math.min(a,m);r=Math.abs(a-C);P=Math.abs(m-C);if(r<P){A=tempPoint1.x;x=tempPoint1.y}else{A=tempPoint2.x;x=tempPoint2.y}if(p)if(c<=C||a>=C&&m>=C)D=C;else d=C;else if(c>=C)D=C;else d=C}i.move2D(A,x)}return C}i.move2D(A,x);return C}function intersectionCircleCircle(t,e,o,n,i,s,c){const a=i.geodesicDistance(t,o);if(a>e+n)return 0;if(a<=Math.abs(n-e))return 0;if(a===e+n){i.geodesicPositionAtFractionSFCT(t,o,.5,s);return 1}calculateIntersectionPoint(t,e,o,n,i,-180,s,c);const m=s.x;const r=s.y;calculateIntersectionPoint(t,e,o,n,i,180,s,c);const P=s.x;const l=s.y;s.move2D(m,r);c.move2D(P,l);return 2}function calculateIntersectionPoint(t,e,o,n,i,s,c,a){const m=i.forwardAzimuth2D(t,o)*Constants.RAD2DEG;const r=c;let P=m;i.geodesicPositionSFCT(t,e,P,r);const l=a;let p=m+s;i.geodesicPositionSFCT(t,e,p,l);while(Math.abs(p-P)>=1e-10){const s=(P+p)/2;i.geodesicPositionSFCT(t,e,s,tempPoint1);const c=undefined;if(i.geodesicDistance(o,tempPoint1)<=n){r.move2D(tempPoint1);P=s}else{l.move2D(tempPoint1);p=s}}i.geodesicPositionAtFractionSFCT(r,l,.5,tempPoint1);c.move2D(tempPoint1)}export function calculateLLHBoundsCircular(t,e,o,n,i,s){const c=t.geodesicPositionSFCT(e,o,n,tempPoint1);s.x=c.x;s.y=c.y;s.width=0;s.height=0;const a=3;const m=i/a;for(let c=1;c<=a;c++){if(c===a&&i>=360)continue;const r=n+c*m;const P=t.geodesicPositionSFCT(e,o,r,tempPoint1);s.setToIncludePoint3D(P)}if(containsAngle(n,i,0)){const n=t.geodesicPositionSFCT(e,o,0,tempPoint1);s.setToIncludePoint3D(n)}if(containsAngle(n,i,180)){const n=t.geodesicPositionSFCT(e,o,180,tempPoint1);s.setToIncludePoint3D(n)}const r={x:0,y:e.y,z:0};const P=e=>t.geodesicPositionSFCT(r,o,e,tempPoint1).x;const l=RealFunctionUtil.minimize(P,225,315,.001);if(containsAngle(n,i,l)){const n=t.geodesicPositionSFCT(e,o,l,tempPoint1);s.setToIncludePoint3D(n)}if(containsAngle(n,i,l-180)){const n=t.geodesicPositionSFCT(e,o,l-180,tempPoint1);s.setToIncludePoint3D(n)}s.enlarge2D(1+1e-8);return s}export function calculateLLHCircleBounds(t,e,o,n){return calculateLLHBoundsCircular(t,e,o,0,360,n)}export function contains2D(t,e,o,n,i){tempPoint1.x=n;tempPoint1.y=i;const s=t.geodesicDistance(e,tempPoint1);return s-o<=Constants.ABSOLUTE_DISTANCE_TOLERANCE+Constants.RELATIVE_DISTANCE_TOLERANCE*s}export function getFocusPoint(t,e){return t.center}export function findCenter(t,e,o,n,i,s){const c=t.x===e.x&&t.y===e.y;const a=t.x===o.x&&t.y===o.y;const m=e.x===o.x&&e.y===o.y;if(c&&a&&m){i.move2D(t);return 0}else if(a||c||m){if(c)n.geodesicPositionAtFractionSFCT(t,o,.5,i);else n.geodesicPositionAtFractionSFCT(t,e,.5,i);return n.geodesicDistance(t,i)}const r=n.forwardAzimuth2D(t,e)*Constants.RAD2DEG;const P=n.forwardAzimuth2D(t,o)*Constants.RAD2DEG;const l=n.forwardAzimuth2D(e,o)*Constants.RAD2DEG;const p=n.forwardAzimuth2D(e,t)*Constants.RAD2DEG;const f=n.forwardAzimuth2D(o,t)*Constants.RAD2DEG;const D=n.forwardAzimuth2D(o,e)*Constants.RAD2DEG;const d=Math.abs(normalizeAngle(P-r));const u=Math.abs(normalizeAngle(l-p));const g=Math.abs(normalizeAngle(f-D));let C;let h;let A;if(u>=d&&u>=g){C=e;h=t;A=o}else if(d>=u&&d>=g){C=t;h=e;A=o}else{C=o;h=e;A=t}return find(C,h,A,n,i,s)}export function translateCircleBy3Points2D(t,e,o,n){const i=t.focusPoint;const s=e.forwardAzimuth2D(i,t.firstPoint)*Constants.RAD2DEG;const c=e.forwardAzimuth2D(i,t.secondPoint)*Constants.RAD2DEG;const a=e.forwardAzimuth2D(i,t.thirdPoint)*Constants.RAD2DEG;const m=e.geodesicDistance(t.firstPoint,i);const r=e.geodesicDistance(t.secondPoint,i);const P=e.geodesicDistance(t.thirdPoint,i);tempPoint2.x=i.x;tempPoint2.y=i.y;tempPoint2.translate(o,n);e.geodesicPositionSFCT(tempPoint2,m,s,tempPoint1);t.moveFirstPoint2DToCoordinates(tempPoint1.x,tempPoint1.y);e.geodesicPositionSFCT(tempPoint2,r,c,tempPoint1);t.moveSecondPoint2DToCoordinates(tempPoint1.x,tempPoint1.y);e.geodesicPositionSFCT(tempPoint2,P,a,tempPoint1);t.moveThirdPoint2DToCoordinates(tempPoint1.x,tempPoint1.y)}