import{PolygonOrientation}from"../shape/PolygonOrientation.js";import{simplePointMove2D}from"../shape/SimplePoint.js";import{containsAngle as cartesianContainsAngle,normalizeAngle}from"../util/Cartesian.js";import{Constants}from"../util/Constants.js";import{normalizeLon}from"../util/LonLatCoord.js";import{geodesicArea as externalGeodesicArea}from"./GeodesicAreaUtil.js";import{bufferContour2DOf2DPolyline}from"./SphereUtil.js";const EQUAL_POINTS_EPSILON=1e-10;const EQUAL_ANGLES_EPSILON=1e-6;function rad2Deg(n){return n*Constants.RAD2DEG}function equalAzimuths(n,e){return Math.abs(normalizeAngle(n-e))<EQUAL_ANGLES_EPSILON}function containsAngle(n,e,t,o){if(e>=0){n-=o;e+=2*o}else if(e<0){n+=o;e-=2*o}return cartesianContainsAngle(n,e,t)}function containsAngleTolerance(n,e,t,o,i){const s=0==e?o:(e<0?-1:1)*(o+i*Math.abs(e));return cartesianContainsAngle(n-s,e+2*s,t)}export function contains2D(n,e,t,o){const i=n.geodesicDistance(e,o);if(i<EQUAL_POINTS_EPSILON)return true;const s=undefined;if(i>n.geodesicDistance(e,t)+EQUAL_POINTS_EPSILON)return false;const r=undefined;const a=undefined;return equalAzimuths(n.forwardAzimuth2D(e,o)*Constants.RAD2DEG,n.forwardAzimuth2D(e,t)*Constants.RAD2DEG)}function intersection2DLineSegmentsWithCommonEndPoint(n,e,t,o,i){const s=undefined;const r=undefined;let a;let D;if(equalAzimuths(Constants.RAD2DEG*o.forwardAzimuth2D(n,e),Constants.RAD2DEG*o.forwardAzimuth2D(n,t))){if(isPole(n))if(equalLongitudes(e,t)){a=o.geodesicDistance(n,e);D=o.geodesicDistance(n,t);if(a<D)i.move2D(e.x,e.y);else i.move2D(t.x,t.y);return-1}else return 1;a=o.geodesicDistance(n,e);D=o.geodesicDistance(n,t);if(a<D)i.move2D(e.x,e.y);else i.move2D(t.x,t.y);return-1}return 1}function equal2DPoints(n,e){return equalPoles(n,e)||equalLongitudes(n,e)&&equalLatitudes(n,e)}function equalPoles(n,e){return isPole(n)&&isPole(e)&&Math.abs(n.y-e.y)<EQUAL_POINTS_EPSILON}function isPole(n){return Math.abs(Math.cos(n.y))<EQUAL_POINTS_EPSILON}function equalLongitudes(n,e){return Math.abs(normalizeLon(n.x-e.x))<EQUAL_POINTS_EPSILON}function equalLatitudes(n,e){return Math.abs(n.y-e.y)<EQUAL_POINTS_EPSILON}export function lonLatContainedOnSegment2D(n,e,t,o,i,s,r){const a={x:e,y:t,z:0};const D={x:o,y:i,z:0};const u={x:s,y:r,z:0};const c=n.geodesicDistance(a,u);if(c<EQUAL_POINTS_EPSILON)return true;const l=undefined;if(c>n.geodesicDistance(a,D)+EQUAL_POINTS_EPSILON)return false;const f=undefined;const A=undefined;return equalAzimuths(rad2Deg(n.forwardAzimuth2D(a,u)),rad2Deg(n.forwardAzimuth2D(a,D)))}export function closestPointOnGeodesic(n,e,t,o,i,s,r){const a=o.geodesicDistance(n,e);let D=Math.max(s,i*a);if(0===D){D=o.a/Constants.EARTH_RADIUS;if(D<=1.1&&D>=.9)D=1}if(a<=D){simplePointMove2D(r,n.x,n.y);return o.geodesicDistance(t,n)}const u=o.forwardAzimuth2D(n,e)*Constants.RAD2DEG;const c=D/a;let l=0;let f=1;const A=(3-Math.sqrt(5))/2;const m=2*(0|Math.ceil(Math.abs(Math.log(c)/Math.log(A))))+1;let d,E,P,g,h,C,L,x,S,y;let z=A;o.geodesicPositionSFCT(n,z*a,u,r);d=o.geodesicDistance(t,r);let G=z;let O=z;let _=d;let N=d;for(let e=0;e<m;e++){E=f-l;P=(l+f)/2;g=1e-12*Math.abs(G)+c/3;if(Math.abs(G-P)+E/2<=2*g)return _;h=A*(Math.abs(G)<P?f-G:l-G);if(Math.abs(G-O)>=g){x=(G-O)*(_-d);L=(G-z)*(_-N);C=(G-z)*L-(G-O)*x;L=2*(L-x);if(L>0)C=-C;else L=-L;if(Math.abs(C)<Math.abs(h*L)&&C>L*(l-G+2*g)&&C<L*(f-G-2*g))h=C/L}if(Math.abs(h)<g)if(h>0)h=g;else h=-g;S=G+h;o.geodesicPositionSFCT(n,S*a,u,r);y=o.geodesicDistance(t,r);if(y<=_){if(S<G)f=G;else l=G;z=O;O=G;G=S;d=N;N=_;_=y}else{if(S<G)l=S;else f=S;if(y<=N||O===G){z=O;O=S;d=N;N=y}else if(y<=N||z===G||z===O){z=S;d=y}}}return _}export function intersection2DLineSegments(n,e,t,o,i,s,r,a){if(equal2DPoints(n,e))if(contains2D(i,t,o,n)){r.move2D(n.x,n.y);return 1}else return 0;if(equal2DPoints(t,o))if(contains2D(i,n,e,t)){r.move2D(t.x,t.y);return 1}else return 0;if(equal2DPoints(n,t)){r.move2D((n.x+t.x)/2,n.y);return intersection2DLineSegmentsWithCommonEndPoint(n,e,o,i,a)}if(equal2DPoints(n,o)){r.move2D((n.x+o.x)/2,n.y);return intersection2DLineSegmentsWithCommonEndPoint(n,e,t,i,a)}if(equal2DPoints(e,t)){r.move2D((e.x+t.x)/2,e.y);return intersection2DLineSegmentsWithCommonEndPoint(e,n,o,i,a)}if(equal2DPoints(e,o)){r.move2D((e.x+o.x)/2,e.y);return intersection2DLineSegmentsWithCommonEndPoint(e,n,t,i,a)}const D=Constants.RAD2DEG*i.forwardAzimuth2D(n,e);const u=Constants.RAD2DEG*i.forwardAzimuth2D(n,t);const c=Constants.RAD2DEG*i.forwardAzimuth2D(n,o);let l=normalizeAngle(c-u);if(!containsAngle(u,l,D,EQUAL_ANGLES_EPSILON))return 0;const f=Constants.RAD2DEG*i.forwardAzimuth2D(e,t);const A=Constants.RAD2DEG*i.forwardAzimuth2D(e,o);const m=Constants.RAD2DEG*i.forwardAzimuth2D(e,n);l=normalizeAngle(A-f);if(!containsAngle(f,l,m,EQUAL_ANGLES_EPSILON))return 0;if(contains2D(i,t,o,n)){r.move2D(n.x,n.y);if(contains2D(i,t,o,e)){a.move2D(e.x,e.y);return-1}else if(contains2D(i,n,e,t)){a.move2D(t.x,t.y);return-1}else if(contains2D(i,n,e,o)){a.move2D(o.x,o.y);return-1}else return 1}else if(contains2D(i,t,o,e)){r.move2D(e.x,e.y);if(contains2D(i,n,e,t)){a.move2D(t.x,t.y);return-1}else if(contains2D(i,n,e,o)){a.move2D(o.x,o.y);return-1}else return 1}else if(contains2D(i,n,e,t)){r.move2D(t.x,t.y);if(contains2D(i,n,e,o)){a.move2D(o.x,o.y);return-1}return 1}else if(contains2D(i,n,e,o)){r.move2DToCoordinates(o.x,o.y);return 1}let d=0;const E=r;const P=a;const g=r.copy();const h=i.geodesicDistance(n,e);const C=i.geodesicDistance(t,o);let L=s;if(L<=0){L=i.a/Constants.EARTH_RADIUS;if(L<=1.1&&L>=.9)L=1}else if(L<.001)L=.001;const x=Math.ceil(Math.log(C/L)/Math.log(2));let S,y,z,G,O;if(h<C){S=h;E.move2D(n.x,n.y);P.move2D(e.x,e.y);z=Constants.RAD2DEG*i.forwardAzimuth2D(t,n);G=Constants.RAD2DEG*i.forwardAzimuth2D(t,o);for(let e=0;e<x;++e){S/=2;i.geodesicPositionSFCT(n,d+S,D,g);y=Constants.RAD2DEG*i.forwardAzimuth2D(t,g);l=normalizeAngle(y-z);if(containsAngle(z,l,G,0))P.move2D(g.x,g.y);else{E.move2D(g.x,g.y);d+=S}}i.geodesicPositionSFCT(n,d+S/2,D,r)}else{S=C;E.move2D(t.x,t.y);P.move2D(o.x,o.y);G=Constants.RAD2DEG*i.forwardAzimuth2D(t,o);for(let e=0;e<x;++e){S/=2;i.geodesicPositionSFCT(t,d+S,G,g);O=Constants.RAD2DEG*i.forwardAzimuth2D(n,g);l=normalizeAngle(O-u);if(containsAngle(u,l,D,0))P.move2D(g.x,g.y);else{E.move2D(g.x,g.y);d+=S}}i.geodesicPositionSFCT(t,d+S/2,G,r)}return 1}export function intersects2DLS(n,e,t,o,i){if(equal2DPoints(e,o)||equal2DPoints(e,i)||equal2DPoints(t,o)||equal2DPoints(t,i))return true;if(equal2DPoints(e,t))return contains2D(n,o,i,e);const s=Constants.RAD2DEG*n.forwardAzimuth2D(e,t);const r=Constants.RAD2DEG*n.forwardAzimuth2D(e,o);const a=Constants.RAD2DEG*n.forwardAzimuth2D(e,i);let D=normalizeAngle(a-r);if(180===D)return true;if(!containsAngleTolerance(r,D,s,EQUAL_ANGLES_EPSILON,0))return false;const u=Constants.RAD2DEG*n.forwardAzimuth2D(t,o);const c=Constants.RAD2DEG*n.forwardAzimuth2D(t,i);const l=Constants.RAD2DEG*n.forwardAzimuth2D(t,e);D=normalizeAngle(c-u);return 180===D||containsAngleTolerance(u,D,l,EQUAL_ANGLES_EPSILON,0)}export function bufferContour2DOf2DPolylineSFCT(n,e,t,o){const i=t*Constants.RAD2DEG/n.auxRadius;bufferContour2DOf2DPolyline(e,i,o)}export function orientation2D(n,e){const t=undefined;return externalGeodesicArea(n,e)>0?PolygonOrientation.COUNTER_CLOCKWISE:PolygonOrientation.CLOCKWISE}export function geodesicArea(n,e){let t=0;let o=0;const i=n.pointCount;for(let e=0;e<i;e++){const s=n.getPoint(e);const r=n.getPoint((e+1)%i);if(!s.equals(r)){t+=s.y;o++}}t/=0==o?1:o;const s=Math.sin(t*Constants.DEG2RAD);const r=undefined;const a=undefined;return e.radiusVertical(s)*e.radiusMeridian(s)*externalGeodesicArea(n,e)}