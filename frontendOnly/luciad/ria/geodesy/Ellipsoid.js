import{ProgrammingError}from"../error/ProgrammingError.js";import{Constants}from"../util/Constants.js";import{normalizeLon}from"../util/LonLatCoord.js";import{forwardAzimuth2D as forwardAzimuth2DUtil}from"./AzimuthUtil.js";import{intersection2DLineSegments,intersects2DLS}from"./EllipsoidUtil.js";import{greatCircleDistanceLL,greatCirclePointAtFractionSFCT}from"./SphereUtil.js";import{isString}from"../util/Lang.js";const EPSILON=1e-10;const EMPTY_STRING="";export class Ellipsoid{static createWGS84(){return new Ellipsoid}constructor(){this._name=null;this._A=0;this._B=0;this._1OverF=0;this._F=0;this._E2=0;this._E=0;this._EMinor2=0;this._N=0;this._BTimesEMinor2=0;this._ATimesE2=0;this._C1=0;this._C2=0;this._C3=0;this._C4=0;this._C5=0;this._C6=0;this._B1=0;this._B2=0;this._B3=0;this._B4=0;this.initializeA1OverF(Constants.WGS_1984_A,Constants.WGS_1984_1OverF)}initializeAB(t,s){this._A=t;this._B=s;this._1OverF=this._A/(this._A-this._B);this._F=(this._A-this._B)/this._A;this._E2=(this._A+this._B)/(this._A*this._1OverF);this.initializeCoefficients()}initializeA1OverF(t,s){this._A=t;this._1OverF=s;this._F=1/this._1OverF;this._B=this._A*(1-this._F);this._E2=(2-1/this._1OverF)/this._1OverF;this.initializeCoefficients()}initializeCoefficients(){this._E=Math.sqrt(this._E2);const t=this._A*this._A,s=this._B*this._B;this._EMinor2=(t-s)/s;this._N=(this._A-this._B)/(this._A+this._B);this._BTimesEMinor2=this._B*this._EMinor2;this._ATimesE2=this._A*this._E2;const n=this._E2*this._E2;const i=n*this._E2;const a=n*n;this._C1=1+this._E2*(3/4+this._E2*(45/64+this._E2*(175/256+this._E2*(11025/16384+this._E2*(43659/65536)))));this._C2=this._E2*(3/8+this._E2*(15/32+this._E2*(525/1024+this._E2*(2205/4096+this._E2*(72765/131072)))));this._C3=n*(15/256+this._E2*(105/1024+this._E2*(2205/16384+this._E2*(10395/65536))));this._C4=i*(35/3072+this._E2*(105/4096+this._E2*(10395/262144)));this._C5=this._E2*i*(315/131072+this._E2*(3465/524288));this._C6=n*i*(693/1310720);const o=this._E2/2+5/24*n+1/12*i+13/360*a;const h=7/48*n+29/240*i+811/11520*a;const e=7/120*i+81/1120*a;const r=4279/161280*a;this._B1=2*o+4*h+6*e+8*r;this._B2=-8*h-32*e-80*r;this._B3=32*e+192*r;this._B4=-128*r}isSphere(){return this._A===this._B||this._1OverF===1/0}equals(t){return t instanceof Ellipsoid&&this._A===t._A&&this._1OverF===t._1OverF}radiusVertical(t){return this._A/Math.sqrt(1-this._E2*t*t)}radiusMeridian(t){return this._A*(1-this._E2)/Math.pow(1-this._E2*t*t,1.5)}radiusEuler(t,s){return this.radiusEulerImpl(t,Math.sin(t*Constants.DEG2RAD),s,Math.cos(s),Math.sin(s))}radiusEulerImpl(t,s,n,i,a){const o=this.radiusMeridian(s);const h=this.radiusVertical(s);return o*h/(o*a*a+h*i*i)}meridionalArcDistance(t){if(0===t)return 0;const s=t*Constants.DEG2RAD;const n=Math.cos(s);const i=Math.sin(s);return this.meridionalArcDistanceOptimized(t,n,i)}meridionalArcDistanceOptimized(t,s,n){const i=t*Constants.DEG2RAD;const a=s*s-n*n;const o=2*s*n;const h=a*a-o*o;const e=2*a*o;const r=undefined;const c=e*a+h*o;const _=2*h*e;const M=c*h+(h*a-e*o)*e;return this._A*(1-this._E2)*(this._C1*i-this._C2*o+this._C3*e-this._C4*c+this._C5*_-this._C6*M)}conformalSphericalLonLatPointSFCT(t,s){s.x=t.x;const n=t.y*Constants.DEG2RAD;const i=Math.cos(n);const a=Math.sin(n);const o=i*i-a*a;const h=2*i*a;const e=undefined;const r=2*o*h;const c=r*o+(o*o-h*h)*h;const _=this._E2*this._E2;const M=this._E2*(.5+this._E2*(5/24+3*this._E2/32));const E=_*(5/48+7*this._E2/80);const l=this._E2*_*13/480;s.y=(n-M*h+E*r-l*c)*Constants.RAD2DEG}inverseConformalSphericalLonLatPointSFCT(t,s){s.x=t.x;const n=t.y*Constants.DEG2RAD;const i=Math.cos(n);const a=Math.sin(n);const o=a*a;s.y=(n+a*i*(this._B1+o*(this._B2+o*(this._B3+o*this._B4))))*Constants.RAD2DEG}geod2geocSFCT(t,s){const n=Constants.DEG2RAD;const i=t.z||0;const a=Math.cos(t.y*n);const o=Math.cos(t.x*n);const h=Math.sin(t.y*n);const e=Math.sin(t.x*n);const r=this.radiusVertical(h);s.x=(r+i)*a*o;s.y=(r+i)*a*e;s.z=(r*(1-this._E2)+i)*h}geoc2geodSFCT(t,s){const n=t.x,i=t.y,a=t.z;let o=0;if(Math.abs(n)<=EPSILON)if(i>0)o=Constants.RAD2DEG*Math.PI/2;else if(i<0)o=Constants.RAD2DEG*-Math.PI/2;else{s.x=0;if(a>0){s.y=Constants.RAD2DEG*Math.PI/2;s.z=a-this._B}else if(a<0){s.y=Constants.RAD2DEG*(-Math.PI/2);s.z=-(this._B+a)}else{s.y=Constants.RAD2DEG*Math.PI/2;s.z=-this._B}return}else o=Math.atan2(i,n)*Constants.RAD2DEG;const h=n*n+i*i,e=Math.sqrt(h);const r=e*this._B,c=a*this._A;const _=Math.sqrt(r*r+c*c);let M=1,E=0;if(_>EPSILON){M=r/_;E=c/_}let l=a+this._BTimesEMinor2*E*E*E,D=e-this._ATimesE2*M*M*M;const A=(1-this._F)*(l/D);M=1/Math.sqrt(A*A+1);E=A*M;l=a+this._BTimesEMinor2*E*E*E;D=e-this._ATimesE2*M*M*M;const u=l/D,C=1/Math.sqrt(u*u+1),m=u*C;const f=Math.atan2(l,D)*Constants.RAD2DEG;const d=this._A/Math.sqrt(1-this._E2*m*m);const R=Math.abs(C)>Math.abs(m)?e/C-d:a/m-d*(1-this._E2);s.x=o;s.y=f;s.z=R}isEqual(t,s,n,i,a,o){return isEqualLonLat(t,s,i,a)||isEqualPoles(s,n,a,o)}geodesicDistance(t,s){return this.geodesicDistanceImpl(t.x,t.y,Math.cos(t.y*Constants.DEG2RAD),s.x,s.y,Math.cos(s.y*Constants.DEG2RAD))}rhumblineDistance(t,s){return this.rhumblineDistanceImpl(t.x,t.y,s.x,s.y)}rhumblineDistanceImpl(t,s,n,i){if(Math.abs(i-s)<1e-8){const i=Math.abs(normalizeLon(n-t))*Constants.DEG2RAD;const a=s*Constants.DEG2RAD;const o=Math.cos(a);const h=1-o*o;return this._A*i*o/Math.sqrt(1-this._E2*h)}const a=this.rhumblineAzimuthRad(t,s,n,i);const o=this.meridionalArcDistance(s);const h=undefined;return(this.meridionalArcDistance(i)-o)/Math.cos(a)}forwardAzimuth2D(t,s){if(this.isSphere())return forwardAzimuth2DUtil(t,s);else return this.forwardAzimuth2DVincenty(t.x,t.y,s.x,s.y)}rhumblineAzimuth2D(t,s){return Constants.RAD2DEG*this.rhumblineAzimuthRad(t.x,t.y,s.x,s.y)}rhumblineAzimuthRad(t,s,n,i){if(90-Math.abs(s)<EPSILON||90-Math.abs(i)<EPSILON)return s<i?0:Math.PI;const a=this.a;const o=this.e;const h=n-t;if(h>180)t+=360;else if(h<-180)t-=360;const e=a*t*Constants.DEG2RAD;const r=Math.sin(s*Constants.DEG2RAD);const c=this.mercatorLatitudeToY(s,r,o,a);const _=a*n*Constants.DEG2RAD;const M=Math.sin(i*Constants.DEG2RAD);const E=this.mercatorLatitudeToY(i,M,o,a);const l=Math.atan2(_-e,E-c);if(l<0)return l+2*Math.PI;return l}mercatorLatitudeToY(t,s,n,i){const a=Math.tan(Math.PI/4+t*Math.PI/360);const o=n*s;const h=Math.pow((1-o)/(1+o),n/2);return i*Math.log(a*h)}geodesicPositionAtFractionSFCT(t,s,n,i){if(this.isSphere())return greatCirclePointAtFractionSFCT(t,s,n,i);else return this.geodesicPositionAtFractionVincentySFCT(t.x,t.y,s.x,s.y,n,i)}geodesicPositionSFCT(t,s,n,i){if(s<1e-4){i.x=t.x;i.y=t.y;return i}const a=this._B*(Math.sin(t.y*Constants.DEG2RAD)/Math.cos(t.y*Constants.DEG2RAD))/this._A,o=Math.atan(a),h=Math.cos(o),e=Math.sin(o),r=n*Constants.DEG2RAD,c=Math.cos(r),_=Math.sin(r);const M=this._F/16;let E,l,D,A,u;let C,m;let f,d,R,G;const F=Math.atan2(a,c);const b=h*_;const B=b*b;const y=1-B;const S=y*this._EMinor2;const L=1+S/16384*(4096+S*(-768+S*(320-175*S)));const O=S/1024*(256+S*(-128+S*(74-47*S)));E=G=s/(this._B*L);l=Math.cos(E);D=Math.sin(E);let g=0;do{C=2*F+E;m=Math.cos(C);f=l*(-1+2*m*m);d=m*(-3+4*D*D)*(-3+4*m*m);A=O*D*(m+O/4*(f-O/6*d));u=E;E=G+A;l=Math.cos(E);D=Math.sin(E);if(Math.abs(E-u)<1e-10)break;g++}while(g<4);f=e*l+h*D*c;R=e*D-h*l*c;d=(1-this._F)*Math.sqrt(B+R*R);const P=Constants.RAD2DEG*Math.atan2(f,d);f=D*_;d=h*l-e*D*c;const p=Math.atan2(f,d);const T=M*y*(4+this._F*(4-3*y));f=m+T*l*(-1+2*m*m);d=(1-T)*this._F*b*(E+T*D*f);const x=p-d;i.x=normalizeLon(t.x+Constants.RAD2DEG*x);i.y=P;return i}rhumblinePositionSFCT(t,s,n,i){const a=.1;let o,h;if(Math.abs(n-90)<a||Math.abs(n-270)<a||Math.abs(n+90)<a||Math.abs(n+270)<a){if(Math.abs(n-270)<a||Math.abs(n+90)<a)s=-s;const i=Math.cos(t.y*Constants.DEG2RAD);const e=1-i*i;const r=s*Math.sqrt(1-this._E2*e)/(i*this._A);o=normalizeLon(t.x+r*Constants.RAD2DEG);h=t.y}else{const i=s*Math.cos(n*Constants.DEG2RAD)+this.meridionalArcDistance(t.y);const a=this._A;const e=this._E;const r=this._E2;const c=r*r;const _=undefined;const M=i/(a*(1-1/4*r-3/64*c-5/256*(c*r)));const E=Math.sqrt(1-r);const l=(1-E)/(1+E);const D=l*l;const A=l*D;const u=D*D;const C=3/2*l-27/32*A;const m=21/16*D-55/32*u;const f=151/96*A;const d=1097/512*u;const R=Math.cos(M);const G=Math.sin(M);const F=R*R-G*G;const b=2*R*G;const B=F*F-b*b;const y=2*F*b;const S=undefined;const L=undefined;const O=M+C*b+m*y+f*(y*F+B*b)+d*(2*B*y);h=O*Constants.RAD2DEG;let g=0;let P=0;while(h>90||h<-90)if(h>90){h=180-h;P++;if(1===(1&P))g=-180;else g=0}else if(h<-90){h=-180-h;P++;if(1===(1&P))g=180;else g=0}const p=Math.tan(n*Constants.DEG2RAD);const T=this.mercatorLatitudeToY(t.y,Math.sin(t.y*Constants.DEG2RAD),e,a);const x=this.mercatorLatitudeToY(h,Math.sin(O),e,a);o=g+t.x+p*(x-T)/a*Constants.RAD2DEG;if(Math.abs(t.y+90)<EPSILON||Math.abs(t.y-90)<EPSILON)o=t.x}i.x=o;i.y=h}geodesicDistanceImpl(t,s,n,i,a,o){if(this.isEqual(t,s,n,i,a,o))return 0;t=isPole(n)?0:t;i=isPole(o)?0:i;if(this.isSphere())return this._A*greatCircleDistanceLL(t,s,n,i,a,o)*Constants.DEG2RAD;else return this.geodesicDistanceVincenty(t,s,i,a)}geodesicDistanceVincenty(t,s,n,i){const a=Math.atan(this._B*Math.tan(s*Constants.DEG2RAD)/this._A);const o=Math.atan(this._B*Math.tan(i*Constants.DEG2RAD)/this._A);const h=Math.cos(a),e=Math.cos(o),r=Math.sin(a),c=Math.sin(o);let _,M,E,l,D,A,u,C,m,f,d,R,G;const F=this._F/16;_=(n-t)*Constants.DEG2RAD;const b=_;let B=0;do{M=Math.sin(_);E=Math.cos(_);l=e*M;D=h*c-r*e*E;u=Math.sqrt(l*l+D*D);C=r*c+h*e*E;m=Math.atan2(u,C);f=h*e*M/u;d=1-f*f;if(d<1e-14)R=0;else R=C-2*r*c/d;G=F*d*(4+this._F*(4-3*d));A=_;l=R+G*C*(-1+2*R*R);D=(1-G)*this._F*f*(m+G*u*l);_=b+D;if(Math.abs(_-A)<1e-10)break;B++}while(B<4);const y=d*this._EMinor2;const S=1+y/16384*(4096+y*(-768+y*(320-175*y)));const L=y/1024*(256+y*(-128+y*(74-47*y)));l=C*(-1+2*R*R);D=R*(-3+4*u*u)*(-3+4*R*R);const O=L*u*(R+L/4*(l-L/6*D));return this._B*S*(m-O)}forwardAzimuth2DVincenty(t,s,n,i){if(this.isEqual(t,s,Math.cos(s*Constants.DEG2RAD),n,i,Math.cos(i*Constants.DEG2RAD)))return 0;const a=Math.atan(this._B*Math.tan(s*Constants.DEG2RAD)/this._A),o=Math.atan(this._B*Math.tan(i*Constants.DEG2RAD)/this._A);const h=Math.cos(a),e=Math.cos(o),r=Math.sin(a),c=Math.sin(o);let _,M,E,l,D,A,u,C;let m,f,d;let R,G,F,b;const B=this._F/16;_=(n-t)*Constants.DEG2RAD;M=_;E=_;C=2*M;l=Math.sin(M);D=Math.cos(M);for(let t=0;t<4;t++){A=e*l;u=h*c-r*e*D;m=Math.sqrt(A*A+u*u);f=r*c+h*e*D;d=Math.atan2(m,f);R=h*e*l/m;G=1-R*R;if(G<1e-14)F=0;else F=f-2*r*c/G;b=B*G*(4+this._F*(4-3*G));C=M;A=F+b*f*(-1+2*F*F);u=(1-b)*this._F*R*(d+b*m*A);M=E+u;l=Math.sin(M);D=Math.cos(M);if(Math.abs(M-C)<1e-10)break}const y=Math.atan2(e*l,h*c-r*e*D);if(y<0)return y+2*Math.PI;else return y}geodesicPositionAtFractionVincentySFCT(t,s,n,i,a,o){if(this.isEqual(t,s,Math.cos(s*Constants.DEG2RAD),n,i,Math.cos(i*Constants.DEG2RAD))){o.x=t;o.y=s;return o}let h,e,r;let c,_;let M,E;let l,D,A,u,C;let m,f,d;let R,G,F,b;const B=this._F/16,y=this._B/this._A;const S=y*Math.tan(s*Constants.DEG2RAD);const L=y*Math.tan(i*Constants.DEG2RAD);const O=Math.atan(S);const g=Math.atan(L);const P=Math.cos(O);const p=Math.cos(g);const T=Math.sin(O);const x=Math.sin(g);const z=(n-t)*Constants.DEG2RAD;const I=z;let q=z;let v=2*q;let N=Math.sin(q);let w=Math.cos(q);const V=1e-10*Math.abs(q);let j=0;do{l=p*N;D=P*x-T*p*w;r=Math.sqrt(l*l+D*D);e=T*x+P*p*w;h=Math.atan2(r,e);m=P*p*N/r;f=m*m;d=1-f;if(d<1e-14)E=0;else E=e-2*T*x/d;C=B*d*(4+this._F*(4-3*d));v=q;l=E+C*e*(-1+2*E*E);D=(1-C)*this._F*m*(h+C*r*l);q=I+D;N=Math.sin(q);w=Math.cos(q);if(Math.abs(q-v)<V)break;j++}while(j<4);const W=d*this._EMinor2;const Y=1+W/16384*(4096+W*(-768+W*(320-175*W)));const U=W/1024*(256+W*(-128+W*(74-47*W)));l=e*(-1+2*E*E);D=E*(-3+4*r*r)*(-3+4*E*E);c=U*r*(E+U/4*(l-U/6*D));const k=this._B*Y*(h-c);const H=Math.atan2(p*N,P*x-T*p*w);const J=a*k;const K=Math.cos(H);const Q=Math.sin(H);const X=Math.atan2(S,K);h=u=J/(this._B*Y);e=Math.cos(h);r=Math.sin(h);const Z=1e-10*Math.abs(h);let $=0;do{M=2*X+h;E=Math.cos(M);l=e*(-1+2*E*E);D=E*(-3+4*r*r)*(-3+4*E*E);c=U*r*(E+U/4*(l-U/6*D));_=h;h=u+c;e=Math.cos(h);r=Math.sin(h);if(Math.abs(h-_)<Z)break;$++}while($<4);l=T*e+P*r*K;A=T*r-P*e*K;D=(1-this._F)*Math.sqrt(f+A*A);R=Constants.RAD2DEG*Math.atan2(l,D);l=r*Q;D=P*e-T*r*K;G=Math.atan2(l,D);C=B*d*(4+this._F*(4-3*d));l=E+C*e*(-1+2*E*E);D=(1-C)*this._F*m*(h+C*r*l);b=G-D;F=normalizeLon(t+Constants.RAD2DEG*b);o.x=F;o.y=R;return o}intersects2DLS(t,s,n,i){return intersects2DLS(this,t,s,n,i)}intersection2DLSSFCT(t,s,n,i,a){const o=undefined;if(1!=intersection2DLineSegments(t,s,n,i,this,.01,a,a.copy()))throw new ProgrammingError("Number of intersection points should be 1.")}get a(){return this._A}get b(){return this._B}get oneOverF(){return this._1OverF}get f(){return this._F}get e(){return this._E}get e2(){return this._E2}get eMinor2(){return this._EMinor2}get n(){return this._N}get name(){let t=this._name;if(null==t)if(EPSILON>=Math.abs(this._A-Constants.WGS_1984_A)&&EPSILON>=Math.abs(this._1OverF-Constants.WGS_1984_1OverF))t="WGS_1984";else t=EMPTY_STRING;return t}get auxRadius(){return this._A}get conformalRadius(){const t=this.n;const s=t*t;return this._A*(1+s/4+s*s/64)/(1+t)}static from(t){const s=new Ellipsoid;s.initializeA1OverF(t.a,t.oneOverF);if(isString(t.name))s._name=t.name;return s}static fromAB(t){const s=new Ellipsoid;s.initializeAB(t.a,t.b);if(isString(t.name))s._name=t.name;return s}hashCode(t){t.appendDouble(this._A);t.appendDouble(this._B)}}function isEqualLonLat(t,s,n,i){return Math.abs(n-t)<Constants.COORD_TOLERANCE&&Math.abs(i-s)<Constants.COORD_TOLERANCE}function isEqualPoles(t,s,n,i){return isPole(s)&&isPole(i)&&Math.abs(t-n)<Constants.COORD_TOLERANCE}function isPole(t){return Math.abs(t)<Constants.COORD_TOLERANCE}export const DEFAULT=Ellipsoid.createWGS84();