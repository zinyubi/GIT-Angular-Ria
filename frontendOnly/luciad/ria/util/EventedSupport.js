import{ProgrammingError}from"../error/ProgrammingError.js";class CallbackWrapper{constructor(){this.handles=[];this.firstListenerAddedHandles=[];this.lastListenerRemovedHandles=[]}apply(e){for(let t=this.handles.length-1;t>=0;--t){const s=this.handles[t];if(s.callBack)s.callBack.apply(s.context,e)}}remove(e){this.handles=this.handles.filter((t=>t!=e));if(0===this.handles.length)for(const e of this.lastListenerRemovedHandles)if(e.callBack)e.callBack()}addCallback(e,t){const s={callBack:e,context:t,remove:()=>this.remove(s)};this.handles.unshift(s);if(1===this.handles.length)for(const e of this.firstListenerAddedHandles)if(e.callBack)e.callBack();return s}addFirstListenerAddedCallback(e){const t={callBack:e,remove:()=>this.removeFirstListenerAddedHandle(t)};this.firstListenerAddedHandles.push(t);if(this.handles.length>=1)e();return t}removeFirstListenerAddedHandle(e){this.firstListenerAddedHandles=this.firstListenerAddedHandles.filter((t=>t!=e))}addLastListenerRemovedCallback(e){const t={callBack:e,remove:()=>this.removeLastListenerRemovedCallback(t)};this.lastListenerRemovedHandles.push(t);return t}removeLastListenerRemovedCallback(e){this.lastListenerRemovedHandles=this.lastListenerRemovedHandles.filter((t=>t!=e))}}export class EventedSupport{constructor(e=[],t=false){if(t&&0===e.length)throw new ProgrammingError(`No supported events are provided`);for(const t of e){const e=new CallbackWrapper;this.callbacks[t]=e;Object.assign(this,{["emit"+t+"Event"]:function(...t){e.apply(t)}})}this._strictEventNames=e.join(", ");this._strictEventsMode=t}getOrCreateCallbackWrapper(e){const t=this.callbacks;let s=t[e];if(!s){if(this._strictEventsMode)throw new ProgrammingError(`Event "${e}" not supported. Can only subscribe to following events: ${this._strictEventNames}`);s=new CallbackWrapper;t[e]=s}return s}on(e,t,s){if(!t)throw new ProgrammingError(`No callback provided when subscribing for '${e}' events`);const r=undefined;return this.getOrCreateCallbackWrapper(e).addCallback(t,s)}onFirstListenerAdded(e,t){const s=undefined;return this.getOrCreateCallbackWrapper(e).addFirstListenerAddedCallback(t)}onLastListenerRemoved(e,t){const s=undefined;return this.getOrCreateCallbackWrapper(e).addLastListenerRemovedCallback(t)}emit(e,...t){const s=this.callbacks[e];if(s)s.apply(t)}canHandle(e){if(this._strictEventsMode)return this._strictEventNames.indexOf(e)>=0;return true}get callbacks(){if(!this._callbacks)this._callbacks={};return this._callbacks}static on(e,t,s,r){return e.on(t,s,r)}static once(e,t,s,r){const a=e.on(t,((...e)=>{a.remove();s.apply(r,e)}),r);return a}static pausable(e,t,s,r){let a=true;const n=e.on(t,(()=>{if(a){const e=new Array;e.push(this);e.push(arguments);s.apply(e)}}),r);n.pause=()=>{a=false};n.resume=()=>{a=true};return n}}export function createOptimizedEventedSupport(e=[],t=false){return new EventedSupport(e,t)}