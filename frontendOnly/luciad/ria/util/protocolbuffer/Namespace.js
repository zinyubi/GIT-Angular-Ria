import{constructors}from"./constructors.js";import{isEnum,isField,isNamespace,isReflectionObject,isService,isType}from"./interfaces.js";import{ReflectionObject}from"./ReflectionObject.js";import*as util from"./util.js";import{isString}from"./util/lang.js";export class Namespace extends ReflectionObject{static className="Namespace";constructor(e,t){super(e,t);this._PB_NAMESPACE=true;this.nested=void 0;this._nestedArray=null}get nestedArray(){return this._nestedArray||(this._nestedArray=util.toArray(this.nested))}static fromJSON(e,t){return new Namespace(e,t.options).addJSON(t.nested)}static arrayToJSON(e,t){if(!(e&&e.length))return;const s={};for(let r=0;r<e.length;++r)s[e[r].name]=e[r].toJSON(t);return s}toJSON(e){const{options:t,nestedArray:s}=this;const r={};if(t)r.options=t;const i=Namespace.arrayToJSON(s,e);if(i)r.nested=i;return r}addJSON(e){const t=this;if(e)for(let s=Object.keys(e),r=0;r<s.length;++r){const i=e[s[r]];const o=(void 0!==i.fields?constructors.Type:void 0!==i.values?constructors.Enum:void 0!==i.methods?constructors.Service:void 0!==i.id?constructors.Field:constructors.Namespace).fromJSON(s[r],i);t.add(o)}return this}get(e){return this.nested?.[e]??null}getEnum(e){const t=this.get(e);if(isEnum(t))return t.values;throw Error(`no such enum: ${e}`)}add(e){if(!(isField(e)&&void 0!==e.extend||isType(e)||isEnum(e)||isService(e)||isNamespace(e)))throw TypeError("object must be a valid nested object");if(!this.nested)this.nested={};else{const t=this.get(e.name);if(t)if(isNamespace(t)&&isNamespace(e)&&!(isType(t)||isService(t))){const s=t.nestedArray;for(let t=0;t<s.length;++t)e.add(s[t]);this.remove(t);if(!this.nested)this.nested={};e.setOptions(t.options,true)}else throw Error(`duplicate name '${e.name}' in ${this}`)}this.nested[e.name]=e;e.onAdd(this);return clearCache(this)}remove(e){if(!isReflectionObject(e))throw TypeError("object must be a ReflectionObject");if(e.parent!==this)throw Error(e+" is not a member of "+this);delete this.nested?.[e.name];if(this.nested&&!Object.keys(this.nested).length)this.nested=void 0;e.onRemove(this);return clearCache(this)}define(e,t){if(isString(e))e=e.split(".");else if(!Array.isArray(e))throw TypeError("illegal path");if(e&&e.length&&""===e[0])throw Error("path must be relative");let s=this;while(e.length>0){const t=e.shift();const r=s.nested?.[t];if(!r){s.add(s=new Namespace(t));continue}if(isNamespace(r)){s=r;continue}throw Error("path conflicts with non-namespace objects")}if(t)s.addJSON(t);return s}resolveAll(){const e=this.nestedArray;let t=0;while(t<e.length){const s=e[t++];isNamespace(s)?s.resolveAll():s.resolve()}return this.resolve()}lookup(e,t,s){if(!e.length)return this;if("."===e)return this.root;const r=isString(e)?e.split("."):e;const i="boolean"===typeof t?t:s??false;const o="boolean"===typeof t||void 0===t?void 0:Array.isArray(t)?t:[t];if(""===r[0])return this.root.lookup(r.slice(1),i);let n=this.get(r[0]);if(n){if(1===r.length){if(!o||0!==o.filter((e=>e(n))).length)return n}else if(isNamespace(n)&&(n=n.lookup(r.slice(1),o,true)))return n}else{const{nestedArray:e}=this;for(let t=0;t<e.length;++t){const s=e[t];if(isNamespace(s)&&(n=s.lookup(r,o,true)))return n}}if(null===this.parent||i)return null;return this.parent.lookup(r,o)}lookupType(e){const t=this.lookup(e,[isType]);if(!t)throw Error(`no such type: ${e}`);return t}lookupEnum(e){const t=this.lookup(e,[isEnum]);if(!t)throw Error("no such Enum '"+e+"' in "+this);return t}lookupTypeOrEnum(e){const t=this.lookup(e,[isType,isEnum]);if(!t)throw Error("no such Type or Enum '"+e+"' in "+this);return t}lookupService(e){const t=this.lookup(e,[isService]);if(!t)throw Error("no such Service '"+e+"' in "+this);return t}}function clearCache(e){e._nestedArray=null;return e}