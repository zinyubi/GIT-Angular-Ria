import{CoordinateType}from"../reference/CoordinateType.js";import{ProgrammingError}from"../error/ProgrammingError.js";import{Ellipse}from"./Ellipse.js";import{XYZBounds}from"./XYZBounds.js";import*as XYEllipseUtil from"./XYEllipseUtil.js";import{normalizeAngle}from"../util/Cartesian.js";import{isNumber}from"../util/Lang.js";export class XYZEllipse extends Ellipse{constructor(e,t,r,i,o){super();this._reference=this.validateReference(e);this._compareReferenceStrict(t.reference,"XYZEllipse::the center point reference must be equal to the ellipse reference");this._center=t.copy();if(!isNumber(r))throw new ProgrammingError("XYZEllipse::cannot create a without a");this._semiMajorAxis=r;if(!isNumber(i))throw new ProgrammingError("XYZEllipse::cannot create a without b");this._semiMinorAxis=i;if(!isNumber(o))throw new ProgrammingError("XYZEllipse::cannot create a without rotationAzimuth");this._rotationAzimuth=normalizeAngle(o)}get coordinateType(){return CoordinateType.CARTESIAN}copy(){return new XYZEllipse(this.reference,this.center,this.a,this.b,this.rotationAzimuth)}get bounds(){return this._cache.memoize("cached-bounding-box",(()=>{const e=new XYZBounds(this.reference,[0,0,0,0,0,0]);XYEllipseUtil.calculateBounds(this.center,this.a,this.b,90-this.rotationAzimuth,e);return e}))}contains2DCoordinates(e,t){return this.bounds.contains2DCoordinates(e,t)&&XYEllipseUtil.contains2D(this.center,this.a,this.b,90-this.rotationAzimuth,e,t)}interpolate(e,t){return XYEllipseUtil.interpolate(this,e,t)}updatePoint(e,t,r){return XYEllipseUtil.updatePoint(this,e,t,r)}}