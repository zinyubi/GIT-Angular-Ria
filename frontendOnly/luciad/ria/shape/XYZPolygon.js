import{CoordinateType}from"../reference/CoordinateType.js";import{PolygonOrientation}from"./PolygonOrientation.js";import{XYZBounds}from"./XYZBounds.js";import{Polygon}from"./Polygon.js";import{orientation2D}from"../util/Cartesian.js";import{validatePointRepresentationForCreations}from"./ShapeWithPointList.js";import{isNumber}from"../util/Lang.js";export class XYZPolygon extends Polygon{constructor(t,o){super();this._reference=this.validateReference(t);this._orientation=PolygonOrientation.INVALID_ORIENTATION;this._coordinates=[validatePointRepresentationForCreations(o,this)]}get coordinateType(){return CoordinateType.CARTESIAN}get bounds(){if(0===this.pointCount)return null;if(!this._bounds){const t=new XYZBounds(this.reference);const o=this._coordinates[0];const n=o.length;const i=o[0];t.move3DToCoordinates(...i);for(let i=1;i<n;i++)t.includeCoordinate3D(...o[i]);this._bounds=t}return this._bounds}get orientation(){if(this._orientation===PolygonOrientation.INVALID_ORIENTATION)this._orientation=orientation2D(super.getSimplePoints());return this._orientation}set orientation(t){this._orientation=t}copy(){return new XYZPolygon(this.reference,super.copyRing())}contains2DCoordinates(t,o){const n=this.pointCount;if(n<=2||!this.bounds||!this.bounds.contains2DCoordinates(t,o))return false;let i;let e;let r;let s;let a;let l=0;const u=t;const c=o;let{x:f,y:p}=this.getPoint(n-1);for(let t=0;t<n;f=i,p=e,t++){const o=this.getPoint(t);i=o.x;e=o.y;if(e===p)continue;if(i<f){if(u>=f)continue;r=i}else{if(u>=i)continue;r=f}if(e<p){if(c<e||c>=p)continue;if(u<r){l++;continue}s=u-i;a=c-e}else{if(c<p||c>=e)continue;if(u<r){l++;continue}s=u-f;a=c-p}if(s<a/(p-e)*(f-i))l++}return 0!==(1&l)}implMove(t,o,n,i){t[0]=o;t[1]=n;if(isNumber(i))t[2]=i}implTranslate(t,o,n,i=0){t[0]+=o;t[1]+=n;t[2]+=i}}