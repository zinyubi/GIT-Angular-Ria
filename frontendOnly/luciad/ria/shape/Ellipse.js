import{buildCache}from"../util/Cacher.js";import{Shape}from"./Shape.js";import{ShapeType}from"./ShapeType.js";import{ShapeUtil}from"./ShapeUtil.js";import{ProgrammingError}from"../error/ProgrammingError.js";import{normalizeAngle}from"../util/Cartesian.js";export class Ellipse extends Shape{_semiMajorAxis=0;_semiMinorAxis=0;_rotationAzimuth=0;_cache=buildCache();get type(){return ShapeType.ELLIPSE}get center(){return this._center}get a(){return this._semiMajorAxis}set a(e){if(e<0)throw new ProgrammingError(`a length should be positive number, but was: ${e}`);this._semiMajorAxis=e;this._cache.invalidate()}get b(){return this._semiMinorAxis}set b(e){if(e<0)throw new ProgrammingError(`b length should be positive number, but was: ${e}`);this._semiMinorAxis=e;this._cache.invalidate()}get rotationAzimuth(){return this._rotationAzimuth}set rotationAzimuth(e){this._rotationAzimuth=normalizeAngle(e);this._cache.invalidate()}translate2D(e,t){this.center.translate2D(e,t);this._cache.invalidate()}move2DToCoordinates(e,t){this.center.move2DToCoordinates(e,t);this._cache.invalidate()}move2DToPoint(e){this.compareReference(e.reference,e.coordinateType);this.move2DToCoordinates(e.x,e.y)}toString(){return`Ellipse[center${this.center.toString(true)}, a[${this.a}], b[${this.b}], rotationAzimuth[${this.rotationAzimuth}]]`}hashCode(e){e.appendUInt32(this.type);this.center.hashCode(e);e.appendDouble(this.a);e.appendDouble(this.b);e.appendDouble(this.rotationAzimuth)}equals(e){if(this===e)return true;if(!ShapeUtil.referencesEqual(this.reference,e.reference))return false;return this.type===e.type&&this.a===e.a&&this.b===e.b&&this.rotationAzimuth===e.rotationAzimuth&&this.center.equals(e.center)}invalidate(){this._cache.invalidate()}get focusPoint(){return this.center}}export function isEllipse(e){return ShapeType.contains(ShapeType.ELLIPSE,e.type)}