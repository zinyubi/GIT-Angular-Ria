import{Shape}from"./Shape.js";import{ProgrammingError}from"../error/ProgrammingError.js";import{ShapeUtil}from"./ShapeUtil.js";export class PointList extends Shape{}class LineWrapper extends PointList{constructor(t,e,i){super();this._delegatePointList=t;this._startIndex=e;this._endIndex=i;if(i<e)throw new ProgrammingError("Wrap around is not supported")}get pointCount(){if(this._endIndex<this._startIndex)return this._delegatePointList.pointCount-this._startIndex+this._endIndex+1;else return this._endIndex-this._startIndex+1}get bounds(){return this._delegatePointList.bounds}get coordinateType(){return this._delegatePointList.coordinateType}get focusPoint(){return this._delegatePointList.focusPoint}get reference(){return this._delegatePointList.reference}get type(){return this._delegatePointList.type}getPoint(t){return this._delegatePointList.getPoint(this.delegateIndex(t))}contains2D(t,e){return this._delegatePointList.contains2D(t,e)}contains2DPoint(t){return this._delegatePointList.contains2DPoint(t)}contains2DCoordinates(t,e){return this._delegatePointList.contains2DCoordinates(t,e)}toString(){return`SubListOf[${this._delegatePointList.toString()}],[${this._startIndex},${this._endIndex}]`}delegateIndex(t){if(t<0||t>this.pointCount)throw new ProgrammingError(`Index ${t} is not in [0, ${this.pointCount}[`);return(this._startIndex+t)%this._delegatePointList.pointCount}copy(){return new LineWrapper(this._delegatePointList.copy(),this._startIndex,this._endIndex)}insertPoint(t,e){const i=t===this.pointCount?this._endIndex+1:this.delegateIndex(t);this._delegatePointList.insertPoint(i,e);this._endIndex++}removePoint(t){this._delegatePointList.removePoint(this.delegateIndex(t));this._endIndex--}move2DPoint(t,e,i){this._delegatePointList.move2DPoint(this.delegateIndex(t),e,i)}move3DPoint(t,e,i,n){this._delegatePointList.move3DPoint(this.delegateIndex(t),e,i,n)}translatePoint(t,e,i,n){this._delegatePointList.translatePoint(this.delegateIndex(t),e,i,n)}translate(t,e,i){for(let n=0;n<this.pointCount;n++)this.translatePoint(n,t,e,i)}translate2D(t,e){for(let i=0;i<this.pointCount;i++)this.translatePoint(i,t,e,0)}hashCode(t){return this._delegatePointList.hashCode(t)}equals(t){if(this===t)return true;if(t.pointCount!==this.pointCount||!ShapeUtil.referencesEqual(this.reference,t.reference))return false;let e=true;for(let i=0;e&&i<this.pointCount;i++)e=this.getPoint(i).equals(t.getPoint(i));return e}getPointCoordinates(t){return this._delegatePointList.getPointCoordinates(this.delegateIndex(t))}getSimplePoint(t){return this._delegatePointList.getSimplePoint(this.delegateIndex(t))}getSimplePointSFCT(t,e){return this._delegatePointList.getSimplePointSFCT(this.delegateIndex(t),e)}getCoordinateArray(t){const e=undefined;return this._delegatePointList.getCoordinateArray(t).slice(3*this._startIndex,3*(this._endIndex+1))}getSimplePoints(){const t=undefined;return this._delegatePointList.getSimplePoints().slice(this._startIndex,this._endIndex+1)}}class LineWrapper2 extends PointList{constructor(t,e,i,n,s){super();this._before=t;this._delegatePointList=e;this._delegateOffset=i+(t?-1:0);this._after=s;this._pointCount=n+(t?1:0)+(s?1:0);this._count=n;this._offset=i}get pointCount(){return this._pointCount}get bounds(){return this._delegatePointList.bounds}get coordinateType(){return this._delegatePointList.coordinateType}get focusPoint(){return this._delegatePointList.focusPoint}get reference(){return this._delegatePointList.reference}get type(){return this._delegatePointList.type}hashCode(t){return this._delegatePointList.hashCode(t)}getPoint(t){if(null!==this._before&&0===t)return this._before;else if(null!==this._after&&t===this._pointCount-1)return this._after;else return this._delegatePointList.getPoint(this._delegateOffset+t)}contains2D(t,e){return this._delegatePointList.contains2D(t,e)}contains2DPoint(t){return this._delegatePointList.contains2DPoint(t)}contains2DCoordinates(t,e){return this._delegatePointList.contains2DCoordinates(t,e)}toString(){return`SubListOf[${this._delegatePointList.toString()}],[${this._offset},${this._offset+this._count}]`}copy(){return new LineWrapper2(this._before.copy(),this._delegatePointList.copy(),this._offset,this._count,this._after.copy())}insertPoint(t,e){this._delegatePointList.insertPoint(t,e)}removePoint(t){this._delegatePointList.removePoint(t)}move2DPoint(t,e,i){this._delegatePointList.move2DPoint(t,e,i)}move3DPoint(t,e,i,n){this._delegatePointList.move3DPoint(t,e,i,n)}translatePoint(t,e,i,n){this._delegatePointList.translatePoint(t,e,i,n)}translate(t,e,i){for(let n=0;n<this.pointCount;n++)this.translatePoint(n,t,e,i)}translate2D(t,e){for(let i=0;i<this.pointCount;i++)this.translatePoint(i,t,e,0)}equals(t){if(this===t)return true;if(t.pointCount!==this.pointCount||!ShapeUtil.referencesEqual(this.reference,t.reference))return false;let e=true;for(let i=0;e&&i<this.pointCount;i++)e=this.getPoint(i).equals(t.getPoint(i));return e}getPointCoordinates(t){const e=this._delegateOffset+t;return this._delegatePointList.getPointCoordinates(e)}getSimplePoint(t){const e=this._delegateOffset+t;return this._delegatePointList.getSimplePoint(e)}getSimplePointSFCT(t,e){const i=this._delegateOffset+t;return this._delegatePointList.getSimplePointSFCT(i,e)}getCoordinateArray(t){const e=undefined;return this._delegatePointList.getCoordinateArray(t).slice(3*this._delegateOffset,3*(this._delegateOffset+this.pointCount))}getSimplePoints(){const t=undefined;return this._delegatePointList.getSimplePoints().slice(this._delegateOffset,this._delegateOffset+this.pointCount)}}export function subLine(t,e,i){if(0===e&&i===t.pointCount-1)return t;return new LineWrapper(t,e,i)}export function subPointListUsingRelativePositions(t,e,i,n,s){if(!t&&0===i&&n===e.pointCount&&!s)return e;return new LineWrapper2(t,e,i,n,s)}