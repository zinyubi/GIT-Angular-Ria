import{InvalidReferenceError}from"../error/InvalidReferenceError.js";import{ProgrammingError}from"../error/ProgrammingError.js";import{Vector3 as Vector3Internal}from"../geometry/mesh/math/Vector3.js";import{CoordinateType}from"../reference/CoordinateType.js";import{Shape}from"./Shape.js";import{ShapeType}from"./ShapeType.js";import{XYZBounds}from"./XYZBounds.js";import{XYZPoint}from"./XYZPoint.js";import{VecMath}from"../util/VecMath.js";import{Matrix4}from"../geometry/mesh/math/Matrix4.js";export class OrientedBox extends Shape{_cache={};constructor(e,r){super();this._reference=e;this._boxCorners=r;this.clearCache()}contains2DPoint(e){if(this.reference&&!this.reference.equals(e.reference))throw new InvalidReferenceError("OrientedBox.contains2DPoint: given reference does not equal oriented box reference. Please transform it first.");if(null===this.reference&&null!==e.reference)throw new InvalidReferenceError("OrientedBox.contains2DPoint: given reference does not equal oriented box reference. Please transform it first.");return super.contains2DPoint(e)}contains2DCoordinates(e,r){const t=[[0,1,2],[0,2,3],[4,5,6],[4,6,7],[1,2,6],[1,6,5],[0,3,7],[0,7,4],[0,1,5],[0,5,4],[3,2,6],[3,6,7]];for(const n of t){const t=this._boxCorners[n[0]];const o=this._boxCorners[n[1]];const s=this._boxCorners[n[2]];const i=new Vector3Internal(t.x,t.y,0);const c=new Vector3Internal(o.x,o.y,0);const a=new Vector3Internal(s.x,s.y,0);if(pointInTriangle2D(new Vector3Internal(e,r,0),i,c,a))return true}return false}contains3DPoint(e){if(e.reference&&!e.reference.equals(this.reference))throw new ProgrammingError("OrientedBox.contains3DPoint: the point reference is not supported");return this.contains3DCoordinates(e.x,e.y,e.z)}contains3DCoordinates(e,r,t){return containsPoint(this._boxCorners,new Vector3Internal(e,r,t))}copy(){const e=[];for(let r=0;r<this._boxCorners.length;r++)e.push({x:this._boxCorners[r].x,y:this._boxCorners[r].y,z:this._boxCorners[r].z});return new OrientedBox(this._reference,e)}equals(e){if(!e)return false;if(e.type!==ShapeType.ORIENTED_BOX)return false;if(!this._referencesEqual(this._reference,e.reference))return false;const r=e.getCorners();for(let e=0;e<this._boxCorners.length;e++){if(this._boxCorners[e].x!==r[e].x)return false;if(this._boxCorners[e].y!==r[e].y)return false;if(this._boxCorners[e].z!==r[e].z)return false}return true}hashCode(e){e.appendUInt32(this.type);for(let r=0;r<this._boxCorners.length;r++){e.appendDouble(this._boxCorners[r].x);e.appendDouble(this._boxCorners[r].y);e.appendDouble(this._boxCorners[r].z)}}getCorners(){return this._boxCorners}getCornerPoints(){const e=[];for(let r=0;r<this._boxCorners.length;r++)e.push(new XYZPoint(this.reference,[this._boxCorners[r].x,this._boxCorners[r].y,this._boxCorners[r].z]));return e}toString(){let e="OrientedBox[";for(let r=0;r<this._boxCorners.length;r++){e+=`(${this._boxCorners[r].x},${this._boxCorners[r].y},${this._boxCorners[r].z})`;if(r!==this._boxCorners.length-1)e+=","}e+="]";return e}translate2D(e,r){this.translate3D(e,r,0)}translate3D(e,r,t){for(const n of this._boxCorners){n.x+=e;n.y+=r;n.z+=t}this.clearCache()}transform(e){const r=[];for(let t=0;t<this._boxCorners.length;t++)r.push(e.transform(this._boxCorners[t]));this._boxCorners=r;if(e.outputReference)this._reference=e.outputReference;this.clearCache()}clearCache(){this._cache={}}invalidate(){this.clearCache()}get focusPoint(){if(!this._cache?.focusPoint)this._cache.focusPoint=findCenter(this.reference,this._boxCorners);return this._cache.focusPoint}get bounds(){if(!this._cache?.bounds)this._cache.bounds=calculateBounds(this.reference,this._boxCorners);return this._cache.bounds}get coordinateType(){return CoordinateType.CARTESIAN}get type(){return ShapeType.ORIENTED_BOX}}function findCenter(e,r){let t=r[0].x;let n=r[0].y;let o=r[0].z;for(let e=1;e<r.length;e++){t+=r[e].x;n+=r[e].y;o+=r[e].z}t/=r.length;n/=r.length;o/=r.length;return new XYZPoint(e,[t,n,o])}function calculateBounds(e,r){const{x:t,y:n,z:o}=r[0];const s=new XYZPoint(e,[t,n,o]);const i=new XYZBounds(e,[t,0,n,0,o,0]);for(let e=1;e<r.length;e++){s.move3DToCoordinates(r[e].x,r[e].y,r[e].z);i.setToIncludePoint3D(s)}return i}function pointInTriangle2D(e,r,t,n){const o=new Vector3Internal(e.x,e.y,0);const s=new Vector3Internal(r.x,r.y,0);const i=new Vector3Internal(t.x,t.y,0);const c=new Vector3Internal(n.x,n.y,0);const a=(new Vector3Internal).subVectors(s,c);const h=(new Vector3Internal).subVectors(s,i);const f=(new Vector3Internal).subVectors(s,o);const l=a.dot(a);const x=a.dot(h);const u=a.dot(f);const p=h.dot(h);const C=h.dot(f);const m=1/(l*p-x*x);const _=(p*u-x*C)*m;const b=(l*C-x*u)*m;return _>=0&&b>=0&&_+b<1}function containsPoint(e,r){const t=e.map((({x:e,y:r,z:t})=>new Vector3Internal(e,r,t)));const n=t[7];const o=t[3];const s=t[6];const i=VecMath.sub([o,n]);const c=VecMath.sub([s,n]);const a=VecMath.cross(i,c);const h=new Matrix4;h.makeBasis(i,c,a);const f=(new Matrix4).getInverse(h);const l=t.map((e=>e.clone().applyMatrix4(f)));const x=l.map((e=>e.x));const u=l.map((e=>e.y));const p=l.map((e=>e.z));const{x:C,y:m,z:_}=r.applyMatrix4(f);return C>=Math.min(...x)&&C<=Math.max(...x)&&m>=Math.min(...u)&&m<=Math.max(...u)&&_>=Math.min(...p)&&_<=Math.max(...p)}